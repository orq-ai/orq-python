"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from orq_ai_sdk import models, utils
from orq_ai_sdk._hooks import HookContext
from orq_ai_sdk.models import createtranslationop as models_createtranslationop
from orq_ai_sdk.types import OptionalNullable, UNSET
from orq_ai_sdk.utils import get_security_from_env
from orq_ai_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional, Union


class Translations(BaseSDK):
    def create(
        self,
        *,
        model: str,
        prompt: Optional[str] = None,
        enable_logging: Optional[bool] = True,
        diarize: Optional[bool] = False,
        response_format: Optional[
            models_createtranslationop.CreateTranslationResponseFormat
        ] = None,
        tag_audio_events: Optional[bool] = True,
        num_speakers: Optional[float] = None,
        timestamps_granularity: Optional[
            models_createtranslationop.CreateTranslationTimestampsGranularity
        ] = "word",
        temperature: Optional[float] = None,
        orq: Optional[
            Union[
                models_createtranslationop.CreateTranslationOrq,
                models_createtranslationop.CreateTranslationOrqTypedDict,
            ]
        ] = None,
        file: Optional[
            Union[
                models_createtranslationop.CreateTranslationFile,
                models_createtranslationop.CreateTranslationFileTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateTranslationResponseBody:
        r"""Create translation

        :param model: ID of the model to use
        :param prompt: An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
        :param enable_logging: When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
        :param diarize: Whether to annotate which speaker is currently talking in the uploaded file.
        :param response_format: The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
        :param tag_audio_events: Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
        :param num_speakers: The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
        :param timestamps_granularity: The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
        :param temperature: The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
        :param orq:
        :param file: The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateTranslationRequestBody(
            model=model,
            prompt=prompt,
            enable_logging=enable_logging,
            diarize=diarize,
            response_format=response_format,
            tag_audio_events=tag_audio_events,
            num_speakers=num_speakers,
            timestamps_granularity=timestamps_granularity,
            temperature=temperature,
            orq=utils.get_pydantic_model(orq, Optional[models.CreateTranslationOrq]),
            file=utils.get_pydantic_model(file, Optional[models.CreateTranslationFile]),
        )

        req = self._build_request(
            method="POST",
            path="/v2/gateway/audio/translations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.CreateTranslationRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createTranslation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.CreateTranslationResponseBody, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                models.CreateTranslationRouterAudioTranslationsResponseBodyData,
                http_res,
            )
            raise models.CreateTranslationRouterAudioTranslationsResponseBody(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        model: str,
        prompt: Optional[str] = None,
        enable_logging: Optional[bool] = True,
        diarize: Optional[bool] = False,
        response_format: Optional[
            models_createtranslationop.CreateTranslationResponseFormat
        ] = None,
        tag_audio_events: Optional[bool] = True,
        num_speakers: Optional[float] = None,
        timestamps_granularity: Optional[
            models_createtranslationop.CreateTranslationTimestampsGranularity
        ] = "word",
        temperature: Optional[float] = None,
        orq: Optional[
            Union[
                models_createtranslationop.CreateTranslationOrq,
                models_createtranslationop.CreateTranslationOrqTypedDict,
            ]
        ] = None,
        file: Optional[
            Union[
                models_createtranslationop.CreateTranslationFile,
                models_createtranslationop.CreateTranslationFileTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateTranslationResponseBody:
        r"""Create translation

        :param model: ID of the model to use
        :param prompt: An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
        :param enable_logging: When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
        :param diarize: Whether to annotate which speaker is currently talking in the uploaded file.
        :param response_format: The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
        :param tag_audio_events: Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
        :param num_speakers: The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
        :param timestamps_granularity: The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
        :param temperature: The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
        :param orq:
        :param file: The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateTranslationRequestBody(
            model=model,
            prompt=prompt,
            enable_logging=enable_logging,
            diarize=diarize,
            response_format=response_format,
            tag_audio_events=tag_audio_events,
            num_speakers=num_speakers,
            timestamps_granularity=timestamps_granularity,
            temperature=temperature,
            orq=utils.get_pydantic_model(orq, Optional[models.CreateTranslationOrq]),
            file=utils.get_pydantic_model(file, Optional[models.CreateTranslationFile]),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/gateway/audio/translations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.CreateTranslationRequestBody
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createTranslation",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.CreateTranslationResponseBody, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                models.CreateTranslationRouterAudioTranslationsResponseBodyData,
                http_res,
            )
            raise models.CreateTranslationRouterAudioTranslationsResponseBody(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)
