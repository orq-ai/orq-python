"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
import pydantic
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


Role2 = Literal["tool",]


Role1 = Literal["user",]


RunAgentRoleTypedDict = TypeAliasType("RunAgentRoleTypedDict", Union[Role1, Role2])
r"""Message role (user or tool for continuing executions)"""


RunAgentRole = TypeAliasType("RunAgentRole", Union[Role1, Role2])
r"""Message role (user or tool for continuing executions)"""


RunAgentPartsAgentsRequestKind = Literal["tool_result",]


class FiveTypedDict(TypedDict):
    kind: RunAgentPartsAgentsRequestKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class Five(BaseModel):
    kind: RunAgentPartsAgentsRequestKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


RunAgentPartsAgentsKind = Literal["tool_call",]


class Parts4TypedDict(TypedDict):
    kind: RunAgentPartsAgentsKind
    tool_name: str
    tool_call_id: str
    arguments: Dict[str, Any]
    metadata: NotRequired[Dict[str, Any]]


class Parts4(BaseModel):
    kind: RunAgentPartsAgentsKind

    tool_name: str

    tool_call_id: str

    arguments: Dict[str, Any]

    metadata: Optional[Dict[str, Any]] = None


RunAgentPartsKind = Literal["file",]


class File2TypedDict(TypedDict):
    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class File2(BaseModel):
    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class File1TypedDict(TypedDict):
    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class File1(BaseModel):
    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


PartsFileTypedDict = TypeAliasType(
    "PartsFileTypedDict", Union[File1TypedDict, File2TypedDict]
)


PartsFile = TypeAliasType("PartsFile", Union[File1, File2])


class Parts3TypedDict(TypedDict):
    kind: RunAgentPartsKind
    file: PartsFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class Parts3(BaseModel):
    kind: RunAgentPartsKind

    file: PartsFile

    metadata: Optional[Dict[str, Any]] = None


PartsKind = Literal["data",]


class Parts2TypedDict(TypedDict):
    kind: PartsKind
    data: Dict[str, Any]
    metadata: NotRequired[Dict[str, Any]]


class Parts2(BaseModel):
    kind: PartsKind

    data: Dict[str, Any]

    metadata: Optional[Dict[str, Any]] = None


Kind = Literal["text",]


class Parts1TypedDict(TypedDict):
    kind: Kind
    text: str


class Parts1(BaseModel):
    kind: Kind

    text: str


PartsTypedDict = TypeAliasType(
    "PartsTypedDict",
    Union[
        Parts1TypedDict,
        Parts2TypedDict,
        Parts3TypedDict,
        FiveTypedDict,
        Parts4TypedDict,
    ],
)


Parts = TypeAliasType("Parts", Union[Parts1, Parts2, Parts3, Five, Parts4])


class MessageTypedDict(TypedDict):
    r"""The A2A format message containing the task for the agent to perform."""

    role: RunAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[PartsTypedDict]
    r"""A2A message parts"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional message metadata"""


class Message(BaseModel):
    r"""The A2A format message containing the task for the agent to perform."""

    role: RunAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[Parts]
    r"""A2A message parts"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional message metadata"""


class ContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class Contact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class RunAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class RunAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class MemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class Memory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


RunAgentConfigurationType = Literal["query",]


class Configuration2TypedDict(TypedDict):
    type: RunAgentConfigurationType
    query: str


class Configuration2(BaseModel):
    type: RunAgentConfigurationType

    query: str


ConfigurationType = Literal["last_user_message",]


class Configuration1TypedDict(TypedDict):
    type: ConfigurationType


class Configuration1(BaseModel):
    type: ConfigurationType


ConfigurationTypedDict = TypeAliasType(
    "ConfigurationTypedDict", Union[Configuration1TypedDict, Configuration2TypedDict]
)
r"""Defines the configuration settings which can either be for a user message or a text entry."""


Configuration = TypeAliasType("Configuration", Union[Configuration1, Configuration2])
r"""Defines the configuration settings which can either be for a user message or a text entry."""


class KnowledgeBasesTypedDict(TypedDict):
    configuration: ConfigurationTypedDict
    r"""Defines the configuration settings which can either be for a user message or a text entry."""


class KnowledgeBases(BaseModel):
    configuration: Configuration
    r"""Defines the configuration settings which can either be for a user message or a text entry."""


class TeamOfAgentsTypedDict(TypedDict):
    id: str
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class TeamOfAgents(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


RunAgentToolsAgentsRequestRequestBodySettings13Type = Literal["function",]


class ToolsFunctionTypedDict(TypedDict):
    name: str
    description: NotRequired[str]
    strict: NotRequired[bool]
    parameters: NotRequired[Dict[str, Any]]


class ToolsFunction(BaseModel):
    name: str

    description: Optional[str] = None

    strict: Optional[bool] = None

    parameters: Optional[Dict[str, Any]] = None


class ThirteenTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings13Type
    key: str
    function: ToolsFunctionTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    description: NotRequired[str]
    requires_approval: NotRequired[bool]


class Thirteen(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings13Type

    key: str

    function: ToolsFunction

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    display_name: Optional[str] = None

    description: Optional[str] = None

    requires_approval: Optional[bool] = False


ToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


RunAgentToolsAgentsRequestRequestBodySettings12Type = Literal["http",]


Method = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class BlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: Method
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, str]]
    r"""The headers to send with the request."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class Blueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: Method
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, str]] = None
    r"""The headers to send with the request."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


RunAgentToolsAgentsRequestRequestBodySettings12HTTPType = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


DefaultValueTypedDict = TypeAliasType("DefaultValueTypedDict", Union[str, float, bool])
r"""The default value of the argument."""


DefaultValue = TypeAliasType("DefaultValue", Union[str, float, bool])
r"""The default value of the argument."""


class ArgumentsTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings12HTTPType
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[DefaultValueTypedDict]
    r"""The default value of the argument."""


class Arguments(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings12HTTPType
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[DefaultValue] = None
    r"""The default value of the argument."""


class HTTPTypedDict(TypedDict):
    blueprint: BlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, ArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class HTTP(BaseModel):
    blueprint: Blueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, Arguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class TwelveTypedDict(TypedDict):
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: RunAgentToolsAgentsRequestRequestBodySettings12Type
    http: HTTPTypedDict
    id: NotRequired[str]
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    status: NotRequired[ToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]
    requires_approval: NotRequired[bool]


class Twelve(BaseModel):
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: RunAgentToolsAgentsRequestRequestBodySettings12Type

    http: HTTP

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "01K5X16BV17ZPH27JT1JZGNS5R"
    )

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    status: Optional[ToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettings11Type = Literal["current_date",]


class ElevenTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings11Type
    requires_approval: NotRequired[bool]


class Eleven(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings11Type

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettings10Type = Literal["query_knowledge_base",]


class TenTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings10Type
    requires_approval: NotRequired[bool]


class Ten(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings10Type

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettings9Type = Literal[
    "retrieve_knowledge_bases",
]


class NineTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings9Type
    requires_approval: NotRequired[bool]


class Nine(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings9Type

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettings8Type = Literal["retrieve_memory_stores",]


class EightTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings8Type
    requires_approval: NotRequired[bool]


class Eight(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings8Type

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettings7Type = Literal["delete_memory_document",]


class SevenTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettings7Type
    requires_approval: NotRequired[bool]


class Seven(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettings7Type

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodySettingsType = Literal["write_memory_store",]


class SixTypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodySettingsType
    requires_approval: NotRequired[bool]


class Six(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodySettingsType

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestRequestBodyType = Literal["query_memory_store",]


class Tools5TypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestRequestBodyType
    requires_approval: NotRequired[bool]


class Tools5(BaseModel):
    type: RunAgentToolsAgentsRequestRequestBodyType

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsRequestType = Literal["retrieve_agents",]


class Tools4TypedDict(TypedDict):
    type: RunAgentToolsAgentsRequestType
    requires_approval: NotRequired[bool]


class Tools4(BaseModel):
    type: RunAgentToolsAgentsRequestType

    requires_approval: Optional[bool] = False


RunAgentToolsAgentsType = Literal["call_sub_agent",]


class Tools3TypedDict(TypedDict):
    type: RunAgentToolsAgentsType
    requires_approval: NotRequired[bool]


class Tools3(BaseModel):
    type: RunAgentToolsAgentsType

    requires_approval: Optional[bool] = False


RunAgentToolsType = Literal["web_scraper",]


class Tools2TypedDict(TypedDict):
    type: RunAgentToolsType
    requires_approval: NotRequired[bool]


class Tools2(BaseModel):
    type: RunAgentToolsType

    requires_approval: Optional[bool] = False


ToolsType = Literal["google_search",]


class Tools1TypedDict(TypedDict):
    type: ToolsType
    requires_approval: NotRequired[bool]


class Tools1(BaseModel):
    type: ToolsType

    requires_approval: Optional[bool] = False


ToolsTypedDict = TypeAliasType(
    "ToolsTypedDict",
    Union[
        SevenTypedDict,
        Tools2TypedDict,
        Tools3TypedDict,
        Tools4TypedDict,
        Tools5TypedDict,
        SixTypedDict,
        Tools1TypedDict,
        EightTypedDict,
        NineTypedDict,
        TenTypedDict,
        ElevenTypedDict,
        ThirteenTypedDict,
        TwelveTypedDict,
    ],
)


Tools = TypeAliasType(
    "Tools",
    Union[
        Seven,
        Tools2,
        Tools3,
        Tools4,
        Tools5,
        Six,
        Tools1,
        Eight,
        Nine,
        Ten,
        Eleven,
        Thirteen,
        Twelve,
    ],
)


ToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class SettingsTypedDict(TypedDict):
    tools: List[ToolsTypedDict]
    tool_approval_required: NotRequired[ToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""
    max_iterations: NotRequired[int]
    r"""Maximum iterations before the agent must provide its best answer."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for task execution."""


class Settings(BaseModel):
    tools: List[Tools]

    tool_approval_required: Optional[ToolApprovalRequired] = "none"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""

    max_iterations: Optional[int] = 15
    r"""Maximum iterations before the agent must provide its best answer."""

    max_execution_time: Optional[int] = 120
    r"""Maximum time (in seconds) for task execution."""


class RunAgentRequestBodyTypedDict(TypedDict):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""
    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""
    role: str
    r"""Specifies the agent's function and area of expertise."""
    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""
    message: MessageTypedDict
    r"""The A2A format message containing the task for the agent to perform."""
    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    settings: SettingsTypedDict
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[ContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[RunAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[MemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    description: NotRequired[str]
    r"""A brief summary of the agent's purpose."""
    system_prompt: NotRequired[str]
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""
    memory_stores: NotRequired[List[str]]
    knowledge_bases: NotRequired[List[KnowledgeBasesTypedDict]]
    team_of_agents: NotRequired[List[TeamOfAgentsTypedDict]]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""


class RunAgentRequestBody(BaseModel):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""

    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""

    role: str
    r"""Specifies the agent's function and area of expertise."""

    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""

    message: Message
    r"""The A2A format message containing the task for the agent to perform."""

    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    settings: Settings

    task_id: Annotated[Optional[str], pydantic.Field(alias="taskId")] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[Contact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[RunAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[Memory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    description: Optional[str] = None
    r"""A brief summary of the agent's purpose."""

    system_prompt: Optional[str] = None
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""

    memory_stores: Optional[List[str]] = None

    knowledge_bases: Optional[List[KnowledgeBases]] = None

    team_of_agents: Optional[List[TeamOfAgents]] = None
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""


RunAgentKind = Literal["task",]
r"""A2A entity type"""


RunAgentState = Literal[
    "submitted",
    "working",
    "input-required",
    "completed",
    "failed",
    "canceled",
    "rejected",
    "auth-required",
    "unknown",
]
r"""Current task state"""


RunAgentAgentsKind = Literal["message",]


RunAgentAgentsRole = Literal[
    "user",
    "agent",
    "tool",
    "system",
]
r"""Extended A2A message role"""


class RunAgentMessageTypedDict(TypedDict):
    r"""Optional status message"""

    kind: RunAgentAgentsKind
    message_id: str
    role: RunAgentAgentsRole
    r"""Extended A2A message role"""
    parts: List[Any]


class RunAgentMessage(BaseModel):
    r"""Optional status message"""

    kind: RunAgentAgentsKind

    message_id: Annotated[str, pydantic.Field(alias="messageId")]

    role: RunAgentAgentsRole
    r"""Extended A2A message role"""

    parts: List[Any]


class RunAgentStatusTypedDict(TypedDict):
    r"""Task status information"""

    state: RunAgentState
    r"""Current task state"""
    timestamp: NotRequired[str]
    r"""ISO timestamp of status update"""
    message: NotRequired[RunAgentMessageTypedDict]
    r"""Optional status message"""


class RunAgentStatus(BaseModel):
    r"""Task status information"""

    state: RunAgentState
    r"""Current task state"""

    timestamp: Optional[str] = None
    r"""ISO timestamp of status update"""

    message: Optional[RunAgentMessage] = None
    r"""Optional status message"""


class RunAgentResponseBodyTypedDict(TypedDict):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""
    context_id: str
    r"""The context ID (workspace ID)"""
    kind: RunAgentKind
    r"""A2A entity type"""
    status: RunAgentStatusTypedDict
    r"""Task status information"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Task metadata"""


class RunAgentResponseBody(BaseModel):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""

    context_id: Annotated[str, pydantic.Field(alias="contextId")]
    r"""The context ID (workspace ID)"""

    kind: RunAgentKind
    r"""A2A entity type"""

    status: RunAgentStatus
    r"""Task status information"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Task metadata"""
