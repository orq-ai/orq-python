"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .createagentresponse import CreateAgentResponse, CreateAgentResponseTypedDict
from .errorpart import ErrorPart, ErrorPartTypedDict
from .filepart import FilePart, FilePartTypedDict
from .responsestreamingevent import (
    ResponseStreamingEvent,
    ResponseStreamingEventTypedDict,
)
from .textpart import TextPart, TextPartTypedDict
from .toolresultpart import ToolResultPart, ToolResultPartTypedDict
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    eventstreaming,
    get_discriminator,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import (
    Annotated,
    NotRequired,
    TypeAliasType,
    TypedDict,
    deprecated,
)


RoleToolMessage = Literal["tool",]
r"""Message containing tool execution results"""


RoleUserMessage = Literal["user",]
r"""Message from the end user"""


CreateAgentResponseRequestRoleTypedDict = TypeAliasType(
    "CreateAgentResponseRequestRoleTypedDict", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


CreateAgentResponseRequestRole = TypeAliasType(
    "CreateAgentResponseRequestRole", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


CreateAgentResponseRequestPublicMessagePartTypedDict = TypeAliasType(
    "CreateAgentResponseRequestPublicMessagePartTypedDict",
    Union[
        TextPartTypedDict,
        FilePartTypedDict,
        ErrorPartTypedDict,
        ToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


CreateAgentResponseRequestPublicMessagePart = Annotated[
    Union[
        Annotated[TextPart, Tag("text")],
        Annotated[FilePart, Tag("file")],
        Annotated[ToolResultPart, Tag("tool_result")],
        Annotated[ErrorPart, Tag("error")],
    ],
    Discriminator(lambda m: get_discriminator(m, "kind", "kind")),
]
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class A2AMessageTypedDict(TypedDict):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: CreateAgentResponseRequestRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[CreateAgentResponseRequestPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class A2AMessage(BaseModel):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: CreateAgentResponseRequestRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[CreateAgentResponseRequestPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["messageId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class IdentityTypedDict(TypedDict):
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class Identity(BaseModel):
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class ContactTypedDict(TypedDict):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class Contact(BaseModel):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateAgentResponseRequestThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class CreateAgentResponseRequestThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateAgentResponseRequestMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class CreateAgentResponseRequestMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class ConversationTypedDict(TypedDict):
    r"""Conversation context for chat studio integration"""

    id: str
    r"""Unique ULID identifier for the conversation, prefixed with \"conv_\". Used to link agent executions to a specific conversation thread."""


class Conversation(BaseModel):
    r"""Conversation context for chat studio integration"""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""Unique ULID identifier for the conversation, prefixed with \"conv_\". Used to link agent executions to a specific conversation thread."""


class CreateAgentResponseRequestRequestBodyTypedDict(TypedDict):
    message: A2AMessageTypedDict
    r"""The A2A message to send to the agent (user input or tool results)"""
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    identity: NotRequired[IdentityTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[ContactTypedDict]
    r"""@deprecated Use identity instead. Information about the contact making the request."""
    thread: NotRequired[CreateAgentResponseRequestThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[CreateAgentResponseRequestMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""
    background: NotRequired[bool]
    r"""If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors."""
    stream: NotRequired[bool]
    r"""If true, returns Server-Sent Events (SSE) streaming response with real-time events. If false (default), returns standard JSON response."""
    conversation: NotRequired[ConversationTypedDict]
    r"""Conversation context for chat studio integration"""


class CreateAgentResponseRequestRequestBody(BaseModel):
    message: A2AMessage
    r"""The A2A message to send to the agent (user input or tool results)"""

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    identity: Optional[Identity] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Annotated[
        Optional[Contact],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    thread: Optional[CreateAgentResponseRequestThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[CreateAgentResponseRequestMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""

    background: Optional[bool] = False
    r"""If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors."""

    stream: Optional[bool] = False
    r"""If true, returns Server-Sent Events (SSE) streaming response with real-time events. If false (default), returns standard JSON response."""

    conversation: Optional[Conversation] = None
    r"""Conversation context for chat studio integration"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "task_id",
                "variables",
                "identity",
                "contact",
                "thread",
                "memory",
                "metadata",
                "background",
                "stream",
                "conversation",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateAgentResponseRequestRequestTypedDict(TypedDict):
    agent_key: str
    r"""The unique key of identifier of the agent to invoke"""
    request_body: CreateAgentResponseRequestRequestBodyTypedDict


class CreateAgentResponseRequestRequest(BaseModel):
    agent_key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique key of identifier of the agent to invoke"""

    request_body: Annotated[
        CreateAgentResponseRequestRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


class CreateAgentResponseRequestResponseBodyTypedDict(TypedDict):
    r"""Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details. In streaming mode, returns Server-Sent Events (SSE) with real-time events."""

    data: NotRequired[ResponseStreamingEventTypedDict]
    r"""Union of all possible streaming events. Each event has a type field for discrimination."""


class CreateAgentResponseRequestResponseBody(BaseModel):
    r"""Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details. In streaming mode, returns Server-Sent Events (SSE) with real-time events."""

    data: Optional[ResponseStreamingEvent] = None
    r"""Union of all possible streaming events. Each event has a type field for discrimination."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["data"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateAgentResponseRequestResponseTypedDict = TypeAliasType(
    "CreateAgentResponseRequestResponseTypedDict",
    Union[
        CreateAgentResponseTypedDict,
        Union[
            eventstreaming.EventStream[CreateAgentResponseRequestResponseBodyTypedDict],
            eventstreaming.EventStreamAsync[
                CreateAgentResponseRequestResponseBodyTypedDict
            ],
        ],
    ],
)


CreateAgentResponseRequestResponse = TypeAliasType(
    "CreateAgentResponseRequestResponse",
    Union[
        CreateAgentResponse,
        Union[
            eventstreaming.EventStream[CreateAgentResponseRequestResponseBody],
            eventstreaming.EventStreamAsync[CreateAgentResponseRequestResponseBody],
        ],
    ],
)


try:
    A2AMessage.model_rebuild()
except NameError:
    pass
try:
    Conversation.model_rebuild()
except NameError:
    pass
