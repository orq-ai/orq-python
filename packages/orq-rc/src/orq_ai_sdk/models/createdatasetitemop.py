"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .audiocontentpartschema import (
    AudioContentPartSchema,
    AudioContentPartSchemaTypedDict,
)
from .filecontentpartschema import FileContentPartSchema, FileContentPartSchemaTypedDict
from .imagecontentpartschema import (
    ImageContentPartSchema,
    ImageContentPartSchemaTypedDict,
)
from .reasoningpartschema import ReasoningPartSchema, ReasoningPartSchemaTypedDict
from .redactedreasoningpartschema import (
    RedactedReasoningPartSchema,
    RedactedReasoningPartSchemaTypedDict,
)
from .refusalpartschema import RefusalPartSchema, RefusalPartSchemaTypedDict
from .textcontentpartschema import TextContentPartSchema, TextContentPartSchemaTypedDict
from datetime import datetime
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
    parse_datetime,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CreateDatasetItemMessagesDatasetsRequestRequestBody5Role = Literal["tool",]
r"""The role of the messages author, in this case tool."""


CreateDatasetItemContentDatasetsRequest2TypedDict = TextContentPartSchemaTypedDict


CreateDatasetItemContentDatasetsRequest2 = TextContentPartSchema


CreateDatasetItemMessagesDatasetsRequestRequestBody5ContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestRequestBody5ContentTypedDict",
    Union[str, List[CreateDatasetItemContentDatasetsRequest2TypedDict]],
)
r"""The contents of the tool message."""


CreateDatasetItemMessagesDatasetsRequestRequestBody5Content = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestRequestBody5Content",
    Union[str, List[CreateDatasetItemContentDatasetsRequest2]],
)
r"""The contents of the tool message."""


CreateDatasetItemMessagesDatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


CreateDatasetItemMessagesTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class CreateDatasetItemMessagesCacheControlTypedDict(TypedDict):
    type: CreateDatasetItemMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[CreateDatasetItemMessagesTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class CreateDatasetItemMessagesCacheControl(BaseModel):
    type: CreateDatasetItemMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[CreateDatasetItemMessagesTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesToolMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsRequestRequestBody5Role
    r"""The role of the messages author, in this case tool."""
    content: CreateDatasetItemMessagesDatasetsRequestRequestBody5ContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""
    cache_control: NotRequired[CreateDatasetItemMessagesCacheControlTypedDict]


class CreateDatasetItemMessagesToolMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsRequestRequestBody5Role
    r"""The role of the messages author, in this case tool."""

    content: CreateDatasetItemMessagesDatasetsRequestRequestBody5Content
    r"""The contents of the tool message."""

    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""

    cache_control: Optional[CreateDatasetItemMessagesCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        nullable_fields = set(["tool_call_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CreateDatasetItemContentDatasets2TypedDict = TypeAliasType(
    "CreateDatasetItemContentDatasets2TypedDict",
    Union[
        RefusalPartSchemaTypedDict,
        RedactedReasoningPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ReasoningPartSchemaTypedDict,
    ],
)


CreateDatasetItemContentDatasets2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[RefusalPartSchema, Tag("refusal")],
        Annotated[ReasoningPartSchema, Tag("reasoning")],
        Annotated[RedactedReasoningPartSchema, Tag("redacted_reasoning")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateDatasetItemMessagesDatasetsRequestRequestBodyContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestRequestBodyContentTypedDict",
    Union[str, List[CreateDatasetItemContentDatasets2TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


CreateDatasetItemMessagesDatasetsRequestRequestBodyContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestRequestBodyContent",
    Union[str, List[CreateDatasetItemContentDatasets2]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


CreateDatasetItemMessagesDatasetsRequestRequestBodyRole = Literal["assistant",]
r"""The role of the messages author, in this case `assistant`."""


class CreateDatasetItemMessagesAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class CreateDatasetItemMessagesAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


CreateDatasetItemMessagesType = Literal["function",]
r"""The type of the tool. Currently, only `function` is supported."""


class CreateDatasetItemMessagesFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class CreateDatasetItemMessagesFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: CreateDatasetItemMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: CreateDatasetItemMessagesFunctionTypedDict
    thought_signature: NotRequired[str]
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""


class CreateDatasetItemMessagesToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: CreateDatasetItemMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: CreateDatasetItemMessagesFunction

    thought_signature: Optional[str] = None
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["thought_signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesAssistantMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsRequestRequestBodyRole
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[CreateDatasetItemMessagesDatasetsRequestRequestBodyContentTypedDict]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[CreateDatasetItemMessagesAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[CreateDatasetItemMessagesToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""


class CreateDatasetItemMessagesAssistantMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsRequestRequestBodyRole
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[
        CreateDatasetItemMessagesDatasetsRequestRequestBodyContent
    ] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[CreateDatasetItemMessagesAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[CreateDatasetItemMessagesToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["content", "refusal", "name", "audio", "tool_calls"])
        nullable_fields = set(["content", "refusal", "audio"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsRequestRole = Literal["user",]
r"""The role of the messages author, in this case `user`."""


CreateDatasetItem2Type = Literal["file",]
r"""The type of the content part. Always `file`."""


CreateDatasetItem2DatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


CreateDatasetItem2TTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class CreateDatasetItem2CacheControlTypedDict(TypedDict):
    type: CreateDatasetItem2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[CreateDatasetItem2TTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class CreateDatasetItem2CacheControl(BaseModel):
    type: CreateDatasetItem2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[CreateDatasetItem2TTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItem24TypedDict(TypedDict):
    type: CreateDatasetItem2Type
    r"""The type of the content part. Always `file`."""
    file: FileContentPartSchemaTypedDict
    r"""File data for the content part. Must contain either file_data or uri, but not both."""
    cache_control: NotRequired[CreateDatasetItem2CacheControlTypedDict]


class CreateDatasetItem24(BaseModel):
    type: CreateDatasetItem2Type
    r"""The type of the content part. Always `file`."""

    file: FileContentPartSchema
    r"""File data for the content part. Must contain either file_data or uri, but not both."""

    cache_control: Optional[CreateDatasetItem2CacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemContent2TypedDict = TypeAliasType(
    "CreateDatasetItemContent2TypedDict",
    Union[
        AudioContentPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ImageContentPartSchemaTypedDict,
        CreateDatasetItem24TypedDict,
    ],
)


CreateDatasetItemContent2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[ImageContentPartSchema, Tag("image_url")],
        Annotated[AudioContentPartSchema, Tag("input_audio")],
        Annotated[CreateDatasetItem24, Tag("file")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateDatasetItemMessagesDatasetsRequestContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestContentTypedDict",
    Union[str, List[CreateDatasetItemContent2TypedDict]],
)
r"""The contents of the user message."""


CreateDatasetItemMessagesDatasetsRequestContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsRequestContent",
    Union[str, List[CreateDatasetItemContent2]],
)
r"""The contents of the user message."""


class CreateDatasetItemMessagesUserMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsRequestRole
    r"""The role of the messages author, in this case `user`."""
    content: CreateDatasetItemMessagesDatasetsRequestContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesUserMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsRequestRole
    r"""The role of the messages author, in this case `user`."""

    content: CreateDatasetItemMessagesDatasetsRequestContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsRole = Literal["developer",]
r"""The role of the messages author, in this case  `developer`."""


CreateDatasetItemMessagesDatasetsContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the developer message."""


CreateDatasetItemMessagesDatasetsContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsContent", Union[str, List[TextContentPartSchema]]
)
r"""The contents of the developer message."""


class CreateDatasetItemMessagesDeveloperMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""
    content: CreateDatasetItemMessagesDatasetsContentTypedDict
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesDeveloperMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""

    content: CreateDatasetItemMessagesDatasetsContent
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesRole = Literal["system",]
r"""The role of the messages author, in this case `system`."""


CreateDatasetItemMessagesContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the system message."""


CreateDatasetItemMessagesContent = TypeAliasType(
    "CreateDatasetItemMessagesContent", Union[str, List[TextContentPartSchema]]
)
r"""The contents of the system message."""


class CreateDatasetItemMessagesSystemMessageTypedDict(TypedDict):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: CreateDatasetItemMessagesRole
    r"""The role of the messages author, in this case `system`."""
    content: CreateDatasetItemMessagesContentTypedDict
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesSystemMessage(BaseModel):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: CreateDatasetItemMessagesRole
    r"""The role of the messages author, in this case `system`."""

    content: CreateDatasetItemMessagesContent
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesTypedDict",
    Union[
        CreateDatasetItemMessagesSystemMessageTypedDict,
        CreateDatasetItemMessagesDeveloperMessageTypedDict,
        CreateDatasetItemMessagesUserMessageTypedDict,
        CreateDatasetItemMessagesToolMessageTypedDict,
        CreateDatasetItemMessagesAssistantMessageTypedDict,
    ],
)


CreateDatasetItemMessages = Annotated[
    Union[
        Annotated[CreateDatasetItemMessagesSystemMessage, Tag("system")],
        Annotated[CreateDatasetItemMessagesDeveloperMessage, Tag("developer")],
        Annotated[CreateDatasetItemMessagesUserMessage, Tag("user")],
        Annotated[CreateDatasetItemMessagesAssistantMessage, Tag("assistant")],
        Annotated[CreateDatasetItemMessagesToolMessage, Tag("tool")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


class CreateDatasetItemRequestBodyTypedDict(TypedDict):
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[CreateDatasetItemMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]


class CreateDatasetItemRequestBody(BaseModel):
    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[CreateDatasetItemMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["inputs", "messages", "expected_output"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemRequestTypedDict(TypedDict):
    dataset_id: str
    r"""The unique identifier of the dataset"""
    request_body: NotRequired[List[CreateDatasetItemRequestBodyTypedDict]]


class CreateDatasetItemRequest(BaseModel):
    dataset_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the dataset"""

    request_body: Annotated[
        Optional[List[CreateDatasetItemRequestBody]],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["RequestBody"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Role = Literal[
    "tool",
]
r"""The role of the messages author, in this case tool."""


CreateDatasetItemContentDatasetsResponse200ApplicationJSON2TypedDict = (
    TextContentPartSchemaTypedDict
)


CreateDatasetItemContentDatasetsResponse200ApplicationJSON2 = TextContentPartSchema


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict",
    Union[
        str, List[CreateDatasetItemContentDatasetsResponse200ApplicationJSON2TypedDict]
    ],
)
r"""The contents of the tool message."""


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Content = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Content",
    Union[str, List[CreateDatasetItemContentDatasetsResponse200ApplicationJSON2]],
)
r"""The contents of the tool message."""


CreateDatasetItemMessagesDatasetsResponse200Type = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


CreateDatasetItemMessagesDatasetsTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class CreateDatasetItemMessagesDatasetsCacheControlTypedDict(TypedDict):
    type: CreateDatasetItemMessagesDatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[CreateDatasetItemMessagesDatasetsTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class CreateDatasetItemMessagesDatasetsCacheControl(BaseModel):
    type: CreateDatasetItemMessagesDatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[CreateDatasetItemMessagesDatasetsTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesDatasetsToolMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Role
    r"""The role of the messages author, in this case tool."""
    content: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""
    cache_control: NotRequired[CreateDatasetItemMessagesDatasetsCacheControlTypedDict]


class CreateDatasetItemMessagesDatasetsToolMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Role
    r"""The role of the messages author, in this case tool."""

    content: (
        CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBody5Content
    )
    r"""The contents of the tool message."""

    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""

    cache_control: Optional[CreateDatasetItemMessagesDatasetsCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        nullable_fields = set(["tool_call_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CreateDatasetItemContentDatasetsResponse2002TypedDict = TypeAliasType(
    "CreateDatasetItemContentDatasetsResponse2002TypedDict",
    Union[
        RefusalPartSchemaTypedDict,
        RedactedReasoningPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ReasoningPartSchemaTypedDict,
    ],
)


CreateDatasetItemContentDatasetsResponse2002 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[RefusalPartSchema, Tag("refusal")],
        Annotated[ReasoningPartSchema, Tag("reasoning")],
        Annotated[RedactedReasoningPartSchema, Tag("redacted_reasoning")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict",
    Union[str, List[CreateDatasetItemContentDatasetsResponse2002TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContent",
    Union[str, List[CreateDatasetItemContentDatasetsResponse2002]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyRole = Literal[
    "assistant",
]
r"""The role of the messages author, in this case `assistant`."""


class CreateDatasetItemMessagesDatasetsAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class CreateDatasetItemMessagesDatasetsAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


CreateDatasetItemMessagesDatasetsResponseType = Literal["function",]
r"""The type of the tool. Currently, only `function` is supported."""


class CreateDatasetItemMessagesDatasetsFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class CreateDatasetItemMessagesDatasetsFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesDatasetsToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: CreateDatasetItemMessagesDatasetsResponseType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: CreateDatasetItemMessagesDatasetsFunctionTypedDict
    thought_signature: NotRequired[str]
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""


class CreateDatasetItemMessagesDatasetsToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: CreateDatasetItemMessagesDatasetsResponseType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: CreateDatasetItemMessagesDatasetsFunction

    thought_signature: Optional[str] = None
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["thought_signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItemMessagesDatasetsAssistantMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyRole
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[
            CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict
        ]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[CreateDatasetItemMessagesDatasetsAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[CreateDatasetItemMessagesDatasetsToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""


class CreateDatasetItemMessagesDatasetsAssistantMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyRole
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[
        CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONResponseBodyContent
    ] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[CreateDatasetItemMessagesDatasetsAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[CreateDatasetItemMessagesDatasetsToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["content", "refusal", "name", "audio", "tool_calls"])
        nullable_fields = set(["content", "refusal", "audio"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONRole = Literal["user",]
r"""The role of the messages author, in this case `user`."""


CreateDatasetItem2DatasetsResponseType = Literal["file",]
r"""The type of the content part. Always `file`."""


CreateDatasetItem2DatasetsResponse200Type = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


CreateDatasetItem2DatasetsTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class CreateDatasetItem2DatasetsCacheControlTypedDict(TypedDict):
    type: CreateDatasetItem2DatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[CreateDatasetItem2DatasetsTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class CreateDatasetItem2DatasetsCacheControl(BaseModel):
    type: CreateDatasetItem2DatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[CreateDatasetItem2DatasetsTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateDatasetItem2Datasets4TypedDict(TypedDict):
    type: CreateDatasetItem2DatasetsResponseType
    r"""The type of the content part. Always `file`."""
    file: FileContentPartSchemaTypedDict
    r"""File data for the content part. Must contain either file_data or uri, but not both."""
    cache_control: NotRequired[CreateDatasetItem2DatasetsCacheControlTypedDict]


class CreateDatasetItem2Datasets4(BaseModel):
    type: CreateDatasetItem2DatasetsResponseType
    r"""The type of the content part. Always `file`."""

    file: FileContentPartSchema
    r"""File data for the content part. Must contain either file_data or uri, but not both."""

    cache_control: Optional[CreateDatasetItem2DatasetsCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemContentDatasetsResponse2TypedDict = TypeAliasType(
    "CreateDatasetItemContentDatasetsResponse2TypedDict",
    Union[
        AudioContentPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ImageContentPartSchemaTypedDict,
        CreateDatasetItem2Datasets4TypedDict,
    ],
)


CreateDatasetItemContentDatasetsResponse2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[ImageContentPartSchema, Tag("image_url")],
        Annotated[AudioContentPartSchema, Tag("input_audio")],
        Annotated[CreateDatasetItem2Datasets4, Tag("file")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContentTypedDict = (
    TypeAliasType(
        "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContentTypedDict",
        Union[str, List[CreateDatasetItemContentDatasetsResponse2TypedDict]],
    )
)
r"""The contents of the user message."""


CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContent",
    Union[str, List[CreateDatasetItemContentDatasetsResponse2]],
)
r"""The contents of the user message."""


class CreateDatasetItemMessagesDatasetsUserMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case `user`."""
    content: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesDatasetsUserMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case `user`."""

    content: CreateDatasetItemMessagesDatasetsResponse200ApplicationJSONContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsResponse200Role = Literal["developer",]
r"""The role of the messages author, in this case  `developer`."""


CreateDatasetItemMessagesDatasetsResponse200ContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200ContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the developer message."""


CreateDatasetItemMessagesDatasetsResponse200Content = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponse200Content",
    Union[str, List[TextContentPartSchema]],
)
r"""The contents of the developer message."""


class CreateDatasetItemMessagesDatasetsDeveloperMessageTypedDict(TypedDict):
    role: CreateDatasetItemMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case  `developer`."""
    content: CreateDatasetItemMessagesDatasetsResponse200ContentTypedDict
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesDatasetsDeveloperMessage(BaseModel):
    role: CreateDatasetItemMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case  `developer`."""

    content: CreateDatasetItemMessagesDatasetsResponse200Content
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemMessagesDatasetsResponseRole = Literal["system",]
r"""The role of the messages author, in this case `system`."""


CreateDatasetItemMessagesDatasetsResponseContentTypedDict = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponseContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the system message."""


CreateDatasetItemMessagesDatasetsResponseContent = TypeAliasType(
    "CreateDatasetItemMessagesDatasetsResponseContent",
    Union[str, List[TextContentPartSchema]],
)
r"""The contents of the system message."""


class CreateDatasetItemMessagesDatasetsSystemMessageTypedDict(TypedDict):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: CreateDatasetItemMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `system`."""
    content: CreateDatasetItemMessagesDatasetsResponseContentTypedDict
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class CreateDatasetItemMessagesDatasetsSystemMessage(BaseModel):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: CreateDatasetItemMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `system`."""

    content: CreateDatasetItemMessagesDatasetsResponseContent
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateDatasetItemDatasetsMessagesTypedDict = TypeAliasType(
    "CreateDatasetItemDatasetsMessagesTypedDict",
    Union[
        CreateDatasetItemMessagesDatasetsSystemMessageTypedDict,
        CreateDatasetItemMessagesDatasetsDeveloperMessageTypedDict,
        CreateDatasetItemMessagesDatasetsUserMessageTypedDict,
        CreateDatasetItemMessagesDatasetsToolMessageTypedDict,
        CreateDatasetItemMessagesDatasetsAssistantMessageTypedDict,
    ],
)


CreateDatasetItemDatasetsMessages = Annotated[
    Union[
        Annotated[CreateDatasetItemMessagesDatasetsSystemMessage, Tag("system")],
        Annotated[CreateDatasetItemMessagesDatasetsDeveloperMessage, Tag("developer")],
        Annotated[CreateDatasetItemMessagesDatasetsUserMessage, Tag("user")],
        Annotated[CreateDatasetItemMessagesDatasetsAssistantMessage, Tag("assistant")],
        Annotated[CreateDatasetItemMessagesDatasetsToolMessage, Tag("tool")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


CreateDatasetItemEvaluationsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


CreateDatasetItemEvaluationsDatasetsSource = Literal[
    "orq",
    "external",
]


CreateDatasetItemEvaluationsDatasetsType = Literal["string_array",]


class Evaluations3TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: CreateDatasetItemEvaluationsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: CreateDatasetItemEvaluationsDatasetsType
    values: List[str]
    source: NotRequired[CreateDatasetItemEvaluationsDatasetsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class Evaluations3(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: CreateDatasetItemEvaluationsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: CreateDatasetItemEvaluationsDatasetsType

    values: List[str]

    source: Optional[CreateDatasetItemEvaluationsDatasetsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-01-20T11:19:25.481Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EvaluationsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


CreateDatasetItemEvaluationsSource = Literal[
    "orq",
    "external",
]


CreateDatasetItemEvaluationsType = Literal["number",]


class Evaluations2TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: EvaluationsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: CreateDatasetItemEvaluationsType
    value: float
    source: NotRequired[CreateDatasetItemEvaluationsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class Evaluations2(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: EvaluationsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: CreateDatasetItemEvaluationsType

    value: float

    source: Optional[CreateDatasetItemEvaluationsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-01-20T11:19:25.480Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EvaluationType = Literal["human_review",]
r"""The type of evaluation"""


EvaluationsSource = Literal[
    "orq",
    "external",
]


EvaluationsType = Literal["string",]


class Evaluations1TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: EvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: EvaluationsType
    value: str
    source: NotRequired[EvaluationsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class Evaluations1(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: EvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: EvaluationsType

    value: str

    source: Optional[EvaluationsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-01-20T11:19:25.479Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


EvaluationsTypedDict = TypeAliasType(
    "EvaluationsTypedDict",
    Union[Evaluations1TypedDict, Evaluations2TypedDict, Evaluations3TypedDict],
)


Evaluations = Annotated[
    Union[
        Annotated[Evaluations1, Tag("string")],
        Annotated[Evaluations2, Tag("number")],
        Annotated[Evaluations3, Tag("string_array")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class CreateDatasetItemResponseBodyTypedDict(TypedDict):
    id: str
    r"""The unique identifier of the dataset item"""
    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""
    dataset_id: str
    r"""The unique identifier of the dataset"""
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[CreateDatasetItemDatasetsMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]
    evaluations: NotRequired[List[EvaluationsTypedDict]]
    r"""Evaluations associated with the datapoint"""
    snapshot_version: NotRequired[str]
    r"""The version of the dataset snapshot"""
    created_by_id: NotRequired[str]
    r"""The unique identifier of the user who created the dataset"""
    updated_by_id: NotRequired[str]
    r"""The unique identifier of the user who last updated the dataset"""
    created: NotRequired[datetime]
    r"""The date and time the resource was created"""
    updated: NotRequired[datetime]
    r"""The date and time the resource was last updated"""


class CreateDatasetItemResponseBody(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the dataset item"""

    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""

    dataset_id: str
    r"""The unique identifier of the dataset"""

    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[CreateDatasetItemDatasetsMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    evaluations: Optional[List[Evaluations]] = None
    r"""Evaluations associated with the datapoint"""

    snapshot_version: Optional[str] = None
    r"""The version of the dataset snapshot"""

    created_by_id: Optional[str] = None
    r"""The unique identifier of the user who created the dataset"""

    updated_by_id: Optional[str] = None
    r"""The unique identifier of the user who last updated the dataset"""

    created: Optional[datetime] = None
    r"""The date and time the resource was created"""

    updated: Optional[datetime] = parse_datetime("2026-01-20T11:19:12.098Z")
    r"""The date and time the resource was last updated"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "inputs",
                "messages",
                "expected_output",
                "evaluations",
                "snapshot_version",
                "created_by_id",
                "updated_by_id",
                "created",
                "updated",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
