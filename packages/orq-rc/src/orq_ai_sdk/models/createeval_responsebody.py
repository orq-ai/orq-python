"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .createeval_guardrail_config_evals_response_200_applicationjson_responsebody_4_2_type import (
    CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody42Type,
    CreateEvalResponseBodyFunction,
    CreateEvalResponseBodyFunctionTypedDict,
    Ragas,
    RagasTypedDict,
    Typescript,
    TypescriptTypedDict,
)
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import get_discriminator
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONNumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody42Type
    value: float
    operator: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONOperator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody42Type

    value: float

    operator: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody4Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONBooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody4Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody4Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalResponseBodyEvalsGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalResponseBodyEvalsGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONNumberTypedDict,
    ],
)


CreateEvalResponseBodyEvalsGuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONBoolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONNumber,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalResponseBodyEvalsType = Literal["python_eval",]


class ResponseBodyPythonTypedDict(TypedDict):
    id: str
    description: str
    code: str
    type: CreateEvalResponseBodyEvalsType
    key: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[CreateEvalResponseBodyEvalsGuardrailConfigTypedDict]


class ResponseBodyPython(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    code: str

    type: CreateEvalResponseBodyEvalsType

    key: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[CreateEvalResponseBodyEvalsGuardrailConfig] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyType = Literal[
    "number",
]


CreateEvalGuardrailConfigEvalsResponse200Operator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200NumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyType
    value: float
    operator: CreateEvalGuardrailConfigEvalsResponse200Operator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200Number(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyType

    value: float

    operator: CreateEvalGuardrailConfigEvalsResponse200Operator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONType = Literal["boolean",]


class CreateEvalGuardrailConfigEvalsResponse200BooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONType
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200Boolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalResponseBodyGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalResponseBodyGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200BooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200NumberTypedDict,
    ],
)


CreateEvalResponseBodyGuardrailConfig = Annotated[
    Union[
        Annotated[CreateEvalGuardrailConfigEvalsResponse200Boolean, Tag("boolean")],
        Annotated[CreateEvalGuardrailConfigEvalsResponse200Number, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalResponseBodyType = Literal["http_eval",]


ResponseBodyMethod = Literal[
    "GET",
    "POST",
]


class ResponseBodyHTTPTypedDict(TypedDict):
    id: str
    description: str
    type: CreateEvalResponseBodyType
    url: str
    method: ResponseBodyMethod
    headers: Dict[str, str]
    payload: Dict[str, Any]
    key: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[CreateEvalResponseBodyGuardrailConfigTypedDict]


class ResponseBodyHTTP(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: CreateEvalResponseBodyType

    url: str

    method: ResponseBodyMethod

    headers: Dict[str, str]

    payload: Dict[str, Any]

    key: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[CreateEvalResponseBodyGuardrailConfig] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200Type = Literal["number",]


CreateEvalGuardrailConfigEvalsResponseOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponseNumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200Type
    value: float
    operator: CreateEvalGuardrailConfigEvalsResponseOperator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponseNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200Type

    value: float

    operator: CreateEvalGuardrailConfigEvalsResponseOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponseType = Literal["boolean",]


class CreateEvalGuardrailConfigEvalsResponseBooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponseType
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponseBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponseType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ResponseBodyGuardrailConfigTypedDict = TypeAliasType(
    "ResponseBodyGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponseBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponseNumberTypedDict,
    ],
)


ResponseBodyGuardrailConfig = Annotated[
    Union[
        Annotated[CreateEvalGuardrailConfigEvalsResponseBoolean, Tag("boolean")],
        Annotated[CreateEvalGuardrailConfigEvalsResponseNumber, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


ResponseBodyType = Literal["json_schema",]


class ResponseBodyJSONTypedDict(TypedDict):
    id: str
    description: str
    type: ResponseBodyType
    schema_: str
    key: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[ResponseBodyGuardrailConfigTypedDict]


class ResponseBodyJSON(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: ResponseBodyType

    schema_: Annotated[str, pydantic.Field(alias="schema")]

    key: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[ResponseBodyGuardrailConfig] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM22Type = (
    Literal["number",]
)


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMOperator = (
    Literal[
        "eq",
        "ne",
        "gt",
        "gte",
        "lt",
        "lte",
    ]
)


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMNumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM22Type
    value: float
    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMOperator
    )
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMNumber(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM22Type

    value: float

    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMOperator
    )

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM2Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMBooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM2Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMBoolean(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLM2Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalLLMEvalsResponseGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalLLMEvalsResponseGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMNumberTypedDict,
    ],
)


CreateEvalLLMEvalsResponseGuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMBoolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMNumber,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalLLMEvalsResponseType = Literal["llm_eval",]


CreateEvalLLMEvalsMode = Literal["jury",]


class CreateEvalLLMEvalsResponseRetryTypedDict(TypedDict):
    count: NotRequired[int]
    on_codes: NotRequired[List[int]]


class CreateEvalLLMEvalsResponseRetry(BaseModel):
    count: Optional[int] = 2

    on_codes: Optional[List[int]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEvalLLMEvalsResponseFallbacksTypedDict(TypedDict):
    model: str


class CreateEvalLLMEvalsResponseFallbacks(BaseModel):
    model: str


class CreateEvalLLMJudgesTypedDict(TypedDict):
    model: str
    retry: NotRequired[CreateEvalLLMEvalsResponseRetryTypedDict]
    fallbacks: NotRequired[List[CreateEvalLLMEvalsResponseFallbacksTypedDict]]


class CreateEvalLLMJudges(BaseModel):
    model: str

    retry: Optional[CreateEvalLLMEvalsResponseRetry] = None

    fallbacks: Optional[List[CreateEvalLLMEvalsResponseFallbacks]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry", "fallbacks"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEvalLLMEvalsRetryTypedDict(TypedDict):
    count: NotRequired[int]
    on_codes: NotRequired[List[int]]


class CreateEvalLLMEvalsRetry(BaseModel):
    count: Optional[int] = 2

    on_codes: Optional[List[int]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEvalLLMEvalsFallbacksTypedDict(TypedDict):
    model: str


class CreateEvalLLMEvalsFallbacks(BaseModel):
    model: str


class CreateEvalLLMReplacementJudgesTypedDict(TypedDict):
    model: str
    retry: NotRequired[CreateEvalLLMEvalsRetryTypedDict]
    fallbacks: NotRequired[List[CreateEvalLLMEvalsFallbacksTypedDict]]


class CreateEvalLLMReplacementJudges(BaseModel):
    model: str

    retry: Optional[CreateEvalLLMEvalsRetry] = None

    fallbacks: Optional[List[CreateEvalLLMEvalsFallbacks]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry", "fallbacks"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalLLMTieValue = Literal["Tie",]


class CreateEvalLLMJuryTypedDict(TypedDict):
    judges: List[CreateEvalLLMJudgesTypedDict]
    replacement_judges: NotRequired[List[CreateEvalLLMReplacementJudgesTypedDict]]
    min_successful_judges: NotRequired[int]
    tie_value: NotRequired[CreateEvalLLMTieValue]


class CreateEvalLLMJury(BaseModel):
    judges: List[CreateEvalLLMJudges]

    replacement_judges: Optional[List[CreateEvalLLMReplacementJudges]] = None

    min_successful_judges: Optional[int] = 2

    tie_value: Optional[CreateEvalLLMTieValue] = "Tie"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["replacement_judges", "min_successful_judges", "tie_value"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEvalLLM2TypedDict(TypedDict):
    id: str
    description: str
    type: CreateEvalLLMEvalsResponseType
    prompt: str
    key: str
    mode: CreateEvalLLMEvalsMode
    jury: CreateEvalLLMJuryTypedDict
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[CreateEvalLLMEvalsResponseGuardrailConfigTypedDict]
    repetitions: NotRequired[int]


class CreateEvalLLM2(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: CreateEvalLLMEvalsResponseType

    prompt: str

    key: str

    mode: CreateEvalLLMEvalsMode

    jury: CreateEvalLLMJury

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[CreateEvalLLMEvalsResponseGuardrailConfig] = None

    repetitions: Optional[int] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config", "repetitions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMType = Literal[
    "number",
]


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Operator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1NumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMType
    value: float
    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Operator
    )
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Number(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1LLMType

    value: float

    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Operator
    )

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1BooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Boolean(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalLLMEvalsGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalLLMEvalsGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1BooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1NumberTypedDict,
    ],
)


CreateEvalLLMEvalsGuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Boolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody1Number,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalLLMEvalsType = Literal["llm_eval",]


CreateEvalLLMEvalsResponseMode = Literal["single",]


class CreateEvalLLM1TypedDict(TypedDict):
    id: str
    description: str
    type: CreateEvalLLMEvalsType
    prompt: str
    key: str
    mode: CreateEvalLLMEvalsResponseMode
    model: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[CreateEvalLLMEvalsGuardrailConfigTypedDict]
    repetitions: NotRequired[int]


class CreateEvalLLM1(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: CreateEvalLLMEvalsType

    prompt: str

    key: str

    mode: CreateEvalLLMEvalsResponseMode

    model: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[CreateEvalLLMEvalsGuardrailConfig] = None

    repetitions: Optional[int] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config", "repetitions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ResponseBodyLLMTypedDict = TypeAliasType(
    "ResponseBodyLLMTypedDict", Union[CreateEvalLLM1TypedDict, CreateEvalLLM2TypedDict]
)


ResponseBodyLLM = Annotated[
    Union[
        Annotated[CreateEvalLLM1, Tag("single")], Annotated[CreateEvalLLM2, Tag("jury")]
    ],
    Discriminator(lambda m: get_discriminator(m, "mode", "mode")),
]


CreateEvalResponseBodyTypedDict = TypeAliasType(
    "CreateEvalResponseBodyTypedDict",
    Union[
        ResponseBodyJSONTypedDict,
        ResponseBodyPythonTypedDict,
        CreateEvalResponseBodyFunctionTypedDict,
        TypescriptTypedDict,
        RagasTypedDict,
        ResponseBodyHTTPTypedDict,
        ResponseBodyLLMTypedDict,
    ],
)
r"""Successfully created an evaluator"""


CreateEvalResponseBody = TypeAliasType(
    "CreateEvalResponseBody",
    Union[
        ResponseBodyJSON,
        ResponseBodyPython,
        CreateEvalResponseBodyFunction,
        Typescript,
        Ragas,
        ResponseBodyHTTP,
        ResponseBodyLLM,
    ],
)
r"""Successfully created an evaluator"""


try:
    ResponseBodyPython.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyHTTP.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyJSON.model_rebuild()
except NameError:
    pass
try:
    CreateEvalLLM2.model_rebuild()
except NameError:
    pass
try:
    CreateEvalLLM1.model_rebuild()
except NameError:
    pass
