"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


UpdateAgentToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type = Literal[
    "function",
]
r"""Function tool type"""


class AgentToolInputCRUDFunctionToolTypedDict(TypedDict):
    r"""Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    r"""Function tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created function tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created function tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDFunctionTool(BaseModel):
    r"""Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    r"""Function tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created function tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created function tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type = Literal[
    "code",
]
r"""Code execution tool type"""


class AgentToolInputCRUDCodeExecutionToolTypedDict(TypedDict):
    r"""Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    r"""Code execution tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created code tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created code tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDCodeExecutionTool(BaseModel):
    r"""Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    r"""Code execution tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created code tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created code tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type = Literal[
    "http",
]
r"""HTTP tool type"""


class AgentToolInputCRUDHTTPToolTypedDict(TypedDict):
    r"""Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    r"""HTTP tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created HTTP tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created HTTP tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDHTTPTool(BaseModel):
    r"""Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id."""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    r"""HTTP tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created HTTP tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created HTTP tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type = Literal[
    "current_date",
]


class AgentToolInputCRUDCurrentDateToolTypedDict(TypedDict):
    r"""Returns the current date and time"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDCurrentDateTool(BaseModel):
    r"""Returns the current date and time"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type = Literal[
    "query_knowledge_base",
]


class AgentToolInputCRUDQueryKnowledgeBaseToolTypedDict(TypedDict):
    r"""Queries knowledge bases for information"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDQueryKnowledgeBaseTool(BaseModel):
    r"""Queries knowledge bases for information"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type = Literal[
    "retrieve_knowledge_bases",
]


class AgentToolInputCRUDRetrieveKnowledgeBasesToolTypedDict(TypedDict):
    r"""Lists available knowledge bases"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDRetrieveKnowledgeBasesTool(BaseModel):
    r"""Lists available knowledge bases"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type = Literal[
    "delete_memory_document",
]


class AgentToolInputCRUDDeleteMemoryDocumentToolTypedDict(TypedDict):
    r"""Deletes documents from memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDDeleteMemoryDocumentTool(BaseModel):
    r"""Deletes documents from memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type = Literal[
    "retrieve_memory_stores",
]


class AgentToolInputCRUDRetrieveMemoryStoresToolTypedDict(TypedDict):
    r"""Lists available memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDRetrieveMemoryStoresTool(BaseModel):
    r"""Lists available memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType = Literal[
    "write_memory_store",
]


class AgentToolInputCRUDWriteMemoryStoreToolTypedDict(TypedDict):
    r"""Writes information to agent memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDWriteMemoryStoreTool(BaseModel):
    r"""Writes information to agent memory stores"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType = Literal[
    "query_memory_store",
]


class AgentToolInputCRUDQueryMemoryStoreToolTypedDict(TypedDict):
    r"""Queries agent memory stores for context"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDQueryMemoryStoreTool(BaseModel):
    r"""Queries agent memory stores for context"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType = Literal["retrieve_agents",]


class AgentToolInputCRUDRetrieveAgentsToolTypedDict(TypedDict):
    r"""Retrieves available agents in the system"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDRetrieveAgentsTool(BaseModel):
    r"""Retrieves available agents in the system"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsRequestType = Literal["call_sub_agent",]


class AgentToolInputCRUDCallSubAgentToolTypedDict(TypedDict):
    r"""Delegates tasks to specialized sub-agents"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDCallSubAgentTool(BaseModel):
    r"""Delegates tasks to specialized sub-agents"""

    type: UpdateAgentAgentToolInputCRUDAgentsRequestType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDAgentsType = Literal["web_scraper",]


class AgentToolInputCRUDWebScraperToolTypedDict(TypedDict):
    r"""Scrapes and extracts content from web pages"""

    type: UpdateAgentAgentToolInputCRUDAgentsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDWebScraperTool(BaseModel):
    r"""Scrapes and extracts content from web pages"""

    type: UpdateAgentAgentToolInputCRUDAgentsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDType = Literal["google_search",]


class AgentToolInputCRUDGoogleSearchToolTypedDict(TypedDict):
    r"""Performs Google searches to retrieve web content"""

    type: UpdateAgentAgentToolInputCRUDType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputCRUDGoogleSearchTool(BaseModel):
    r"""Performs Google searches to retrieve web content"""

    type: UpdateAgentAgentToolInputCRUDType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


UpdateAgentAgentToolInputCRUDTypedDict = TypeAliasType(
    "UpdateAgentAgentToolInputCRUDTypedDict",
    Union[
        AgentToolInputCRUDGoogleSearchToolTypedDict,
        AgentToolInputCRUDWebScraperToolTypedDict,
        AgentToolInputCRUDCallSubAgentToolTypedDict,
        AgentToolInputCRUDRetrieveAgentsToolTypedDict,
        AgentToolInputCRUDQueryMemoryStoreToolTypedDict,
        AgentToolInputCRUDWriteMemoryStoreToolTypedDict,
        AgentToolInputCRUDRetrieveMemoryStoresToolTypedDict,
        AgentToolInputCRUDDeleteMemoryDocumentToolTypedDict,
        AgentToolInputCRUDRetrieveKnowledgeBasesToolTypedDict,
        AgentToolInputCRUDQueryKnowledgeBaseToolTypedDict,
        AgentToolInputCRUDCurrentDateToolTypedDict,
        AgentToolInputCRUDHTTPToolTypedDict,
        AgentToolInputCRUDCodeExecutionToolTypedDict,
        AgentToolInputCRUDFunctionToolTypedDict,
    ],
)
r"""Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools must reference pre-created tools by key or id."""


UpdateAgentAgentToolInputCRUD = TypeAliasType(
    "UpdateAgentAgentToolInputCRUD",
    Union[
        AgentToolInputCRUDGoogleSearchTool,
        AgentToolInputCRUDWebScraperTool,
        AgentToolInputCRUDCallSubAgentTool,
        AgentToolInputCRUDRetrieveAgentsTool,
        AgentToolInputCRUDQueryMemoryStoreTool,
        AgentToolInputCRUDWriteMemoryStoreTool,
        AgentToolInputCRUDRetrieveMemoryStoresTool,
        AgentToolInputCRUDDeleteMemoryDocumentTool,
        AgentToolInputCRUDRetrieveKnowledgeBasesTool,
        AgentToolInputCRUDQueryKnowledgeBaseTool,
        AgentToolInputCRUDCurrentDateTool,
        AgentToolInputCRUDHTTPTool,
        AgentToolInputCRUDCodeExecutionTool,
        AgentToolInputCRUDFunctionTool,
    ],
)
r"""Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools must reference pre-created tools by key or id."""


class UpdateAgentSettingsTypedDict(TypedDict):
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""
    tool_approval_required: NotRequired[UpdateAgentToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""
    tools: NotRequired[List[UpdateAgentAgentToolInputCRUDTypedDict]]
    r"""Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id."""


class UpdateAgentSettings(BaseModel):
    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""

    tool_approval_required: Optional[UpdateAgentToolApprovalRequired] = "respect_tool"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""

    tools: Optional[List[UpdateAgentAgentToolInputCRUD]] = None
    r"""Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id."""


class UpdateAgentKnowledgeBasesTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class UpdateAgentKnowledgeBases(BaseModel):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class UpdateAgentTeamOfAgentsTypedDict(TypedDict):
    key: str
    r"""The unique key of the agent within the workspace"""
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class UpdateAgentTeamOfAgents(BaseModel):
    key: str
    r"""The unique key of the agent within the workspace"""

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class UpdateAgentRequestBodyTypedDict(TypedDict):
    key: NotRequired[str]
    project_id: NotRequired[str]
    role: NotRequired[str]
    description: NotRequired[str]
    instructions: NotRequired[str]
    system_prompt: NotRequired[str]
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""
    model: NotRequired[str]
    r"""The primary language model that powers the agent (e.g., \"anthropic/claude-3-sonnet-20240229\")"""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""
    settings: NotRequired[UpdateAgentSettingsTypedDict]
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    memory_stores: NotRequired[List[str]]
    knowledge_bases: NotRequired[List[UpdateAgentKnowledgeBasesTypedDict]]
    team_of_agents: NotRequired[List[UpdateAgentTeamOfAgentsTypedDict]]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""


class UpdateAgentRequestBody(BaseModel):
    key: Optional[str] = None

    project_id: Optional[str] = None

    role: Optional[str] = None

    description: Optional[str] = None

    instructions: Optional[str] = None

    system_prompt: Optional[str] = None
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""

    model: Optional[str] = None
    r"""The primary language model that powers the agent (e.g., \"anthropic/claude-3-sonnet-20240229\")"""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""

    settings: Optional[UpdateAgentSettings] = None

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    memory_stores: Optional[List[str]] = None

    knowledge_bases: Optional[List[UpdateAgentKnowledgeBases]] = None

    team_of_agents: Optional[List[UpdateAgentTeamOfAgents]] = None
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""


class UpdateAgentRequestTypedDict(TypedDict):
    agent_key: str
    r"""The unique key of the agent to update"""
    request_body: NotRequired[UpdateAgentRequestBodyTypedDict]


class UpdateAgentRequest(BaseModel):
    agent_key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique key of the agent to update"""

    request_body: Annotated[
        Optional[UpdateAgentRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None


class UpdateAgentAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class UpdateAgentAgentsResponseBody(OrqError):
    r"""Agent not found"""

    data: UpdateAgentAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: UpdateAgentAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


UpdateAgentStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateAgentAgentsToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class UpdateAgentConditionsTypedDict(TypedDict):
    condition: str
    r"""The argument of the tool call to evaluate"""
    operator: str
    r"""The operator to use"""
    value: str
    r"""The value to compare against"""


class UpdateAgentConditions(BaseModel):
    condition: str
    r"""The argument of the tool call to evaluate"""

    operator: str
    r"""The operator to use"""

    value: str
    r"""The value to compare against"""


class UpdateAgentToolsTypedDict(TypedDict):
    id: str
    r"""The id of the resource"""
    action_type: str
    key: NotRequired[str]
    r"""Optional tool key for custom tools"""
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]
    conditions: NotRequired[List[UpdateAgentConditionsTypedDict]]
    mcp_server: NotRequired[str]
    r"""The id of the resource"""
    timeout: NotRequired[float]
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class UpdateAgentTools(BaseModel):
    id: str
    r"""The id of the resource"""

    action_type: str

    key: Optional[str] = None
    r"""Optional tool key for custom tools"""

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False

    conditions: Optional[List[UpdateAgentConditions]] = None

    mcp_server: Annotated[Optional[str], pydantic.Field(alias="mcpServer")] = None
    r"""The id of the resource"""

    timeout: Optional[float] = 120
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class UpdateAgentAgentsSettingsTypedDict(TypedDict):
    tools: List[UpdateAgentToolsTypedDict]
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""
    tool_approval_required: NotRequired[UpdateAgentAgentsToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class UpdateAgentAgentsSettings(BaseModel):
    tools: List[UpdateAgentTools]

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""

    tool_approval_required: Optional[UpdateAgentAgentsToolApprovalRequired] = (
        "respect_tool"
    )
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class UpdateAgentModelTypedDict(TypedDict):
    id: str
    r"""The database ID of the primary model"""
    integration_id: NotRequired[Nullable[str]]
    r"""Optional integration ID for custom model configurations"""
    fallback_models: NotRequired[Nullable[List[str]]]
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""
    max_tokens: NotRequired[int]
    r"""Maximum number of tokens for model responses"""
    temperature: NotRequired[float]
    r"""Temperature setting for model responses"""


class UpdateAgentModel(BaseModel):
    id: str
    r"""The database ID of the primary model"""

    integration_id: OptionalNullable[str] = UNSET
    r"""Optional integration ID for custom model configurations"""

    fallback_models: OptionalNullable[List[str]] = UNSET
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""

    max_tokens: Optional[int] = None
    r"""Maximum number of tokens for model responses"""

    temperature: Optional[float] = None
    r"""Temperature setting for model responses"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "integration_id",
            "fallback_models",
            "max_tokens",
            "temperature",
        ]
        nullable_fields = ["integration_id", "fallback_models"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateAgentAgentsTeamOfAgentsTypedDict(TypedDict):
    key: str
    r"""The unique key of the agent within the workspace"""
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class UpdateAgentAgentsTeamOfAgents(BaseModel):
    key: str
    r"""The unique key of the agent within the workspace"""

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class UpdateAgentMetricsTypedDict(TypedDict):
    total_cost: NotRequired[float]


class UpdateAgentMetrics(BaseModel):
    total_cost: Optional[float] = 0


class UpdateAgentAgentsKnowledgeBasesTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class UpdateAgentAgentsKnowledgeBases(BaseModel):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


UpdateAgentHiddenPanels = Literal[
    "model",
    "tools",
    "knowledge_bases",
    "variables",
    "runtime_constraints",
]


class UpdateAgentResponseBodyTypedDict(TypedDict):
    r"""Agent updated successfully"""

    id: str
    key: str
    workspace_id: str
    project_id: str
    role: str
    description: str
    instructions: str
    status: UpdateAgentStatus
    r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    model: UpdateAgentModelTypedDict
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    memory_stores: List[str]
    team_of_agents: List[UpdateAgentAgentsTeamOfAgentsTypedDict]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""
    created_by_id: NotRequired[Nullable[str]]
    updated_by_id: NotRequired[Nullable[str]]
    created: NotRequired[str]
    updated: NotRequired[str]
    system_prompt: NotRequired[str]
    settings: NotRequired[UpdateAgentAgentsSettingsTypedDict]
    version_hash: NotRequired[str]
    metrics: NotRequired[UpdateAgentMetricsTypedDict]
    variables: NotRequired[Dict[str, Any]]
    r"""Extracted variables from agent instructions"""
    knowledge_bases: NotRequired[List[UpdateAgentAgentsKnowledgeBasesTypedDict]]
    r"""Agent knowledge bases reference"""
    hidden_panels: NotRequired[List[UpdateAgentHiddenPanels]]
    r"""List of hidden collapsed panels in configuration. Duplicates are not allowed."""


class UpdateAgentResponseBody(BaseModel):
    r"""Agent updated successfully"""

    id: Annotated[str, pydantic.Field(alias="_id")]

    key: str

    workspace_id: str

    project_id: str

    role: str

    description: str

    instructions: str

    status: UpdateAgentStatus
    r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    model: UpdateAgentModel

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    memory_stores: List[str]

    team_of_agents: List[UpdateAgentAgentsTeamOfAgents]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""

    created_by_id: OptionalNullable[str] = UNSET

    updated_by_id: OptionalNullable[str] = UNSET

    created: Optional[str] = None

    updated: Optional[str] = None

    system_prompt: Optional[str] = None

    settings: Optional[UpdateAgentAgentsSettings] = None

    version_hash: Optional[str] = None

    metrics: Optional[UpdateAgentMetrics] = None

    variables: Optional[Dict[str, Any]] = None
    r"""Extracted variables from agent instructions"""

    knowledge_bases: Optional[List[UpdateAgentAgentsKnowledgeBases]] = None
    r"""Agent knowledge bases reference"""

    hidden_panels: Optional[List[UpdateAgentHiddenPanels]] = None
    r"""List of hidden collapsed panels in configuration. Duplicates are not allowed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "created_by_id",
            "updated_by_id",
            "created",
            "updated",
            "system_prompt",
            "settings",
            "version_hash",
            "metrics",
            "variables",
            "knowledge_bases",
            "hidden_panels",
        ]
        nullable_fields = ["created_by_id", "updated_by_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
