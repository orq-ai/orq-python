"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import get_discriminator
from pydantic import Discriminator, Tag, model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


PostV2RouterOcrDocumentType = Literal["image_url",]


class ImageURL2TypedDict(TypedDict):
    r"""URL of the image to process"""

    url: str
    detail: NotRequired[str]


class ImageURL2(BaseModel):
    r"""URL of the image to process"""

    url: str

    detail: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["detail"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


DocumentImageURLTypedDict = TypeAliasType(
    "DocumentImageURLTypedDict", Union[ImageURL2TypedDict, str]
)


DocumentImageURL = TypeAliasType("DocumentImageURL", Union[ImageURL2, str])


class Document2TypedDict(TypedDict):
    type: PostV2RouterOcrDocumentType
    image_url: DocumentImageURLTypedDict


class Document2(BaseModel):
    type: PostV2RouterOcrDocumentType

    image_url: DocumentImageURL


DocumentType = Literal["document_url",]


class Document1TypedDict(TypedDict):
    type: DocumentType
    document_url: str
    r"""URL of the document to process"""
    document_name: NotRequired[str]
    r"""The name of the document"""


class Document1(BaseModel):
    type: DocumentType

    document_url: str
    r"""URL of the document to process"""

    document_name: Optional[str] = None
    r"""The name of the document"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["document_name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


DocumentTypedDict = TypeAliasType(
    "DocumentTypedDict", Union[Document2TypedDict, Document1TypedDict]
)
r"""Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk."""


Document = Annotated[
    Union[
        Annotated[Document1, Tag("document_url")],
        Annotated[Document2, Tag("image_url")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk."""


class OcrSettingsTypedDict(TypedDict):
    r"""Optional settings for the OCR run"""

    include_image_base64: NotRequired[Nullable[bool]]
    r"""Whether to include image Base64 in the response. Null for default."""
    max_images_to_include: NotRequired[int]
    r"""Maximum number of images to extract. Null for no limit."""
    image_min_size: NotRequired[int]
    r"""Minimum height and width of image to extract. Null for no minimum."""


class OcrSettings(BaseModel):
    r"""Optional settings for the OCR run"""

    include_image_base64: OptionalNullable[bool] = UNSET
    r"""Whether to include image Base64 in the response. Null for default."""

    max_images_to_include: Optional[int] = None
    r"""Maximum number of images to extract. Null for no limit."""

    image_min_size: Optional[int] = None
    r"""Minimum height and width of image to extract. Null for no minimum."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["include_image_base64", "max_images_to_include", "image_min_size"]
        )
        nullable_fields = set(["include_image_base64"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PostV2RouterOcrRequestBodyTypedDict(TypedDict):
    r"""input"""

    model: str
    r"""ID of the model to use for OCR."""
    document: DocumentTypedDict
    r"""Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk."""
    pages: NotRequired[Nullable[List[int]]]
    r"""Specific pages to process. Can be a single number, range, or list. Starts from 0. Null for all pages."""
    ocr_settings: NotRequired[OcrSettingsTypedDict]
    r"""Optional settings for the OCR run"""


class PostV2RouterOcrRequestBody(BaseModel):
    r"""input"""

    model: str
    r"""ID of the model to use for OCR."""

    document: Document
    r"""Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk."""

    pages: OptionalNullable[List[int]] = UNSET
    r"""Specific pages to process. Can be a single number, range, or list. Starts from 0. Null for all pages."""

    ocr_settings: Optional[OcrSettings] = None
    r"""Optional settings for the OCR run"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["pages", "ocr_settings"])
        nullable_fields = set(["pages"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PostV2RouterOcrImagesTypedDict(TypedDict):
    id: str
    r"""The id of the image"""
    image_base64: NotRequired[Nullable[str]]
    r"""The base64 encoded image"""


class PostV2RouterOcrImages(BaseModel):
    id: str
    r"""The id of the image"""

    image_base64: OptionalNullable[str] = UNSET
    r"""The base64 encoded image"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["image_base64"])
        nullable_fields = set(["image_base64"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class DimensionsTypedDict(TypedDict):
    r"""The dimensions of the PDF Page's screenshot image"""

    dpi: int
    r"""Dots per inch of the page-image"""
    height: int
    r"""Height of the image in pixels"""
    width: int
    r"""Width of the image in pixels"""


class Dimensions(BaseModel):
    r"""The dimensions of the PDF Page's screenshot image"""

    dpi: int
    r"""Dots per inch of the page-image"""

    height: int
    r"""Height of the image in pixels"""

    width: int
    r"""Width of the image in pixels"""


class PagesTypedDict(TypedDict):
    index: float
    r"""The page index in a pdf document starting from 0"""
    markdown: str
    r"""The markdown string response of the page"""
    images: List[PostV2RouterOcrImagesTypedDict]
    dimensions: NotRequired[Nullable[DimensionsTypedDict]]
    r"""The dimensions of the PDF Page's screenshot image"""


class Pages(BaseModel):
    index: float
    r"""The page index in a pdf document starting from 0"""

    markdown: str
    r"""The markdown string response of the page"""

    images: List[PostV2RouterOcrImages]

    dimensions: OptionalNullable[Dimensions] = UNSET
    r"""The dimensions of the PDF Page's screenshot image"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dimensions"])
        nullable_fields = set(["dimensions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


PostV2RouterOcrUsageType = Literal["tokens",]


class Usage2TypedDict(TypedDict):
    r"""The usage information for the OCR run counted as tokens processed"""

    type: PostV2RouterOcrUsageType
    tokens_processed: int
    r"""The number of tokens processed"""


class Usage2(BaseModel):
    r"""The usage information for the OCR run counted as tokens processed"""

    type: PostV2RouterOcrUsageType

    tokens_processed: int
    r"""The number of tokens processed"""


UsageType = Literal["pages",]


class Usage1TypedDict(TypedDict):
    r"""The usage information for the OCR run counted as pages processed"""

    type: UsageType
    pages_processed: int
    r"""The number of pages processed"""


class Usage1(BaseModel):
    r"""The usage information for the OCR run counted as pages processed"""

    type: UsageType

    pages_processed: int
    r"""The number of pages processed"""


PostV2RouterOcrUsageTypedDict = TypeAliasType(
    "PostV2RouterOcrUsageTypedDict", Union[Usage1TypedDict, Usage2TypedDict]
)


PostV2RouterOcrUsage = Annotated[
    Union[Annotated[Usage1, Tag("pages")], Annotated[Usage2, Tag("tokens")]],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class PostV2RouterOcrResponseBodyTypedDict(TypedDict):
    r"""Represents an OCR response from the API."""

    model: str
    r"""ID of the model used for OCR."""
    pages: List[PagesTypedDict]
    usage: PostV2RouterOcrUsageTypedDict


class PostV2RouterOcrResponseBody(BaseModel):
    r"""Represents an OCR response from the API."""

    model: str
    r"""ID of the model used for OCR."""

    pages: List[Pages]

    usage: PostV2RouterOcrUsage
