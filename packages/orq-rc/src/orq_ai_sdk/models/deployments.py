"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


InputsTypedDict = TypeAliasType("InputsTypedDict", Union[str, float, bool])


Inputs = TypeAliasType("Inputs", Union[str, float, bool])


DeploymentsPrefixMessages5Role = Literal["tool"]
r"""The role of the messages author, in this case tool."""

DeploymentsPrefixMessagesContentTypedDict = TypeAliasType(
    "DeploymentsPrefixMessagesContentTypedDict", Union[str, List[str]]
)
r"""The contents of the tool message."""


DeploymentsPrefixMessagesContent = TypeAliasType(
    "DeploymentsPrefixMessagesContent", Union[str, List[str]]
)
r"""The contents of the tool message."""


class ToolMessageTypedDict(TypedDict):
    role: DeploymentsPrefixMessages5Role
    r"""The role of the messages author, in this case tool."""
    content: DeploymentsPrefixMessagesContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: str
    r"""Tool call that this message is responding to."""


class ToolMessage(BaseModel):
    role: DeploymentsPrefixMessages5Role
    r"""The role of the messages author, in this case tool."""

    content: DeploymentsPrefixMessagesContent
    r"""The contents of the tool message."""

    tool_call_id: str
    r"""Tool call that this message is responding to."""


Deployments2PrefixMessages4ContentType = Literal["refusal"]
r"""The type of the content part."""


class RefusalContentPartTypedDict(TypedDict):
    type: Deployments2PrefixMessages4ContentType
    r"""The type of the content part."""
    refusal: str
    r"""The refusal message generated by the model."""


class RefusalContentPart(BaseModel):
    type: Deployments2PrefixMessages4ContentType
    r"""The type of the content part."""

    refusal: str
    r"""The refusal message generated by the model."""


Deployments2PrefixMessages4Type = Literal["text"]
r"""The type of the content part."""


class TextContentPartTypedDict(TypedDict):
    type: Deployments2PrefixMessages4Type
    r"""The type of the content part."""
    text: str
    r"""The text content."""


class TextContentPart(BaseModel):
    type: Deployments2PrefixMessages4Type
    r"""The type of the content part."""

    text: str
    r"""The text content."""


Content2TypedDict = TypeAliasType(
    "Content2TypedDict", Union[TextContentPartTypedDict, RefusalContentPartTypedDict]
)


Content2 = TypeAliasType("Content2", Union[TextContentPart, RefusalContentPart])


PrefixMessagesContentTypedDict = TypeAliasType(
    "PrefixMessagesContentTypedDict", Union[str, List[Content2TypedDict]]
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


PrefixMessagesContent = TypeAliasType(
    "PrefixMessagesContent", Union[str, List[Content2]]
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


DeploymentsPrefixMessages4Role = Literal["assistant"]
r"""The role of the messages author, in this case `assistant`."""


class AudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class Audio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


Type = Literal["function"]
r"""The type of the tool. Currently, only `function` is supported."""


class FunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class Function(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class ToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: Type
    r"""The type of the tool. Currently, only `function` is supported."""
    function: FunctionTypedDict


class ToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: Type
    r"""The type of the tool. Currently, only `function` is supported."""

    function: Function


class AssistantMessageTypedDict(TypedDict):
    role: DeploymentsPrefixMessages4Role
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[Nullable[PrefixMessagesContentTypedDict]]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[AudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[ToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""
    reasoning: NotRequired[str]
    r"""Internal thought process of the model"""
    reasoning_signature: NotRequired[str]
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""
    redacted_reasoning: NotRequired[str]
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""


class AssistantMessage(BaseModel):
    role: DeploymentsPrefixMessages4Role
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[PrefixMessagesContent] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[Audio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[ToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    reasoning: Optional[str] = None
    r"""Internal thought process of the model"""

    reasoning_signature: Optional[str] = None
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""

    redacted_reasoning: Optional[str] = None
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "content",
            "refusal",
            "name",
            "audio",
            "tool_calls",
            "reasoning",
            "reasoning_signature",
            "redacted_reasoning",
        ]
        nullable_fields = ["content", "refusal", "audio"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


DeploymentsPrefixMessagesRole = Literal["user"]
r"""The role of the messages author, in this case `user`."""

Deployments2PrefixMessagesType = Literal["file"]
r"""The type of the content part. Always `file`."""


class FileTypedDict(TypedDict):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""
    filename: NotRequired[str]
    r"""The name of the file, used when passing the file to the model as a string."""


class File(BaseModel):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""

    filename: Optional[str] = None
    r"""The name of the file, used when passing the file to the model as a string."""


class FourTypedDict(TypedDict):
    type: Deployments2PrefixMessagesType
    r"""The type of the content part. Always `file`."""
    file: FileTypedDict


class Four(BaseModel):
    type: Deployments2PrefixMessagesType
    r"""The type of the content part. Always `file`."""

    file: File


Deployments2Type = Literal["input_audio"]

Format = Literal["mp3", "wav"]
r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class InputAudioTypedDict(TypedDict):
    data: str
    r"""Base64 encoded audio data."""
    format_: Format
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class InputAudio(BaseModel):
    data: str
    r"""Base64 encoded audio data."""

    format_: Annotated[Format, pydantic.Field(alias="format")]
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class Deployments23TypedDict(TypedDict):
    type: Deployments2Type
    input_audio: InputAudioTypedDict


class Deployments23(BaseModel):
    type: Deployments2Type

    input_audio: InputAudio


TwoType = Literal["image_url"]

Detail = Literal["low", "high", "auto"]
r"""Specifies the detail level of the image."""


class ImageURLTypedDict(TypedDict):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""
    detail: NotRequired[Detail]
    r"""Specifies the detail level of the image."""


class ImageURL(BaseModel):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""

    detail: Optional[Detail] = None
    r"""Specifies the detail level of the image."""


class Two2TypedDict(TypedDict):
    type: TwoType
    image_url: ImageURLTypedDict


class Two2(BaseModel):
    type: TwoType

    image_url: ImageURL


Deployments2PrefixMessages3Type = Literal["text"]


class Deployments21TypedDict(TypedDict):
    type: Deployments2PrefixMessages3Type
    text: str


class Deployments21(BaseModel):
    type: Deployments2PrefixMessages3Type

    text: str


TwoTypedDict = TypeAliasType(
    "TwoTypedDict",
    Union[Deployments21TypedDict, Two2TypedDict, Deployments23TypedDict, FourTypedDict],
)


Two = TypeAliasType("Two", Union[Deployments21, Two2, Deployments23, Four])


ContentTypedDict = TypeAliasType("ContentTypedDict", Union[str, List[TwoTypedDict]])
r"""The contents of the user message."""


Content = TypeAliasType("Content", Union[str, List[Two]])
r"""The contents of the user message."""


class UserMessageTypedDict(TypedDict):
    role: DeploymentsPrefixMessagesRole
    r"""The role of the messages author, in this case `user`."""
    content: ContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UserMessage(BaseModel):
    role: DeploymentsPrefixMessagesRole
    r"""The role of the messages author, in this case `user`."""

    content: Content
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


PrefixMessagesRole = Literal["system"]
r"""The role of the messages author, in this case `system`."""


class SystemMessageTypedDict(TypedDict):
    role: PrefixMessagesRole
    r"""The role of the messages author, in this case `system`."""
    content: str
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class SystemMessage(BaseModel):
    role: PrefixMessagesRole
    r"""The role of the messages author, in this case `system`."""

    content: str
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


Role = Literal["developer"]
r"""The role of the messages author, in this case  `developer`."""


class DeveloperMessageTypedDict(TypedDict):
    role: Role
    r"""The role of the messages author, in this case  `developer`."""
    content: str
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class DeveloperMessage(BaseModel):
    role: Role
    r"""The role of the messages author, in this case  `developer`."""

    content: str
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


PrefixMessagesTypedDict = TypeAliasType(
    "PrefixMessagesTypedDict",
    Union[
        DeveloperMessageTypedDict,
        SystemMessageTypedDict,
        UserMessageTypedDict,
        ToolMessageTypedDict,
        AssistantMessageTypedDict,
    ],
)


PrefixMessages = TypeAliasType(
    "PrefixMessages",
    Union[DeveloperMessage, SystemMessage, UserMessage, ToolMessage, AssistantMessage],
)


DeploymentsMessages5Role = Literal["tool"]
r"""The role of the messages author, in this case tool."""

DeploymentsMessages5ContentTypedDict = TypeAliasType(
    "DeploymentsMessages5ContentTypedDict", Union[str, List[str]]
)
r"""The contents of the tool message."""


DeploymentsMessages5Content = TypeAliasType(
    "DeploymentsMessages5Content", Union[str, List[str]]
)
r"""The contents of the tool message."""


class MessagesToolMessageTypedDict(TypedDict):
    role: DeploymentsMessages5Role
    r"""The role of the messages author, in this case tool."""
    content: DeploymentsMessages5ContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: str
    r"""Tool call that this message is responding to."""


class MessagesToolMessage(BaseModel):
    role: DeploymentsMessages5Role
    r"""The role of the messages author, in this case tool."""

    content: DeploymentsMessages5Content
    r"""The contents of the tool message."""

    tool_call_id: str
    r"""Tool call that this message is responding to."""


Deployments2Messages4ContentType = Literal["refusal"]
r"""The type of the content part."""


class TwoRefusalContentPartTypedDict(TypedDict):
    type: Deployments2Messages4ContentType
    r"""The type of the content part."""
    refusal: str
    r"""The refusal message generated by the model."""


class TwoRefusalContentPart(BaseModel):
    type: Deployments2Messages4ContentType
    r"""The type of the content part."""

    refusal: str
    r"""The refusal message generated by the model."""


Deployments2Messages4Type = Literal["text"]
r"""The type of the content part."""


class TwoTextContentPartTypedDict(TypedDict):
    type: Deployments2Messages4Type
    r"""The type of the content part."""
    text: str
    r"""The text content."""


class TwoTextContentPart(BaseModel):
    type: Deployments2Messages4Type
    r"""The type of the content part."""

    text: str
    r"""The text content."""


DeploymentsContentMessages2TypedDict = TypeAliasType(
    "DeploymentsContentMessages2TypedDict",
    Union[TwoTextContentPartTypedDict, TwoRefusalContentPartTypedDict],
)


DeploymentsContentMessages2 = TypeAliasType(
    "DeploymentsContentMessages2", Union[TwoTextContentPart, TwoRefusalContentPart]
)


DeploymentsMessagesContentTypedDict = TypeAliasType(
    "DeploymentsMessagesContentTypedDict",
    Union[str, List[DeploymentsContentMessages2TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


DeploymentsMessagesContent = TypeAliasType(
    "DeploymentsMessagesContent", Union[str, List[DeploymentsContentMessages2]]
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


DeploymentsMessages4Role = Literal["assistant"]
r"""The role of the messages author, in this case `assistant`."""


class MessagesAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class MessagesAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


MessagesType = Literal["function"]
r"""The type of the tool. Currently, only `function` is supported."""


class MessagesFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class MessagesFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class MessagesToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: MessagesType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: MessagesFunctionTypedDict


class MessagesToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: MessagesType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: MessagesFunction


class MessagesAssistantMessageTypedDict(TypedDict):
    role: DeploymentsMessages4Role
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[Nullable[DeploymentsMessagesContentTypedDict]]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[MessagesAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[MessagesToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""
    reasoning: NotRequired[str]
    r"""Internal thought process of the model"""
    reasoning_signature: NotRequired[str]
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""
    redacted_reasoning: NotRequired[str]
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""


class MessagesAssistantMessage(BaseModel):
    role: DeploymentsMessages4Role
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[DeploymentsMessagesContent] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[MessagesAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[MessagesToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    reasoning: Optional[str] = None
    r"""Internal thought process of the model"""

    reasoning_signature: Optional[str] = None
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""

    redacted_reasoning: Optional[str] = None
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "content",
            "refusal",
            "name",
            "audio",
            "tool_calls",
            "reasoning",
            "reasoning_signature",
            "redacted_reasoning",
        ]
        nullable_fields = ["content", "refusal", "audio"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


DeploymentsMessages3Role = Literal["user"]
r"""The role of the messages author, in this case `user`."""

Deployments2Messages3Content4Type = Literal["file"]
r"""The type of the content part. Always `file`."""


class TwoFileTypedDict(TypedDict):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""
    filename: NotRequired[str]
    r"""The name of the file, used when passing the file to the model as a string."""


class TwoFile(BaseModel):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""

    filename: Optional[str] = None
    r"""The name of the file, used when passing the file to the model as a string."""


class Two4TypedDict(TypedDict):
    type: Deployments2Messages3Content4Type
    r"""The type of the content part. Always `file`."""
    file: TwoFileTypedDict


class Two4(BaseModel):
    type: Deployments2Messages3Content4Type
    r"""The type of the content part. Always `file`."""

    file: TwoFile


Deployments2Messages3ContentType = Literal["input_audio"]

TwoFormat = Literal["mp3", "wav"]
r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class TwoInputAudioTypedDict(TypedDict):
    data: str
    r"""Base64 encoded audio data."""
    format_: TwoFormat
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class TwoInputAudio(BaseModel):
    data: str
    r"""Base64 encoded audio data."""

    format_: Annotated[TwoFormat, pydantic.Field(alias="format")]
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class Two3TypedDict(TypedDict):
    type: Deployments2Messages3ContentType
    input_audio: TwoInputAudioTypedDict


class Two3(BaseModel):
    type: Deployments2Messages3ContentType

    input_audio: TwoInputAudio


Deployments2Messages3Type = Literal["image_url"]

TwoDetail = Literal["low", "high", "auto"]
r"""Specifies the detail level of the image."""


class TwoImageURLTypedDict(TypedDict):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""
    detail: NotRequired[TwoDetail]
    r"""Specifies the detail level of the image."""


class TwoImageURL(BaseModel):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""

    detail: Optional[TwoDetail] = None
    r"""Specifies the detail level of the image."""


class Deployments22TypedDict(TypedDict):
    type: Deployments2Messages3Type
    image_url: TwoImageURLTypedDict


class Deployments22(BaseModel):
    type: Deployments2Messages3Type

    image_url: TwoImageURL


Deployments2MessagesType = Literal["text"]


class Two1TypedDict(TypedDict):
    type: Deployments2MessagesType
    text: str


class Two1(BaseModel):
    type: Deployments2MessagesType

    text: str


DeploymentsContent2TypedDict = TypeAliasType(
    "DeploymentsContent2TypedDict",
    Union[Two1TypedDict, Deployments22TypedDict, Two3TypedDict, Two4TypedDict],
)


DeploymentsContent2 = TypeAliasType(
    "DeploymentsContent2", Union[Two1, Deployments22, Two3, Two4]
)


MessagesContentTypedDict = TypeAliasType(
    "MessagesContentTypedDict", Union[str, List[DeploymentsContent2TypedDict]]
)
r"""The contents of the user message."""


MessagesContent = TypeAliasType(
    "MessagesContent", Union[str, List[DeploymentsContent2]]
)
r"""The contents of the user message."""


class MessagesUserMessageTypedDict(TypedDict):
    role: DeploymentsMessages3Role
    r"""The role of the messages author, in this case `user`."""
    content: MessagesContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class MessagesUserMessage(BaseModel):
    role: DeploymentsMessages3Role
    r"""The role of the messages author, in this case `user`."""

    content: MessagesContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


DeploymentsMessagesRole = Literal["system"]
r"""The role of the messages author, in this case `system`."""


class MessagesSystemMessageTypedDict(TypedDict):
    role: DeploymentsMessagesRole
    r"""The role of the messages author, in this case `system`."""
    content: str
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class MessagesSystemMessage(BaseModel):
    role: DeploymentsMessagesRole
    r"""The role of the messages author, in this case `system`."""

    content: str
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


MessagesRole = Literal["developer"]
r"""The role of the messages author, in this case  `developer`."""


class MessagesDeveloperMessageTypedDict(TypedDict):
    role: MessagesRole
    r"""The role of the messages author, in this case  `developer`."""
    content: str
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class MessagesDeveloperMessage(BaseModel):
    role: MessagesRole
    r"""The role of the messages author, in this case  `developer`."""

    content: str
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


MessagesTypedDict = TypeAliasType(
    "MessagesTypedDict",
    Union[
        MessagesDeveloperMessageTypedDict,
        MessagesSystemMessageTypedDict,
        MessagesUserMessageTypedDict,
        MessagesToolMessageTypedDict,
        MessagesAssistantMessageTypedDict,
    ],
)


Messages = TypeAliasType(
    "Messages",
    Union[
        MessagesDeveloperMessage,
        MessagesSystemMessage,
        MessagesUserMessage,
        MessagesToolMessage,
        MessagesAssistantMessage,
    ],
)


class MetadataTypedDict(TypedDict):
    r"""Metadata about the document"""

    file_name: NotRequired[str]
    r"""Name of the file the text is from."""
    file_type: NotRequired[str]
    r"""Content type of the file the text is from."""
    page_number: NotRequired[float]
    r"""The page number the text is from."""


class Metadata(BaseModel):
    r"""Metadata about the document"""

    file_name: Optional[str] = None
    r"""Name of the file the text is from."""

    file_type: Optional[str] = None
    r"""Content type of the file the text is from."""

    page_number: Optional[float] = None
    r"""The page number the text is from."""


class DocumentsTypedDict(TypedDict):
    text: str
    r"""The text content of the document"""
    metadata: NotRequired[MetadataTypedDict]
    r"""Metadata about the document"""


class Documents(BaseModel):
    text: str
    r"""The text content of the document"""

    metadata: Optional[Metadata] = None
    r"""Metadata about the document"""


class InvokeOptionsTypedDict(TypedDict):
    include_retrievals: NotRequired[bool]
    r"""Whether to include the retrieved knowledge chunks in the response."""
    mock_response: NotRequired[str]
    r"""A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage."""


class InvokeOptions(BaseModel):
    include_retrievals: Optional[bool] = False
    r"""Whether to include the retrieved knowledge chunks in the response."""

    mock_response: Optional[str] = None
    r"""A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage."""


class ThreadTypedDict(TypedDict):
    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class Thread(BaseModel):
    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class DollarOrDollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class DollarOrDollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


DollarOrDollarNinTypedDict = TypeAliasType(
    "DollarOrDollarNinTypedDict", Union[str, float, bool]
)


DollarOrDollarNin = TypeAliasType("DollarOrDollarNin", Union[str, float, bool])


class DeploymentsDollarOrDollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[DollarOrDollarNinTypedDict]


class DeploymentsDollarOrDollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[List[DollarOrDollarNin], pydantic.Field(alias="$nin")]


DollarOrDollarInTypedDict = TypeAliasType(
    "DollarOrDollarInTypedDict", Union[str, float, bool]
)


DollarOrDollarIn = TypeAliasType("DollarOrDollarIn", Union[str, float, bool])


class DeploymentsDollarOrDollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[DollarOrDollarInTypedDict]


class DeploymentsDollarOrDollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[List[DollarOrDollarIn], pydantic.Field(alias="$in")]


class DollarOrDollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class DollarOrDollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class DollarOrDollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class DollarOrDollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class DollarOrDollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class DollarOrDollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class DollarOr3TypedDict(TypedDict):
    dollar_gt: float


class DollarOr3(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


DollarOrDollarNeTypedDict = TypeAliasType(
    "DollarOrDollarNeTypedDict", Union[str, float, bool]
)


DollarOrDollarNe = TypeAliasType("DollarOrDollarNe", Union[str, float, bool])


class DeploymentsDollarOrDollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: DollarOrDollarNeTypedDict


class DeploymentsDollarOrDollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[DollarOrDollarNe, pydantic.Field(alias="$ne")]


DollarOrDollarEqTypedDict = TypeAliasType(
    "DollarOrDollarEqTypedDict", Union[str, float, bool]
)


DollarOrDollarEq = TypeAliasType("DollarOrDollarEq", Union[str, float, bool])


class DeploymentsDollarOrDollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: DollarOrDollarEqTypedDict


class DeploymentsDollarOrDollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[DollarOrDollarEq, pydantic.Field(alias="$eq")]


DollarOrTypedDict = TypeAliasType(
    "DollarOrTypedDict",
    Union[
        DeploymentsDollarOrDollarEqTypedDict,
        DeploymentsDollarOrDollarNeTypedDict,
        DollarOr3TypedDict,
        DollarOrDollarGteTypedDict,
        DollarOrDollarLtTypedDict,
        DollarOrDollarLteTypedDict,
        DeploymentsDollarOrDollarInTypedDict,
        DeploymentsDollarOrDollarNinTypedDict,
        DollarOrDollarExistsTypedDict,
    ],
)


DollarOr = TypeAliasType(
    "DollarOr",
    Union[
        DeploymentsDollarOrDollarEq,
        DeploymentsDollarOrDollarNe,
        DollarOr3,
        DollarOrDollarGte,
        DollarOrDollarLt,
        DollarOrDollarLte,
        DeploymentsDollarOrDollarIn,
        DeploymentsDollarOrDollarNin,
        DollarOrDollarExists,
    ],
)


class KnowledgeFilterDollarOrTypedDict(TypedDict):
    r"""Or"""

    dollar_or: List[Dict[str, DollarOrTypedDict]]


class KnowledgeFilterDollarOr(BaseModel):
    r"""Or"""

    dollar_or: Annotated[List[Dict[str, DollarOr]], pydantic.Field(alias="$or")]


class DollarAndDollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class DollarAndDollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


DollarAndDollarNinTypedDict = TypeAliasType(
    "DollarAndDollarNinTypedDict", Union[str, float, bool]
)


DollarAndDollarNin = TypeAliasType("DollarAndDollarNin", Union[str, float, bool])


class DeploymentsDollarAndDollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[DollarAndDollarNinTypedDict]


class DeploymentsDollarAndDollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[List[DollarAndDollarNin], pydantic.Field(alias="$nin")]


DollarAndDollarInTypedDict = TypeAliasType(
    "DollarAndDollarInTypedDict", Union[str, float, bool]
)


DollarAndDollarIn = TypeAliasType("DollarAndDollarIn", Union[str, float, bool])


class DeploymentsDollarAndDollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[DollarAndDollarInTypedDict]


class DeploymentsDollarAndDollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[List[DollarAndDollarIn], pydantic.Field(alias="$in")]


class DollarAndDollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class DollarAndDollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class DollarAndDollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class DollarAndDollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class DollarAndDollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class DollarAndDollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class DollarAnd3TypedDict(TypedDict):
    dollar_gt: float


class DollarAnd3(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


DollarAndDollarNeTypedDict = TypeAliasType(
    "DollarAndDollarNeTypedDict", Union[str, float, bool]
)


DollarAndDollarNe = TypeAliasType("DollarAndDollarNe", Union[str, float, bool])


class DeploymentsDollarAndDollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: DollarAndDollarNeTypedDict


class DeploymentsDollarAndDollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[DollarAndDollarNe, pydantic.Field(alias="$ne")]


DollarAndDollarEqTypedDict = TypeAliasType(
    "DollarAndDollarEqTypedDict", Union[str, float, bool]
)


DollarAndDollarEq = TypeAliasType("DollarAndDollarEq", Union[str, float, bool])


class DeploymentsDollarAndDollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: DollarAndDollarEqTypedDict


class DeploymentsDollarAndDollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[DollarAndDollarEq, pydantic.Field(alias="$eq")]


DollarAndTypedDict = TypeAliasType(
    "DollarAndTypedDict",
    Union[
        DeploymentsDollarAndDollarEqTypedDict,
        DeploymentsDollarAndDollarNeTypedDict,
        DollarAnd3TypedDict,
        DollarAndDollarGteTypedDict,
        DollarAndDollarLtTypedDict,
        DollarAndDollarLteTypedDict,
        DeploymentsDollarAndDollarInTypedDict,
        DeploymentsDollarAndDollarNinTypedDict,
        DollarAndDollarExistsTypedDict,
    ],
)


DollarAnd = TypeAliasType(
    "DollarAnd",
    Union[
        DeploymentsDollarAndDollarEq,
        DeploymentsDollarAndDollarNe,
        DollarAnd3,
        DollarAndDollarGte,
        DollarAndDollarLt,
        DollarAndDollarLte,
        DeploymentsDollarAndDollarIn,
        DeploymentsDollarAndDollarNin,
        DollarAndDollarExists,
    ],
)


class KnowledgeFilterDollarAndTypedDict(TypedDict):
    r"""And"""

    dollar_and: List[Dict[str, DollarAndTypedDict]]


class KnowledgeFilterDollarAnd(BaseModel):
    r"""And"""

    dollar_and: Annotated[List[Dict[str, DollarAnd]], pydantic.Field(alias="$and")]


class DollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class DollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


DollarNinTypedDict = TypeAliasType("DollarNinTypedDict", Union[str, float, bool])


DollarNin = TypeAliasType("DollarNin", Union[str, float, bool])


class OneDollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[DollarNinTypedDict]


class OneDollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[List[DollarNin], pydantic.Field(alias="$nin")]


DollarInTypedDict = TypeAliasType("DollarInTypedDict", Union[str, float, bool])


DollarIn = TypeAliasType("DollarIn", Union[str, float, bool])


class OneDollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[DollarInTypedDict]


class OneDollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[List[DollarIn], pydantic.Field(alias="$in")]


class DollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class DollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class DollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class DollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class DollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class DollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class ThreeTypedDict(TypedDict):
    dollar_gt: float


class Three(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


DollarNeTypedDict = TypeAliasType("DollarNeTypedDict", Union[str, float, bool])


DollarNe = TypeAliasType("DollarNe", Union[str, float, bool])


class OneDollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: DollarNeTypedDict


class OneDollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[DollarNe, pydantic.Field(alias="$ne")]


DollarEqTypedDict = TypeAliasType("DollarEqTypedDict", Union[str, float, bool])


DollarEq = TypeAliasType("DollarEq", Union[str, float, bool])


class OneDollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: DollarEqTypedDict


class OneDollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[DollarEq, pydantic.Field(alias="$eq")]


OneTypedDict = TypeAliasType(
    "OneTypedDict",
    Union[
        OneDollarEqTypedDict,
        OneDollarNeTypedDict,
        ThreeTypedDict,
        DollarGteTypedDict,
        DollarLtTypedDict,
        DollarLteTypedDict,
        OneDollarInTypedDict,
        OneDollarNinTypedDict,
        DollarExistsTypedDict,
    ],
)


One = TypeAliasType(
    "One",
    Union[
        OneDollarEq,
        OneDollarNe,
        Three,
        DollarGte,
        DollarLt,
        DollarLte,
        OneDollarIn,
        OneDollarNin,
        DollarExists,
    ],
)


KnowledgeFilterTypedDict = TypeAliasType(
    "KnowledgeFilterTypedDict",
    Union[
        KnowledgeFilterDollarAndTypedDict,
        KnowledgeFilterDollarOrTypedDict,
        Dict[str, OneTypedDict],
    ],
)
r"""A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment."""


KnowledgeFilter = TypeAliasType(
    "KnowledgeFilter",
    Union[KnowledgeFilterDollarAnd, KnowledgeFilterDollarOr, Dict[str, One]],
)
r"""A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment."""


class DeploymentsTypedDict(TypedDict):
    r"""The deployment request payload"""

    key: str
    r"""The deployment key to invoke"""
    inputs: NotRequired[Dict[str, InputsTypedDict]]
    r"""Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used."""
    context: NotRequired[Dict[str, Any]]
    r"""Key-value pairs that match your data model and fields declared in your deployment routing configuration"""
    prefix_messages: NotRequired[List[PrefixMessagesTypedDict]]
    r"""A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment."""
    messages: NotRequired[List[MessagesTypedDict]]
    r"""A list of messages to send to the deployment."""
    file_ids: NotRequired[List[str]]
    r"""A list of file IDs that are associated with the deployment request."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Key-value pairs that you want to attach to the log generated by this request."""
    extra_params: NotRequired[Dict[str, Any]]
    r"""Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration."""
    documents: NotRequired[List[DocumentsTypedDict]]
    r"""A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings."""
    invoke_options: NotRequired[InvokeOptionsTypedDict]
    thread: NotRequired[ThreadTypedDict]
    knowledge_filter: NotRequired[KnowledgeFilterTypedDict]
    r"""A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment."""


class Deployments(BaseModel):
    r"""The deployment request payload"""

    key: str
    r"""The deployment key to invoke"""

    inputs: Optional[Dict[str, Inputs]] = None
    r"""Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used."""

    context: Optional[Dict[str, Any]] = None
    r"""Key-value pairs that match your data model and fields declared in your deployment routing configuration"""

    prefix_messages: Optional[List[PrefixMessages]] = None
    r"""A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment."""

    messages: Optional[List[Messages]] = None
    r"""A list of messages to send to the deployment."""

    file_ids: Optional[List[str]] = None
    r"""A list of file IDs that are associated with the deployment request."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Key-value pairs that you want to attach to the log generated by this request."""

    extra_params: Optional[Dict[str, Any]] = None
    r"""Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration."""

    documents: Optional[List[Documents]] = None
    r"""A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings."""

    invoke_options: Optional[InvokeOptions] = None

    thread: Optional[Thread] = None

    knowledge_filter: Optional[KnowledgeFilter] = None
    r"""A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment."""
