"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class PaginationTypedDict(TypedDict):
    page: NotRequired[float]
    limit: NotRequired[float]
    last_id: NotRequired[Nullable[str]]
    first_id: NotRequired[Nullable[str]]


class Pagination(BaseModel):
    page: Optional[float] = None

    limit: Optional[float] = 50

    last_id: Annotated[OptionalNullable[str], pydantic.Field(alias="lastId")] = UNSET

    first_id: Annotated[OptionalNullable[str], pydantic.Field(alias="firstId")] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["page", "limit", "lastId", "firstId"]
        nullable_fields = ["lastId", "firstId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


Direction = Literal["asc", "desc"]
r"""The direction to sort by"""


class SortingPropsTypedDict(TypedDict):
    key: str
    r"""The path to sort by"""
    direction: NotRequired[Direction]
    r"""The direction to sort by"""


class SortingProps(BaseModel):
    key: str
    r"""The path to sort by"""

    direction: Optional[Direction] = None
    r"""The direction to sort by"""


Operator = Literal["and", "or"]

ListSessionsFiltersSessionsRequestRequestBodyQuery8Operator = Literal["is"]

ListSessionsFiltersSessionsRequestRequestBodyQuery8Type = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters85 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters84 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters83 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters82 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters81 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperatorsTypedDict = (
    TypeAliasType(
        "ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperatorsTypedDict",
        Union[
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters81,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters82,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters83,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters84,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters85,
        ],
    )
)


ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters81,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters82,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters83,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters84,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters85,
    ],
)


class Filters8TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQuery8Operator
    type: ListSessionsFiltersSessionsRequestRequestBodyQuery8Type
    name: str
    path: str
    value: NotRequired[bool]
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperatorsTypedDict]
    ]


class Filters8(BaseModel):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQuery8Operator

    type: ListSessionsFiltersSessionsRequestRequestBodyQuery8Type

    name: str

    path: str

    value: Optional[bool] = False

    hide_operators: Annotated[
        Optional[
            List[ListSessionsFiltersSessionsRequestRequestBodyQuery8HideOperators]
        ],
        pydantic.Field(alias="hideOperators"),
    ] = None


ListSessionsOperator2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsOperator1 = Literal["is"]

ListSessionsFiltersSessionsRequestRequestBodyQuery7OperatorTypedDict = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQuery7OperatorTypedDict",
    Union[ListSessionsOperator1, ListSessionsOperator2],
)


ListSessionsFiltersSessionsRequestRequestBodyQuery7Operator = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQuery7Operator",
    Union[ListSessionsOperator1, ListSessionsOperator2],
)


ListSessionsFiltersSessionsRequestRequestBodyQuery7Type = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsFiltersSessionsRequestRequestBodyQuery7OptionsType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters75 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters74 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters73 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters72 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters71 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperatorsTypedDict = (
    TypeAliasType(
        "ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperatorsTypedDict",
        Union[
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters71,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters72,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters73,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters74,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters75,
        ],
    )
)


ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters71,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters72,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters73,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters74,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters75,
    ],
)


EvaluatorType = Literal[
    "function_eval",
    "http_eval",
    "json_schema",
    "llm_eval",
    "python_eval",
    "ragas",
    "typescript_eval",
]

EvaluatorOutputType = Literal["boolean", "number", "string", "enum"]


class ListSessionsFiltersSessionsOptionsTypedDict(TypedDict):
    name: str
    path: str
    type: ListSessionsFiltersSessionsRequestRequestBodyQuery7OptionsType
    id: str
    evaluator_id: str
    evaluator_type: EvaluatorType
    evaluator_output_type: EvaluatorOutputType
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperatorsTypedDict]
    ]


class ListSessionsFiltersSessionsOptions(BaseModel):
    name: str

    path: str

    type: ListSessionsFiltersSessionsRequestRequestBodyQuery7OptionsType

    id: str

    evaluator_id: Annotated[str, pydantic.Field(alias="evaluatorId")]

    evaluator_type: Annotated[EvaluatorType, pydantic.Field(alias="evaluatorType")]

    evaluator_output_type: Annotated[
        EvaluatorOutputType, pydantic.Field(alias="evaluatorOutputType")
    ]

    hide_operators: Annotated[
        Optional[
            List[ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators]
        ],
        pydantic.Field(alias="hideOperators"),
    ] = None


ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters76 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters77 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters78 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters79 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters710 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1TypedDict = (
    TypeAliasType(
        "ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1TypedDict",
        Union[
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters710,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters79,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters78,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters77,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters76,
        ],
    )
)


ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1 = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters710,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters79,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters78,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters77,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters76,
    ],
)


class Filters7TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQuery7OperatorTypedDict
    type: ListSessionsFiltersSessionsRequestRequestBodyQuery7Type
    selected_option_id: Nullable[str]
    options: List[ListSessionsFiltersSessionsOptionsTypedDict]
    name: str
    path: str
    value: NotRequired[Nullable[Any]]
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1TypedDict]
    ]


class Filters7(BaseModel):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQuery7Operator

    type: ListSessionsFiltersSessionsRequestRequestBodyQuery7Type

    selected_option_id: Annotated[
        Nullable[str], pydantic.Field(alias="selectedOptionId")
    ]

    options: List[ListSessionsFiltersSessionsOptions]

    name: str

    path: str

    value: OptionalNullable[Any] = UNSET

    hide_operators: Annotated[
        Optional[
            List[ListSessionsFiltersSessionsRequestRequestBodyQuery7HideOperators1]
        ],
        pydantic.Field(alias="hideOperators"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["value", "hideOperators"]
        nullable_fields = ["value", "selectedOptionId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


Operator5 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

Operator4 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

Operator3 = Literal["contains", "does_not_contain", "is_empty", "is_not_empty"]

Operator2 = Literal["is", "is_not", "is_empty", "is_not_empty"]

Operator1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyQueryOperatorTypedDict = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQueryOperatorTypedDict",
    Union[Operator1, Operator2, Operator3, Operator4, Operator5],
)


ListSessionsFiltersSessionsRequestRequestBodyQueryOperator = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQueryOperator",
    Union[Operator1, Operator2, Operator3, Operator4, Operator5],
)


ListSessionsFiltersSessionsRequestRequestBodyQueryType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsFiltersSessionsRequestRequestBodyQuery6Type = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQuery5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQuery4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQuery3 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQuery2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQuery1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyHideOperatorsTypedDict = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyHideOperatorsTypedDict",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery1,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery2,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery3,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery4,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery5,
    ],
)


ListSessionsFiltersSessionsRequestRequestBodyHideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyHideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery1,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery2,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery3,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery4,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQuery5,
    ],
)


class ListSessionsFiltersOptionsTypedDict(TypedDict):
    name: str
    path: str
    type: ListSessionsFiltersSessionsRequestRequestBodyQuery6Type
    id: str
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestRequestBodyHideOperatorsTypedDict]
    ]


class ListSessionsFiltersOptions(BaseModel):
    name: str

    path: str

    type: ListSessionsFiltersSessionsRequestRequestBodyQuery6Type

    id: str

    hide_operators: Annotated[
        Optional[List[ListSessionsFiltersSessionsRequestRequestBodyHideOperators]],
        pydantic.Field(alias="hideOperators"),
    ] = None


ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters3 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperatorsTypedDict = (
    TypeAliasType(
        "ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperatorsTypedDict",
        Union[
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters1,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters2,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters3,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters4,
            ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters5,
        ],
    )
)


ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters1,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters2,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters3,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters4,
        ListSessionsHideOperatorsSessionsRequestRequestBodyQueryFilters5,
    ],
)


class Filters6TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQueryOperatorTypedDict
    type: ListSessionsFiltersSessionsRequestRequestBodyQueryType
    options: List[ListSessionsFiltersOptionsTypedDict]
    selected_option_id: Nullable[str]
    name: str
    path: str
    value: NotRequired[Nullable[Any]]
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperatorsTypedDict]
    ]


class Filters6(BaseModel):
    operator: ListSessionsFiltersSessionsRequestRequestBodyQueryOperator

    type: ListSessionsFiltersSessionsRequestRequestBodyQueryType

    options: List[ListSessionsFiltersOptions]

    selected_option_id: Annotated[
        Nullable[str], pydantic.Field(alias="selectedOptionId")
    ]

    name: str

    path: str

    value: OptionalNullable[Any] = UNSET

    hide_operators: Annotated[
        Optional[List[ListSessionsFiltersSessionsRequestRequestBodyQueryHideOperators]],
        pydantic.Field(alias="hideOperators"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["value", "hideOperators"]
        nullable_fields = ["value", "selectedOptionId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListSessionsFiltersSessionsRequestRequestBodyOperator = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestRequestBodyType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessionsRequestRequestBody5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBody4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBody3 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequestRequestBody2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequestRequestBody1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsRequestHideOperatorsTypedDict = TypeAliasType(
    "ListSessionsFiltersSessionsRequestHideOperatorsTypedDict",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBody1,
        ListSessionsHideOperatorsSessionsRequestRequestBody2,
        ListSessionsHideOperatorsSessionsRequestRequestBody3,
        ListSessionsHideOperatorsSessionsRequestRequestBody4,
        ListSessionsHideOperatorsSessionsRequestRequestBody5,
    ],
)


ListSessionsFiltersSessionsRequestHideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsRequestHideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequestRequestBody1,
        ListSessionsHideOperatorsSessionsRequestRequestBody2,
        ListSessionsHideOperatorsSessionsRequestRequestBody3,
        ListSessionsHideOperatorsSessionsRequestRequestBody4,
        ListSessionsHideOperatorsSessionsRequestRequestBody5,
    ],
)


class Filters5TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsRequestRequestBodyOperator
    value: Nullable[str]
    type: ListSessionsFiltersSessionsRequestRequestBodyType
    name: str
    path: str
    hide_operators: NotRequired[
        List[ListSessionsFiltersSessionsRequestHideOperatorsTypedDict]
    ]


class Filters5(BaseModel):
    operator: ListSessionsFiltersSessionsRequestRequestBodyOperator

    value: Nullable[str]

    type: ListSessionsFiltersSessionsRequestRequestBodyType

    name: str

    path: str

    hide_operators: Annotated[
        Optional[List[ListSessionsFiltersSessionsRequestHideOperators]],
        pydantic.Field(alias="hideOperators"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["hideOperators"]
        nullable_fields = ["value"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListSessionsFiltersSessionsRequestOperator = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersValueTypedDict = TypeAliasType(
    "ListSessionsFiltersValueTypedDict", Union[float, List[float]]
)


ListSessionsFiltersValue = TypeAliasType(
    "ListSessionsFiltersValue", Union[float, List[float]]
)


ListSessionsFiltersSessionsRequestType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessionsRequest5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequest4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequest3 = Literal[
    "is", "is_not", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessionsRequest2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessionsRequest1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersSessionsHideOperatorsTypedDict = TypeAliasType(
    "ListSessionsFiltersSessionsHideOperatorsTypedDict",
    Union[
        ListSessionsHideOperatorsSessionsRequest1,
        ListSessionsHideOperatorsSessionsRequest2,
        ListSessionsHideOperatorsSessionsRequest3,
        ListSessionsHideOperatorsSessionsRequest4,
        ListSessionsHideOperatorsSessionsRequest5,
    ],
)


ListSessionsFiltersSessionsHideOperators = TypeAliasType(
    "ListSessionsFiltersSessionsHideOperators",
    Union[
        ListSessionsHideOperatorsSessionsRequest1,
        ListSessionsHideOperatorsSessionsRequest2,
        ListSessionsHideOperatorsSessionsRequest3,
        ListSessionsHideOperatorsSessionsRequest4,
        ListSessionsHideOperatorsSessionsRequest5,
    ],
)


class Filters4TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsRequestOperator
    value: Nullable[ListSessionsFiltersValueTypedDict]
    type: ListSessionsFiltersSessionsRequestType
    name: str
    path: str
    hide_operators: NotRequired[List[ListSessionsFiltersSessionsHideOperatorsTypedDict]]


class Filters4(BaseModel):
    operator: ListSessionsFiltersSessionsRequestOperator

    value: Nullable[ListSessionsFiltersValue]

    type: ListSessionsFiltersSessionsRequestType

    name: str

    path: str

    hide_operators: Annotated[
        Optional[List[ListSessionsFiltersSessionsHideOperators]],
        pydantic.Field(alias="hideOperators"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["hideOperators"]
        nullable_fields = ["value"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListSessionsFiltersSessionsOperator = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

Unit2 = Literal["hours_ago", "minutes_ago"]

Unit1 = Literal["day", "week", "month", "year"]

UnitTypedDict = TypeAliasType("UnitTypedDict", Union[Unit1, Unit2])


Unit = TypeAliasType("Unit", Union[Unit1, Unit2])


RelativeTime = Literal[
    "today", "yesterday", "one_week_ago", "one_month_ago", "custom_date"
]

FiltersDirection = Literal["present", "past"]


class CriteriaTypedDict(TypedDict):
    unit: NotRequired[UnitTypedDict]
    count: NotRequired[Nullable[float]]
    relative_time: NotRequired[RelativeTime]
    custom_date: NotRequired[Nullable[str]]
    direction: NotRequired[FiltersDirection]
    start_date: NotRequired[Nullable[str]]
    end_date: NotRequired[Nullable[str]]


class Criteria(BaseModel):
    unit: Optional[Unit] = None

    count: OptionalNullable[float] = UNSET

    relative_time: Annotated[
        Optional[RelativeTime], pydantic.Field(alias="relativeTime")
    ] = None

    custom_date: Annotated[
        OptionalNullable[str], pydantic.Field(alias="customDate")
    ] = UNSET

    direction: Optional[FiltersDirection] = None

    start_date: Annotated[OptionalNullable[str], pydantic.Field(alias="startDate")] = (
        UNSET
    )

    end_date: Annotated[OptionalNullable[str], pydantic.Field(alias="endDate")] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "unit",
            "count",
            "relativeTime",
            "customDate",
            "direction",
            "startDate",
            "endDate",
        ]
        nullable_fields = ["count", "customDate", "startDate", "endDate"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


Mode = Literal["date", "datetime"]


class FiltersValueTypedDict(TypedDict):
    criteria: Nullable[CriteriaTypedDict]
    mode: Mode


class FiltersValue(BaseModel):
    criteria: Nullable[Criteria]

    mode: Mode

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["criteria"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListSessionsFiltersSessionsType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

ListSessionsHideOperatorsSessions5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessions4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperatorsSessions3 = Literal["is", "is_not", "is_empty", "is_not_empty"]

ListSessionsHideOperatorsSessions2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperatorsSessions1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

ListSessionsFiltersHideOperatorsTypedDict = TypeAliasType(
    "ListSessionsFiltersHideOperatorsTypedDict",
    Union[
        ListSessionsHideOperatorsSessions1,
        ListSessionsHideOperatorsSessions2,
        ListSessionsHideOperatorsSessions3,
        ListSessionsHideOperatorsSessions4,
        ListSessionsHideOperatorsSessions5,
    ],
)


ListSessionsFiltersHideOperators = TypeAliasType(
    "ListSessionsFiltersHideOperators",
    Union[
        ListSessionsHideOperatorsSessions1,
        ListSessionsHideOperatorsSessions2,
        ListSessionsHideOperatorsSessions3,
        ListSessionsHideOperatorsSessions4,
        ListSessionsHideOperatorsSessions5,
    ],
)


class Filters3TypedDict(TypedDict):
    operator: ListSessionsFiltersSessionsOperator
    value: FiltersValueTypedDict
    type: ListSessionsFiltersSessionsType
    name: str
    path: str
    hide_operators: NotRequired[List[ListSessionsFiltersHideOperatorsTypedDict]]


class Filters3(BaseModel):
    operator: ListSessionsFiltersSessionsOperator

    value: FiltersValue

    type: ListSessionsFiltersSessionsType

    name: str

    path: str

    hide_operators: Annotated[
        Optional[List[ListSessionsFiltersHideOperators]],
        pydantic.Field(alias="hideOperators"),
    ] = None


ListSessionsFiltersOperator = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsFiltersType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

FiltersOptionsTypedDict = TypeAliasType("FiltersOptionsTypedDict", Union[str, float])


FiltersOptions = TypeAliasType("FiltersOptions", Union[str, float])


FiltersOptionsMapTypedDict = TypeAliasType(
    "FiltersOptionsMapTypedDict", Union[str, float]
)


FiltersOptionsMap = TypeAliasType("FiltersOptionsMap", Union[str, float])


ListSessionsHideOperators5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperators4 = Literal[
    "contains", "does_not_contain", "is_empty", "is_not_empty"
]

ListSessionsHideOperators3 = Literal["is", "is_not", "is_empty", "is_not_empty"]

ListSessionsHideOperators2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

ListSessionsHideOperators1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

FiltersHideOperatorsTypedDict = TypeAliasType(
    "FiltersHideOperatorsTypedDict",
    Union[
        ListSessionsHideOperators1,
        ListSessionsHideOperators2,
        ListSessionsHideOperators3,
        ListSessionsHideOperators4,
        ListSessionsHideOperators5,
    ],
)


FiltersHideOperators = TypeAliasType(
    "FiltersHideOperators",
    Union[
        ListSessionsHideOperators1,
        ListSessionsHideOperators2,
        ListSessionsHideOperators3,
        ListSessionsHideOperators4,
        ListSessionsHideOperators5,
    ],
)


class Filters2TypedDict(TypedDict):
    operator: ListSessionsFiltersOperator
    value: Nullable[List[Any]]
    type: ListSessionsFiltersType
    options: List[FiltersOptionsTypedDict]
    name: str
    path: str
    options_map: NotRequired[Nullable[Dict[str, FiltersOptionsMapTypedDict]]]
    image_url_map: NotRequired[Dict[str, str]]
    hide_operators: NotRequired[List[FiltersHideOperatorsTypedDict]]


class Filters2(BaseModel):
    operator: ListSessionsFiltersOperator

    value: Nullable[List[Any]]

    type: ListSessionsFiltersType

    options: List[FiltersOptions]

    name: str

    path: str

    options_map: Annotated[
        OptionalNullable[Dict[str, FiltersOptionsMap]],
        pydantic.Field(alias="optionsMap"),
    ] = UNSET

    image_url_map: Annotated[
        Optional[Dict[str, str]], pydantic.Field(alias="imageUrlMap")
    ] = None

    hide_operators: Annotated[
        Optional[List[FiltersHideOperators]], pydantic.Field(alias="hideOperators")
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["optionsMap", "imageUrlMap", "hideOperators"]
        nullable_fields = ["value", "optionsMap"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


FiltersOperator = Literal["is", "is_not", "is_empty", "is_not_empty"]

FiltersType = Literal[
    "string",
    "multi-value-array",
    "single-value-array",
    "number",
    "date",
    "object",
    "boolean",
    "evaluator",
]

OptionsTypedDict = TypeAliasType("OptionsTypedDict", Union[str, float])


Options = TypeAliasType("Options", Union[str, float])


OptionsMapTypedDict = TypeAliasType("OptionsMapTypedDict", Union[str, float])


OptionsMap = TypeAliasType("OptionsMap", Union[str, float])


HideOperators5 = Literal[
    "is",
    "is_before",
    "is_on_or_before",
    "is_between",
    "is_relative_today",
    "is_relative_time",
    "is_empty",
    "is_not_empty",
]

HideOperators4 = Literal["contains", "does_not_contain", "is_empty", "is_not_empty"]

HideOperators3 = Literal["is", "is_not", "is_empty", "is_not_empty"]

HideOperators2 = Literal[
    "equals",
    "is_not_equal",
    "is_greater_than",
    "is_less_than",
    "is_greater_than_or_equal_to",
    "is_less_than_or_equal_to",
    "is_between",
    "is_empty",
    "is_not_empty",
]

HideOperators1 = Literal[
    "is",
    "is_not",
    "contains",
    "does_not_contain",
    "starts_with",
    "ends_with",
    "is_empty",
    "is_not_empty",
]

HideOperatorsTypedDict = TypeAliasType(
    "HideOperatorsTypedDict",
    Union[
        HideOperators1, HideOperators2, HideOperators3, HideOperators4, HideOperators5
    ],
)


HideOperators = TypeAliasType(
    "HideOperators",
    Union[
        HideOperators1, HideOperators2, HideOperators3, HideOperators4, HideOperators5
    ],
)


class Filters1TypedDict(TypedDict):
    operator: FiltersOperator
    type: FiltersType
    options: List[OptionsTypedDict]
    name: str
    path: str
    value: NotRequired[Any]
    options_map: NotRequired[Nullable[Dict[str, OptionsMapTypedDict]]]
    image_url_map: NotRequired[Dict[str, str]]
    hide_operators: NotRequired[List[HideOperatorsTypedDict]]


class Filters1(BaseModel):
    operator: FiltersOperator

    type: FiltersType

    options: List[Options]

    name: str

    path: str

    value: Optional[Any] = None

    options_map: Annotated[
        OptionalNullable[Dict[str, OptionsMap]], pydantic.Field(alias="optionsMap")
    ] = UNSET

    image_url_map: Annotated[
        Optional[Dict[str, str]], pydantic.Field(alias="imageUrlMap")
    ] = None

    hide_operators: Annotated[
        Optional[List[HideOperators]], pydantic.Field(alias="hideOperators")
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["value", "optionsMap", "imageUrlMap", "hideOperators"]
        nullable_fields = ["optionsMap"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


FiltersTypedDict = TypeAliasType(
    "FiltersTypedDict",
    Union[
        Filters3TypedDict,
        Filters4TypedDict,
        Filters5TypedDict,
        Filters8TypedDict,
        Filters6TypedDict,
        Filters7TypedDict,
        Filters1TypedDict,
        Filters2TypedDict,
    ],
)


Filters = TypeAliasType(
    "Filters",
    Union[
        Filters3, Filters4, Filters5, Filters8, Filters6, Filters7, Filters1, Filters2
    ],
)


class QueryTypedDict(TypedDict):
    operator: Operator
    search: NotRequired[str]
    filters: NotRequired[List[FiltersTypedDict]]


class Query(BaseModel):
    operator: Operator

    search: Optional[str] = None

    filters: Optional[List[Filters]] = None


ListSessionsFiltersSessionsRequestRequestBody4Type = Literal["string_array"]

ListSessionsFiltersSessionsRequestRequestBody4Operator = Literal["in"]


class ListSessionsFilters4TypedDict(TypedDict):
    type: ListSessionsFiltersSessionsRequestRequestBody4Type
    operator: ListSessionsFiltersSessionsRequestRequestBody4Operator
    values: List[str]
    path: str


class ListSessionsFilters4(BaseModel):
    type: ListSessionsFiltersSessionsRequestRequestBody4Type

    operator: ListSessionsFiltersSessionsRequestRequestBody4Operator

    values: List[str]

    path: str


ListSessionsFiltersSessionsRequestRequestBody3Type = Literal["string"]

ListSessionsFiltersSessionsRequestRequestBody3Operator = Literal["contains", "equals"]


class ListSessionsFilters3TypedDict(TypedDict):
    type: ListSessionsFiltersSessionsRequestRequestBody3Type
    operator: ListSessionsFiltersSessionsRequestRequestBody3Operator
    value: str
    path: str


class ListSessionsFilters3(BaseModel):
    type: ListSessionsFiltersSessionsRequestRequestBody3Type

    operator: ListSessionsFiltersSessionsRequestRequestBody3Operator

    value: str

    path: str


ListSessionsFiltersSessionsRequestRequestBody2Type = Literal["search"]


class ListSessionsFilters2TypedDict(TypedDict):
    type: ListSessionsFiltersSessionsRequestRequestBody2Type
    value: str
    search_paths: List[str]


class ListSessionsFilters2(BaseModel):
    type: ListSessionsFiltersSessionsRequestRequestBody2Type

    value: str

    search_paths: Annotated[List[str], pydantic.Field(alias="searchPaths")]


ListSessionsFiltersSessionsRequestRequestBody1Type = Literal["id"]


class ListSessionsFilters1TypedDict(TypedDict):
    type: ListSessionsFiltersSessionsRequestRequestBody1Type
    id: str
    path: str


class ListSessionsFilters1(BaseModel):
    type: ListSessionsFiltersSessionsRequestRequestBody1Type

    id: str

    path: str


ListSessionsFiltersTypedDict = TypeAliasType(
    "ListSessionsFiltersTypedDict",
    Union[
        ListSessionsFilters1TypedDict,
        ListSessionsFilters2TypedDict,
        ListSessionsFilters3TypedDict,
        ListSessionsFilters4TypedDict,
    ],
)


ListSessionsFilters = TypeAliasType(
    "ListSessionsFilters",
    Union[
        ListSessionsFilters1,
        ListSessionsFilters2,
        ListSessionsFilters3,
        ListSessionsFilters4,
    ],
)


class ListSessionsRequestBodyTypedDict(TypedDict):
    filters: List[ListSessionsFiltersTypedDict]
    pagination: NotRequired[PaginationTypedDict]
    sorting_props: NotRequired[List[SortingPropsTypedDict]]
    query: NotRequired[QueryTypedDict]
    included_fields: NotRequired[Dict[str, str]]


class ListSessionsRequestBody(BaseModel):
    filters: List[ListSessionsFilters]

    pagination: Optional[Pagination] = None

    sorting_props: Annotated[
        Optional[List[SortingProps]], pydantic.Field(alias="sortingProps")
    ] = None

    query: Optional[Query] = None

    included_fields: Annotated[
        Optional[Dict[str, str]], pydantic.Field(alias="includedFields")
    ] = None


ListSessionsObject = Literal["list"]


class ListSessionsBillingTypedDict(TypedDict):
    input_cost: float
    r"""Total cost of the session"""
    output_cost: float
    r"""Total cost of the session"""
    total_cost: float
    r"""Total usage of the session"""


class ListSessionsBilling(BaseModel):
    input_cost: float
    r"""Total cost of the session"""

    output_cost: float
    r"""Total cost of the session"""

    total_cost: float
    r"""Total usage of the session"""


class ListSessionsUsageTypedDict(TypedDict):
    prompt_tokens: float
    r"""Total input tokens of the session"""
    completion_tokens: float
    r"""Total output tokens of the session"""
    total_tokens: float
    r"""Total tokens of the session"""


class ListSessionsUsage(BaseModel):
    prompt_tokens: float
    r"""Total input tokens of the session"""

    completion_tokens: float
    r"""Total output tokens of the session"""

    total_tokens: float
    r"""Total tokens of the session"""


class ListSessionsDataTypedDict(TypedDict):
    id: str
    external_id: str
    duration: float
    r"""Duration of the session in ms"""
    contact_ids: List[str]
    r"""List of contact ids"""
    billing: ListSessionsBillingTypedDict
    usage: ListSessionsUsageTypedDict
    traces_count: float
    r"""Total traces of the session"""
    tags: List[str]
    workspace_id: str
    r"""The workspace id"""
    project_id: NotRequired[Nullable[str]]
    r"""The project id"""
    started_at: NotRequired[datetime]
    r"""The time when the session was created"""
    updated_at: NotRequired[datetime]
    r"""The time when the session was updated"""


class ListSessionsData(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    external_id: str

    duration: float
    r"""Duration of the session in ms"""

    contact_ids: List[str]
    r"""List of contact ids"""

    billing: ListSessionsBilling

    usage: ListSessionsUsage

    traces_count: float
    r"""Total traces of the session"""

    tags: List[str]

    workspace_id: str
    r"""The workspace id"""

    project_id: OptionalNullable[str] = UNSET
    r"""The project id"""

    started_at: Optional[datetime] = None
    r"""The time when the session was created"""

    updated_at: Optional[datetime] = None
    r"""The time when the session was updated"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["project_id", "started_at", "updated_at"]
        nullable_fields = ["project_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ListSessionsResponseBodyTypedDict(TypedDict):
    r"""Sessions retrieved successfully."""

    object: ListSessionsObject
    data: List[ListSessionsDataTypedDict]
    has_more: bool


class ListSessionsResponseBody(BaseModel):
    r"""Sessions retrieved successfully."""

    object: ListSessionsObject

    data: List[ListSessionsData]

    has_more: bool
