"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import get_discriminator
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CreateEvalGuardrailConfigEvalsRequestRequestBody4Type = Literal["number",]


CreateEvalGuardrailConfigOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigNumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBody4Type
    value: float
    operator: CreateEvalGuardrailConfigOperator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBody4Type

    value: float

    operator: CreateEvalGuardrailConfigOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestRequestBodyType = Literal["boolean",]


class CreateEvalGuardrailConfigBooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBodyType
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBodyType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalRequestBodyGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalRequestBodyGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigBooleanTypedDict,
        CreateEvalGuardrailConfigNumberTypedDict,
    ],
)


CreateEvalRequestBodyGuardrailConfig = Annotated[
    Union[
        Annotated[CreateEvalGuardrailConfigBoolean, Tag("boolean")],
        Annotated[CreateEvalGuardrailConfigNumber, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalRequestBodyOutputType = Literal[
    "boolean",
    "number",
]


CreateEvalRequestBodyType = Literal["python_eval",]


class PythonTypedDict(TypedDict):
    code: str
    type: CreateEvalRequestBodyType
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    guardrail_config: NotRequired[CreateEvalRequestBodyGuardrailConfigTypedDict]
    output_type: NotRequired[CreateEvalRequestBodyOutputType]
    description: NotRequired[str]


class Python(BaseModel):
    code: str

    type: CreateEvalRequestBodyType

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str

    guardrail_config: Optional[CreateEvalRequestBodyGuardrailConfig] = None

    output_type: Optional[CreateEvalRequestBodyOutputType] = None

    description: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["guardrail_config", "output_type", "description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestType = Literal["number",]


GuardrailConfigOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class GuardrailConfigNumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestType
    value: float
    operator: GuardrailConfigOperator
    alert_on_failure: NotRequired[bool]


class GuardrailConfigNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestType

    value: float

    operator: GuardrailConfigOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsType = Literal["boolean",]


class GuardrailConfigBooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsType
    value: bool
    alert_on_failure: NotRequired[bool]


class GuardrailConfigBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RequestBodyGuardrailConfigTypedDict = TypeAliasType(
    "RequestBodyGuardrailConfigTypedDict",
    Union[GuardrailConfigBooleanTypedDict, GuardrailConfigNumberTypedDict],
)


RequestBodyGuardrailConfig = Annotated[
    Union[
        Annotated[GuardrailConfigBoolean, Tag("boolean")],
        Annotated[GuardrailConfigNumber, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


RequestBodyOutputType = Literal[
    "boolean",
    "categorical",
    "number",
    "string",
]
r"""The type of output expected from the evaluator"""


RequestBodyType = Literal["http_eval",]


CreateEvalRequestBodyMethod = Literal[
    "GET",
    "POST",
]


class CreateEvalRequestBodyHTTPTypedDict(TypedDict):
    type: RequestBodyType
    url: str
    method: CreateEvalRequestBodyMethod
    headers: Dict[str, str]
    payload: Dict[str, Any]
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    guardrail_config: NotRequired[RequestBodyGuardrailConfigTypedDict]
    output_type: NotRequired[RequestBodyOutputType]
    r"""The type of output expected from the evaluator"""
    description: NotRequired[str]


class CreateEvalRequestBodyHTTP(BaseModel):
    type: RequestBodyType

    url: str

    method: CreateEvalRequestBodyMethod

    headers: Dict[str, str]

    payload: Dict[str, Any]

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str

    guardrail_config: Optional[RequestBodyGuardrailConfig] = None

    output_type: Optional[RequestBodyOutputType] = None
    r"""The type of output expected from the evaluator"""

    description: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["guardrail_config", "output_type", "description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigType = Literal["number",]


Operator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class NumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigType
    value: float
    operator: Operator
    alert_on_failure: NotRequired[bool]


class Number(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigType

    value: float

    operator: Operator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


GuardrailConfigType = Literal["boolean",]


class BooleanTypedDict(TypedDict):
    enabled: bool
    type: GuardrailConfigType
    value: bool
    alert_on_failure: NotRequired[bool]


class Boolean(BaseModel):
    enabled: bool

    type: GuardrailConfigType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


GuardrailConfigTypedDict = TypeAliasType(
    "GuardrailConfigTypedDict", Union[BooleanTypedDict, NumberTypedDict]
)


GuardrailConfig = Annotated[
    Union[Annotated[Boolean, Tag("boolean")], Annotated[Number, Tag("number")]],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


OutputType = Literal["boolean",]


CreateEvalRequestBodyEvalsType = Literal["json_schema",]


class JSONTypedDict(TypedDict):
    type: CreateEvalRequestBodyEvalsType
    schema_: str
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    guardrail_config: NotRequired[GuardrailConfigTypedDict]
    output_type: NotRequired[OutputType]
    description: NotRequired[str]


class JSON(BaseModel):
    type: CreateEvalRequestBodyEvalsType

    schema_: Annotated[str, pydantic.Field(alias="schema")]

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str

    guardrail_config: Optional[GuardrailConfig] = None

    output_type: Optional[OutputType] = None

    description: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["guardrail_config", "output_type", "description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM2Type = Literal["number",]


CreateEvalGuardrailConfigEvalsOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsNumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM2Type
    value: float
    operator: CreateEvalGuardrailConfigEvalsOperator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM2Type

    value: float

    operator: CreateEvalGuardrailConfigEvalsOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestRequestBody1LLMType = Literal["boolean",]


class CreateEvalGuardrailConfigEvalsBooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLMType
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLMType

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


LLMGuardrailConfigTypedDict = TypeAliasType(
    "LLMGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsNumberTypedDict,
    ],
)


LLMGuardrailConfig = Annotated[
    Union[
        Annotated[CreateEvalGuardrailConfigEvalsBoolean, Tag("boolean")],
        Annotated[CreateEvalGuardrailConfigEvalsNumber, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


LLMOutputType = Literal[
    "boolean",
    "categorical",
    "number",
    "string",
]
r"""The type of output expected from the evaluator"""


LLMType = Literal["llm_eval",]


LLMMode = Literal["jury",]


class CreateEvalLLMRetryTypedDict(TypedDict):
    count: NotRequired[int]
    on_codes: NotRequired[List[int]]


class CreateEvalLLMRetry(BaseModel):
    count: Optional[int] = 2

    on_codes: Optional[List[int]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateEvalLLMFallbacksTypedDict(TypedDict):
    model: str


class CreateEvalLLMFallbacks(BaseModel):
    model: str


class LLMJudgesTypedDict(TypedDict):
    model: str
    retry: NotRequired[CreateEvalLLMRetryTypedDict]
    fallbacks: NotRequired[List[CreateEvalLLMFallbacksTypedDict]]


class LLMJudges(BaseModel):
    model: str

    retry: Optional[CreateEvalLLMRetry] = None

    fallbacks: Optional[List[CreateEvalLLMFallbacks]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry", "fallbacks"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class LLMRetryTypedDict(TypedDict):
    count: NotRequired[int]
    on_codes: NotRequired[List[int]]


class LLMRetry(BaseModel):
    count: Optional[int] = 2

    on_codes: Optional[List[int]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class LLMFallbacksTypedDict(TypedDict):
    model: str


class LLMFallbacks(BaseModel):
    model: str


class LLMReplacementJudgesTypedDict(TypedDict):
    model: str
    retry: NotRequired[LLMRetryTypedDict]
    fallbacks: NotRequired[List[LLMFallbacksTypedDict]]


class LLMReplacementJudges(BaseModel):
    model: str

    retry: Optional[LLMRetry] = None

    fallbacks: Optional[List[LLMFallbacks]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["retry", "fallbacks"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


LLMTieValue = Literal["Tie",]


class LLMJuryTypedDict(TypedDict):
    judges: List[LLMJudgesTypedDict]
    replacement_judges: NotRequired[List[LLMReplacementJudgesTypedDict]]
    min_successful_judges: NotRequired[int]
    tie_value: NotRequired[LLMTieValue]


class LLMJury(BaseModel):
    judges: List[LLMJudges]

    replacement_judges: Optional[List[LLMReplacementJudges]] = None

    min_successful_judges: Optional[int] = 2

    tie_value: Optional[LLMTieValue] = "Tie"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["replacement_judges", "min_successful_judges", "tie_value"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class Llm2TypedDict(TypedDict):
    type: LLMType
    prompt: str
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    mode: LLMMode
    jury: LLMJuryTypedDict
    guardrail_config: NotRequired[LLMGuardrailConfigTypedDict]
    output_type: NotRequired[LLMOutputType]
    r"""The type of output expected from the evaluator"""
    repetitions: NotRequired[int]
    description: NotRequired[str]


class Llm2(BaseModel):
    type: LLMType

    prompt: str

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str

    mode: LLMMode

    jury: LLMJury

    guardrail_config: Optional[LLMGuardrailConfig] = None

    output_type: Optional[LLMOutputType] = None
    r"""The type of output expected from the evaluator"""

    repetitions: Optional[int] = None

    description: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["guardrail_config", "output_type", "repetitions", "description"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestRequestBody1Type = Literal["number",]


CreateEvalGuardrailConfigEvalsRequestOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsRequestNumberTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1Type
    value: float
    operator: CreateEvalGuardrailConfigEvalsRequestOperator
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsRequestNumber(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1Type

    value: float

    operator: CreateEvalGuardrailConfigEvalsRequestOperator

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM1Type = Literal["boolean",]


class CreateEvalGuardrailConfigEvalsRequestBooleanTypedDict(TypedDict):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM1Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsRequestBoolean(BaseModel):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsRequestRequestBody1LLM1Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalLLMGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalLLMGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsRequestBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsRequestNumberTypedDict,
    ],
)


CreateEvalLLMGuardrailConfig = Annotated[
    Union[
        Annotated[CreateEvalGuardrailConfigEvalsRequestBoolean, Tag("boolean")],
        Annotated[CreateEvalGuardrailConfigEvalsRequestNumber, Tag("number")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalLLMOutputType = Literal[
    "boolean",
    "categorical",
    "number",
    "string",
]
r"""The type of output expected from the evaluator"""


CreateEvalLLMType = Literal["llm_eval",]


CreateEvalLLMMode = Literal["single",]


class Llm1TypedDict(TypedDict):
    type: CreateEvalLLMType
    prompt: str
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    mode: CreateEvalLLMMode
    model: str
    guardrail_config: NotRequired[CreateEvalLLMGuardrailConfigTypedDict]
    output_type: NotRequired[CreateEvalLLMOutputType]
    r"""The type of output expected from the evaluator"""
    repetitions: NotRequired[int]
    description: NotRequired[str]


class Llm1(BaseModel):
    type: CreateEvalLLMType

    prompt: str

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str

    mode: CreateEvalLLMMode

    model: str

    guardrail_config: Optional[CreateEvalLLMGuardrailConfig] = None

    output_type: Optional[CreateEvalLLMOutputType] = None
    r"""The type of output expected from the evaluator"""

    repetitions: Optional[int] = None

    description: Optional[str] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["guardrail_config", "output_type", "repetitions", "description"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


LlmTypedDict = TypeAliasType("LlmTypedDict", Union[Llm1TypedDict, Llm2TypedDict])


Llm = Annotated[
    Union[Annotated[Llm1, Tag("single")], Annotated[Llm2, Tag("jury")]],
    Discriminator(lambda m: get_discriminator(m, "mode", "mode")),
]


CreateEvalRequestBodyTypedDict = TypeAliasType(
    "CreateEvalRequestBodyTypedDict",
    Union[
        JSONTypedDict, PythonTypedDict, CreateEvalRequestBodyHTTPTypedDict, LlmTypedDict
    ],
)


CreateEvalRequestBody = TypeAliasType(
    "CreateEvalRequestBody", Union[JSON, Python, CreateEvalRequestBodyHTTP, Llm]
)


class CreateEvalEvalsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class CreateEvalEvalsResponseBody(OrqError):
    r"""Workspace ID is not found on the request"""

    data: CreateEvalEvalsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: CreateEvalEvalsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody72Type = Literal[
    "number",
]


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Operator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7NumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody72Type
    value: float
    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Operator
    )
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Number(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody72Type

    value: float

    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Operator
    )

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7BooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Boolean(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalResponseBodyEvalsResponse200ApplicationJSONGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalResponseBodyEvalsResponse200ApplicationJSONGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7BooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7NumberTypedDict,
    ],
)


CreateEvalResponseBodyEvalsResponse200ApplicationJSONGuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Boolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody7Number,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalResponseBodyEvalsResponse200ApplicationJSONType = Literal["typescript_eval",]


class TypescriptTypedDict(TypedDict):
    id: str
    description: str
    code: str
    type: CreateEvalResponseBodyEvalsResponse200ApplicationJSONType
    key: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[
        CreateEvalResponseBodyEvalsResponse200ApplicationJSONGuardrailConfigTypedDict
    ]


class Typescript(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    code: str

    type: CreateEvalResponseBodyEvalsResponse200ApplicationJSONType

    key: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[
        CreateEvalResponseBodyEvalsResponse200ApplicationJSONGuardrailConfig
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody62Type = Literal[
    "number",
]


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Operator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6NumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody62Type
    value: float
    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Operator
    )
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Number(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody62Type

    value: float

    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Operator
    )

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6BooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Boolean(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalResponseBodyEvalsResponse200GuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalResponseBodyEvalsResponse200GuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6BooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6NumberTypedDict,
    ],
)


CreateEvalResponseBodyEvalsResponse200GuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Boolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody6Number,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalResponseBodyEvalsResponse200Type = Literal["ragas",]


RagasMetric = Literal[
    "context_precision",
    "context_recall",
    "context_entities_recall",
    "harmfulness",
    "maliciousness",
    "coherence",
    "correctness",
    "conciseness",
    "response_relevancy",
    "faithfulness",
    "summarization",
    "noise_sensitivity",
]


class RagasTypedDict(TypedDict):
    id: str
    description: str
    type: CreateEvalResponseBodyEvalsResponse200Type
    ragas_metric: RagasMetric
    key: str
    model: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[
        CreateEvalResponseBodyEvalsResponse200GuardrailConfigTypedDict
    ]


class Ragas(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: CreateEvalResponseBodyEvalsResponse200Type

    ragas_metric: RagasMetric

    key: str

    model: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[
        CreateEvalResponseBodyEvalsResponse200GuardrailConfig
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody52Type = Literal[
    "number",
]


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyOperator = Literal[
    "eq",
    "ne",
    "gt",
    "gte",
    "lt",
    "lte",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyNumberTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody52Type
    value: float
    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyOperator
    )
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyNumber(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody52Type

    value: float

    operator: (
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyOperator
    )

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody5Type = Literal[
    "boolean",
]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyBooleanTypedDict(
    TypedDict
):
    enabled: bool
    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody5Type
    value: bool
    alert_on_failure: NotRequired[bool]


class CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyBoolean(
    BaseModel
):
    enabled: bool

    type: CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody5Type

    value: bool

    alert_on_failure: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["alert_on_failure"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalResponseBodyEvalsResponseGuardrailConfigTypedDict = TypeAliasType(
    "CreateEvalResponseBodyEvalsResponseGuardrailConfigTypedDict",
    Union[
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyBooleanTypedDict,
        CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyNumberTypedDict,
    ],
)


CreateEvalResponseBodyEvalsResponseGuardrailConfig = Annotated[
    Union[
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyBoolean,
            Tag("boolean"),
        ],
        Annotated[
            CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBodyNumber,
            Tag("number"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


CreateEvalResponseBodyEvalsResponseType = Literal["function_eval",]


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody532Type = Literal[
    "grammar_diversity",
]


class ThirtyTwoTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody532Type


class ThirtyTwo(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody532Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody531Type = Literal[
    "lexical_repetition",
]


class ThirtyOneTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody531Type


class ThirtyOne(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody531Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody530Type = Literal[
    "sentences_count",
]


class ThirtyTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody530Type


class Thirty(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody530Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody529Type = Literal[
    "words_count",
]


class TwentyNineTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody529Type


class TwentyNine(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody529Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody528Type = Literal[
    "gse_english_level",
]


class TwentyEightTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody528Type


class TwentyEight(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody528Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody527Type = Literal[
    "flesch_reading_ease",
]


class TwentySevenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody527Type


class TwentySeven(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody527Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody526Type = Literal[
    "most_repeated_words",
]


class TwentySixTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody526Type


class TwentySix(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody526Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody525Type = Literal[
    "keywords_match",
]


class TwentyFiveTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody525Type
    keywords: List[str]


class TwentyFive(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody525Type

    keywords: List[str]


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody524Type = Literal[
    "levenshtein_distance",
]


class TwentyFourTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody524Type


class TwentyFour(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody524Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody523Type = Literal[
    "cosine_similarity",
]


class TwentyThreeTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody523Type


class TwentyThree(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody523Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody522Type = Literal[
    "meteor_score",
]


class TwentyTwoTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody522Type


class TwentyTwo(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody522Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody521Type = Literal[
    "rouge_n",
]


class TwentyOneTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody521Type


class TwentyOne(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody521Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody520Type = Literal[
    "bleu_score",
]


class TwentyTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody520Type


class Twenty(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody520Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody519Type = Literal[
    "bert_score",
]


class NineteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody519Type


class Nineteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody519Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody518Type = Literal[
    "moderations_google",
]


class EighteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody518Type


class Eighteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody518Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody517Type = Literal[
    "moderations_openai",
]


class SeventeenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody517Type


class Seventeen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody517Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody516Type = Literal[
    "is_valid_json",
]


class SixteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody516Type


class Sixteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody516Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody515Type = Literal[
    "regex",
]


class FifteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody515Type
    pattern: str


class Fifteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody515Type

    pattern: str


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody514Type = Literal[
    "one_line",
]


class FourteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody514Type


class Fourteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody514Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody513Type = Literal[
    "length_greater_than",
]


class ThirteenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody513Type
    value: float


class Thirteen(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody513Type

    value: float


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody512Type = Literal[
    "length_between",
]


class TwelveTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody512Type
    min: float
    max: float


class Twelve(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody512Type

    min: float

    max: float


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody511Type = Literal[
    "length_less_than",
]


class ElevenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody511Type
    value: float


class Eleven(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody511Type

    value: float


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody510Type = Literal[
    "exact_match",
]


class TenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody510Type


class Ten(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody510Type


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody59Type = Literal[
    "ends_with",
]


class NineTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody59Type
    value: str


class Nine(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody59Type

    value: str


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody5Type = Literal[
    "start_with",
]


class EightTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody5Type
    value: str


class Eight(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBody5Type

    value: str


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBodyType = Literal[
    "contains_valid_link",
]


class SevenTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBodyType


class Seven(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONResponseBodyType


CreateEvalFunctionParamsEvalsResponse200ApplicationJSONType = Literal["contains_url",]


class SixTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONType


class Six(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200ApplicationJSONType


CreateEvalFunctionParamsEvalsResponse200Type = Literal["contains_email",]


class FiveTypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponse200Type


class Five(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponse200Type


CreateEvalFunctionParamsEvalsResponseType = Literal["contains_any",]


class CreateEvalFunctionParams4TypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsResponseType
    keywords: List[str]


class CreateEvalFunctionParams4(BaseModel):
    type: CreateEvalFunctionParamsEvalsResponseType

    keywords: List[str]


CreateEvalFunctionParamsEvalsType = Literal["contains_all",]


class CreateEvalFunctionParams3TypedDict(TypedDict):
    type: CreateEvalFunctionParamsEvalsType
    keywords: List[str]


class CreateEvalFunctionParams3(BaseModel):
    type: CreateEvalFunctionParamsEvalsType

    keywords: List[str]


CreateEvalFunctionParamsType = Literal["contains_none",]


class FunctionParams2TypedDict(TypedDict):
    type: CreateEvalFunctionParamsType
    keywords: List[str]


class FunctionParams2(BaseModel):
    type: CreateEvalFunctionParamsType

    keywords: List[str]


FunctionParamsType = Literal["contains",]


class FunctionParams1TypedDict(TypedDict):
    type: FunctionParamsType
    value: str


class FunctionParams1(BaseModel):
    type: FunctionParamsType

    value: str


FunctionParamsTypedDict = TypeAliasType(
    "FunctionParamsTypedDict",
    Union[
        TwentySevenTypedDict,
        TwentySixTypedDict,
        ThirtyOneTypedDict,
        ThirtyTypedDict,
        FiveTypedDict,
        SixTypedDict,
        SevenTypedDict,
        TwentyNineTypedDict,
        TwentyEightTypedDict,
        TenTypedDict,
        ThirtyTwoTypedDict,
        TwentyFourTypedDict,
        TwentyTwoTypedDict,
        FourteenTypedDict,
        TwentyThreeTypedDict,
        SixteenTypedDict,
        SeventeenTypedDict,
        EighteenTypedDict,
        NineteenTypedDict,
        TwentyTypedDict,
        TwentyOneTypedDict,
        NineTypedDict,
        FifteenTypedDict,
        ThirteenTypedDict,
        TwentyFiveTypedDict,
        ElevenTypedDict,
        FunctionParams1TypedDict,
        EightTypedDict,
        CreateEvalFunctionParams4TypedDict,
        CreateEvalFunctionParams3TypedDict,
        FunctionParams2TypedDict,
        TwelveTypedDict,
    ],
)


FunctionParams = Annotated[
    Union[
        Annotated[FunctionParams1, Tag("contains")],
        Annotated[FunctionParams2, Tag("contains_none")],
        Annotated[CreateEvalFunctionParams3, Tag("contains_all")],
        Annotated[CreateEvalFunctionParams4, Tag("contains_any")],
        Annotated[Five, Tag("contains_email")],
        Annotated[Six, Tag("contains_url")],
        Annotated[Seven, Tag("contains_valid_link")],
        Annotated[Eight, Tag("start_with")],
        Annotated[Nine, Tag("ends_with")],
        Annotated[Ten, Tag("exact_match")],
        Annotated[Eleven, Tag("length_less_than")],
        Annotated[Twelve, Tag("length_between")],
        Annotated[Thirteen, Tag("length_greater_than")],
        Annotated[Fourteen, Tag("one_line")],
        Annotated[Fifteen, Tag("regex")],
        Annotated[Sixteen, Tag("is_valid_json")],
        Annotated[Seventeen, Tag("moderations_openai")],
        Annotated[Eighteen, Tag("moderations_google")],
        Annotated[Nineteen, Tag("bert_score")],
        Annotated[Twenty, Tag("bleu_score")],
        Annotated[TwentyOne, Tag("rouge_n")],
        Annotated[TwentyTwo, Tag("meteor_score")],
        Annotated[TwentyThree, Tag("cosine_similarity")],
        Annotated[TwentyFour, Tag("levenshtein_distance")],
        Annotated[TwentyFive, Tag("keywords_match")],
        Annotated[TwentySix, Tag("most_repeated_words")],
        Annotated[TwentySeven, Tag("flesch_reading_ease")],
        Annotated[TwentyEight, Tag("gse_english_level")],
        Annotated[TwentyNine, Tag("words_count")],
        Annotated[Thirty, Tag("sentences_count")],
        Annotated[ThirtyOne, Tag("lexical_repetition")],
        Annotated[ThirtyTwo, Tag("grammar_diversity")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class CreateEvalResponseBodyFunctionTypedDict(TypedDict):
    id: str
    description: str
    type: CreateEvalResponseBodyEvalsResponseType
    function_params: FunctionParamsTypedDict
    key: str
    created: NotRequired[str]
    updated: NotRequired[str]
    guardrail_config: NotRequired[
        CreateEvalResponseBodyEvalsResponseGuardrailConfigTypedDict
    ]


class CreateEvalResponseBodyFunction(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    description: str

    type: CreateEvalResponseBodyEvalsResponseType

    function_params: FunctionParams

    key: str

    created: Optional[str] = "2026-02-21T10:19:06.076Z"

    updated: Optional[str] = "2026-02-21T10:19:06.076Z"

    guardrail_config: Optional[CreateEvalResponseBodyEvalsResponseGuardrailConfig] = (
        None
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "updated", "guardrail_config"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateEvalGuardrailConfigEvalsResponse200ApplicationJSONResponseBody42Type = Literal[
    "number",
]


try:
    JSON.model_rebuild()
except NameError:
    pass
try:
    Typescript.model_rebuild()
except NameError:
    pass
try:
    Ragas.model_rebuild()
except NameError:
    pass
try:
    CreateEvalResponseBodyFunction.model_rebuild()
except NameError:
    pass
