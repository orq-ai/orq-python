"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CreateKnowledgeRetrievalSettingsKnowledgeType = Literal["hybrid_search"]

CreateKnowledgeRetrievalSettingsKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

CreateKnowledgeRetrievalSettingsKnowledgeModelType = Literal["rerank"]


class CreateKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[CreateKnowledgeRetrievalSettingsKnowledgeProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[CreateKnowledgeRetrievalSettingsKnowledgeModelType]
    model_parameters: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict
    ]


class CreateKnowledgeRetrievalSettingsRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[CreateKnowledgeRetrievalSettingsKnowledgeProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[CreateKnowledgeRetrievalSettingsKnowledgeModelType] = None

    model_parameters: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeModelParameters
    ] = None


class RetrievalSettings3TypedDict(TypedDict):
    type: CreateKnowledgeRetrievalSettingsKnowledgeType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[CreateKnowledgeRetrievalSettingsRerankConfigTypedDict]
    ]


class RetrievalSettings3(BaseModel):
    type: CreateKnowledgeRetrievalSettingsKnowledgeType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[CreateKnowledgeRetrievalSettingsRerankConfig] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


CreateKnowledgeRetrievalSettingsType = Literal["keyword_search"]

CreateKnowledgeRetrievalSettingsProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

CreateKnowledgeRetrievalSettingsModelType = Literal["rerank"]


class CreateKnowledgeRetrievalSettingsModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class RetrievalSettingsRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[CreateKnowledgeRetrievalSettingsProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[CreateKnowledgeRetrievalSettingsModelType]
    model_parameters: NotRequired[
        CreateKnowledgeRetrievalSettingsModelParametersTypedDict
    ]


class RetrievalSettingsRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[CreateKnowledgeRetrievalSettingsProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[CreateKnowledgeRetrievalSettingsModelType] = None

    model_parameters: Optional[CreateKnowledgeRetrievalSettingsModelParameters] = None


class RetrievalSettings2TypedDict(TypedDict):
    type: CreateKnowledgeRetrievalSettingsType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[Nullable[RetrievalSettingsRerankConfigTypedDict]]


class RetrievalSettings2(BaseModel):
    type: CreateKnowledgeRetrievalSettingsType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[RetrievalSettingsRerankConfig] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


RetrievalSettingsType = Literal["vector_search"]

RetrievalSettingsProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

RetrievalSettingsModelType = Literal["rerank"]


class RetrievalSettingsModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class RetrievalSettingsModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class RerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[RetrievalSettingsProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[RetrievalSettingsModelType]
    model_parameters: NotRequired[RetrievalSettingsModelParametersTypedDict]


class RerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[RetrievalSettingsProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[RetrievalSettingsModelType] = None

    model_parameters: Optional[RetrievalSettingsModelParameters] = None


class RetrievalSettings1TypedDict(TypedDict):
    type: RetrievalSettingsType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[Nullable[RerankConfigTypedDict]]


class RetrievalSettings1(BaseModel):
    type: RetrievalSettingsType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[RerankConfig] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


RetrievalSettingsTypedDict = TypeAliasType(
    "RetrievalSettingsTypedDict",
    Union[
        RetrievalSettings1TypedDict,
        RetrievalSettings2TypedDict,
        RetrievalSettings3TypedDict,
    ],
)
r"""The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy."""


RetrievalSettings = TypeAliasType(
    "RetrievalSettings",
    Union[RetrievalSettings1, RetrievalSettings2, RetrievalSettings3],
)
r"""The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy."""


class CreateKnowledgeRequestBodyTypedDict(TypedDict):
    key: str
    model: str
    r"""The embeddings model to use for the knowledge base."""
    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    description: NotRequired[str]
    retrieval_settings: NotRequired[RetrievalSettingsTypedDict]
    r"""The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy."""


class CreateKnowledgeRequestBody(BaseModel):
    key: str

    model: str
    r"""The embeddings model to use for the knowledge base."""

    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    description: Optional[str] = None

    retrieval_settings: Optional[RetrievalSettings] = None
    r"""The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy."""


class CreateKnowledgeMetadataTypedDict(TypedDict):
    word_count: NotRequired[int]
    document_count: NotRequired[int]
    sentences_count: NotRequired[int]


class CreateKnowledgeMetadata(BaseModel):
    word_count: Optional[int] = 0

    document_count: Optional[int] = 0

    sentences_count: Optional[int] = 0


CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType = Literal[
    "hybrid_search"
]

CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType = Literal[
    "rerank"
]


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParameters(
    BaseModel
):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfigTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    provider: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider
    ]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType
    ]
    model_parameters: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider
    ] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType
    ] = None

    model_parameters: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateKnowledgeRetrievalSettings3TypedDict(TypedDict):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[
            CreateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfigTypedDict
        ]
    ]


class CreateKnowledgeRetrievalSettings3(BaseModel):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


CreateKnowledgeRetrievalSettingsKnowledgeResponse200Type = Literal["keyword_search"]

CreateKnowledgeRetrievalSettingsKnowledgeResponse200Provider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType = Literal["rerank"]


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[CreateKnowledgeRetrievalSettingsKnowledgeResponse200Provider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType
    ]
    model_parameters: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[CreateKnowledgeRetrievalSettingsKnowledgeResponse200Provider] = (
        None
    )

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType
    ] = None

    model_parameters: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateKnowledgeRetrievalSettings2TypedDict(TypedDict):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponse200Type
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[CreateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict]
    ]


class CreateKnowledgeRetrievalSettings2(BaseModel):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponse200Type

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        CreateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


CreateKnowledgeRetrievalSettingsKnowledgeResponseType = Literal["vector_search"]

CreateKnowledgeRetrievalSettingsKnowledgeResponseProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

CreateKnowledgeRetrievalSettingsKnowledgeResponseModelType = Literal["rerank"]


class CreateKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeResponseModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class CreateKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[CreateKnowledgeRetrievalSettingsKnowledgeResponseProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[CreateKnowledgeRetrievalSettingsKnowledgeResponseModelType]
    model_parameters: NotRequired[
        CreateKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class CreateKnowledgeRetrievalSettingsKnowledgeRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[CreateKnowledgeRetrievalSettingsKnowledgeResponseProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[CreateKnowledgeRetrievalSettingsKnowledgeResponseModelType] = (
        None
    )

    model_parameters: Optional[
        CreateKnowledgeRetrievalSettingsKnowledgeResponseModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateKnowledgeRetrievalSettings1TypedDict(TypedDict):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponseType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[CreateKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict]
    ]


class CreateKnowledgeRetrievalSettings1(BaseModel):
    type: CreateKnowledgeRetrievalSettingsKnowledgeResponseType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        CreateKnowledgeRetrievalSettingsKnowledgeRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


CreateKnowledgeRetrievalSettingsTypedDict = TypeAliasType(
    "CreateKnowledgeRetrievalSettingsTypedDict",
    Union[
        CreateKnowledgeRetrievalSettings1TypedDict,
        CreateKnowledgeRetrievalSettings2TypedDict,
        CreateKnowledgeRetrievalSettings3TypedDict,
    ],
)


CreateKnowledgeRetrievalSettings = TypeAliasType(
    "CreateKnowledgeRetrievalSettings",
    Union[
        CreateKnowledgeRetrievalSettings1,
        CreateKnowledgeRetrievalSettings2,
        CreateKnowledgeRetrievalSettings3,
    ],
)


class CreateKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Knowledge Base object"""

    id: str
    r"""The unique identifier of the knowledge base."""
    created_by_id: str
    r"""The id of the resource"""
    created: str
    r"""The creation date of the knowledge base."""
    key: str
    r"""The unique key of the knowledge base."""
    metadata: CreateKnowledgeMetadataTypedDict
    model: str
    r"""The embeddings model used for the knowledge base."""
    retrieval_settings: CreateKnowledgeRetrievalSettingsTypedDict
    update_by_id: str
    r"""The id of the resource"""
    updated: str
    r"""The last update date of the knowledge base."""
    description: NotRequired[str]
    r"""The description of the knowledge base."""
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""


class CreateKnowledgeResponseBody(BaseModel):
    r"""Knowledge Base object"""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the knowledge base."""

    created_by_id: str
    r"""The id of the resource"""

    created: str
    r"""The creation date of the knowledge base."""

    key: str
    r"""The unique key of the knowledge base."""

    metadata: CreateKnowledgeMetadata

    model: str
    r"""The embeddings model used for the knowledge base."""

    retrieval_settings: CreateKnowledgeRetrievalSettings

    update_by_id: str
    r"""The id of the resource"""

    updated: str
    r"""The last update date of the knowledge base."""

    description: Optional[str] = None
    r"""The description of the knowledge base."""

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
