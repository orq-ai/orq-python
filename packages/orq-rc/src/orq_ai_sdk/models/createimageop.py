"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .publiccontact import PublicContact, PublicContactTypedDict
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional
from typing_extensions import NotRequired, TypedDict, deprecated


Background = Literal[
    "transparent",
    "opaque",
    "auto",
]
r"""Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`."""


Moderation = Literal[
    "low",
    "auto",
]
r"""Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`."""


OutputFormat = Literal[
    "png",
    "jpeg",
    "webp",
]
r"""The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`."""


Quality = Literal[
    "auto",
    "high",
    "medium",
    "low",
    "hd",
    "standard",
]
r"""The quality of the image that will be generated. `auto` will automatically select the best quality for the given model."""


CreateImageResponseFormat = Literal[
    "url",
    "b64_json",
]
r"""The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."""


Style = Literal[
    "vivid",
    "natural",
]
r"""The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`."""


class CreateImageRetryTypedDict(TypedDict):
    r"""Retry configuration for the request"""

    count: NotRequired[float]
    r"""Number of retry attempts (1-5)"""
    on_codes: NotRequired[List[float]]
    r"""HTTP status codes that trigger retry logic"""


class CreateImageRetry(BaseModel):
    r"""Retry configuration for the request"""

    count: Optional[float] = 3
    r"""Number of retry attempts (1-5)"""

    on_codes: Optional[List[float]] = None
    r"""HTTP status codes that trigger retry logic"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageFallbacksTypedDict(TypedDict):
    model: str
    r"""Fallback model identifier"""


class CreateImageFallbacks(BaseModel):
    model: str
    r"""Fallback model identifier"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageContactTypedDict(TypedDict):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageContact(BaseModel):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageType = Literal["exact_match",]


class CreateImageCacheTypedDict(TypedDict):
    r"""Cache configuration for the request."""

    type: CreateImageType
    ttl: NotRequired[float]
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""


class CreateImageCache(BaseModel):
    r"""Cache configuration for the request."""

    type: CreateImageType

    ttl: Optional[float] = 1800
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageLoadBalancerType = Literal["weight_based",]


class CreateImageLoadBalancerModelsTypedDict(TypedDict):
    model: str
    r"""Model identifier for load balancing"""
    weight: NotRequired[float]
    r"""Weight assigned to this model for load balancing"""


class CreateImageLoadBalancerModels(BaseModel):
    model: str
    r"""Model identifier for load balancing"""

    weight: Optional[float] = 0.5
    r"""Weight assigned to this model for load balancing"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["weight"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageLoadBalancer1TypedDict(TypedDict):
    type: CreateImageLoadBalancerType
    models: List[CreateImageLoadBalancerModelsTypedDict]


class CreateImageLoadBalancer1(BaseModel):
    type: CreateImageLoadBalancerType

    models: List[CreateImageLoadBalancerModels]


CreateImageLoadBalancerTypedDict = CreateImageLoadBalancer1TypedDict
r"""Array of models with weights for load balancing requests"""


CreateImageLoadBalancer = CreateImageLoadBalancer1
r"""Array of models with weights for load balancing requests"""


class CreateImageTimeoutTypedDict(TypedDict):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageTimeout(BaseModel):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageOrqTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name to display on the trace. If not specified, the default system name will be used."""
    retry: NotRequired[CreateImageRetryTypedDict]
    r"""Retry configuration for the request"""
    fallbacks: NotRequired[List[CreateImageFallbacksTypedDict]]
    r"""Array of fallback models to use if primary model fails"""
    identity: NotRequired[PublicContactTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[CreateImageContactTypedDict]
    cache: NotRequired[CreateImageCacheTypedDict]
    r"""Cache configuration for the request."""
    load_balancer: NotRequired[CreateImageLoadBalancerTypedDict]
    r"""Array of models with weights for load balancing requests"""
    timeout: NotRequired[CreateImageTimeoutTypedDict]
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""


class CreateImageOrq(BaseModel):
    name: Optional[str] = None
    r"""The name to display on the trace. If not specified, the default system name will be used."""

    retry: Optional[CreateImageRetry] = None
    r"""Retry configuration for the request"""

    fallbacks: Optional[List[CreateImageFallbacks]] = None
    r"""Array of fallback models to use if primary model fails"""

    identity: Optional[PublicContact] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Optional[CreateImageContact] = None

    cache: Optional[CreateImageCache] = None
    r"""Cache configuration for the request."""

    load_balancer: Optional[CreateImageLoadBalancer] = None
    r"""Array of models with weights for load balancing requests"""

    timeout: Optional[CreateImageTimeout] = None
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "name",
                "retry",
                "fallbacks",
                "identity",
                "contact",
                "cache",
                "load_balancer",
                "timeout",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageRequestBodyTypedDict(TypedDict):
    r"""input"""

    prompt: str
    r"""A text description of the desired image(s)."""
    model: str
    r"""The model to use for image generation. One of `openai/dall-e-2`, `openai/dall-e-3`, or `openai/gpt-image-1`."""
    background: NotRequired[Nullable[Background]]
    r"""Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`."""
    moderation: NotRequired[Nullable[Moderation]]
    r"""Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`."""
    n: NotRequired[Nullable[int]]
    r"""The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."""
    output_compression: NotRequired[Nullable[int]]
    r"""The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats."""
    output_format: NotRequired[Nullable[OutputFormat]]
    r"""The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`."""
    quality: NotRequired[Nullable[Quality]]
    r"""The quality of the image that will be generated. `auto` will automatically select the best quality for the given model."""
    response_format: NotRequired[Nullable[CreateImageResponseFormat]]
    r"""The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."""
    size: NotRequired[Nullable[str]]
    r"""The size of the generated images. Must be one of the specified sizes for each model."""
    style: NotRequired[Nullable[Style]]
    r"""The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`."""
    orq: NotRequired[CreateImageOrqTypedDict]


class CreateImageRequestBody(BaseModel):
    r"""input"""

    prompt: str
    r"""A text description of the desired image(s)."""

    model: str
    r"""The model to use for image generation. One of `openai/dall-e-2`, `openai/dall-e-3`, or `openai/gpt-image-1`."""

    background: OptionalNullable[Background] = UNSET
    r"""Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`."""

    moderation: OptionalNullable[Moderation] = UNSET
    r"""Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`."""

    n: OptionalNullable[int] = 1
    r"""The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."""

    output_compression: OptionalNullable[int] = UNSET
    r"""The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats."""

    output_format: OptionalNullable[OutputFormat] = UNSET
    r"""The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`."""

    quality: OptionalNullable[Quality] = UNSET
    r"""The quality of the image that will be generated. `auto` will automatically select the best quality for the given model."""

    response_format: OptionalNullable[CreateImageResponseFormat] = UNSET
    r"""The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."""

    size: OptionalNullable[str] = UNSET
    r"""The size of the generated images. Must be one of the specified sizes for each model."""

    style: OptionalNullable[Style] = UNSET
    r"""The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`."""

    orq: Optional[CreateImageOrq] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "background",
                "moderation",
                "n",
                "output_compression",
                "output_format",
                "quality",
                "response_format",
                "size",
                "style",
                "orq",
            ]
        )
        nullable_fields = set(
            [
                "background",
                "moderation",
                "n",
                "output_compression",
                "output_format",
                "quality",
                "response_format",
                "size",
                "style",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateImageDataTypedDict(TypedDict):
    revised_prompt: NotRequired[Nullable[str]]
    r"""The prompt that was used to generate the image, if there was any revision to the prompt."""
    b64_json: NotRequired[str]
    r"""The base64-encoded JSON of the generated image, if `response_format` is `b64_json`"""
    url: NotRequired[str]
    r"""The url of the generated image, if `response_format` is `url` (default)"""


class CreateImageData(BaseModel):
    revised_prompt: OptionalNullable[str] = UNSET
    r"""The prompt that was used to generate the image, if there was any revision to the prompt."""

    b64_json: Optional[str] = None
    r"""The base64-encoded JSON of the generated image, if `response_format` is `b64_json`"""

    url: Optional[str] = None
    r"""The url of the generated image, if `response_format` is `url` (default)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revised_prompt", "b64_json", "url"])
        nullable_fields = set(["revised_prompt"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class InputTokensDetailsTypedDict(TypedDict):
    image_tokens: NotRequired[float]
    text_tokens: NotRequired[float]


class InputTokensDetails(BaseModel):
    image_tokens: Optional[float] = None

    text_tokens: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["image_tokens", "text_tokens"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageUsageTypedDict(TypedDict):
    input_tokens_details: InputTokensDetailsTypedDict
    input_tokens: NotRequired[float]
    output_tokens: NotRequired[float]
    total_tokens: NotRequired[float]


class CreateImageUsage(BaseModel):
    input_tokens_details: InputTokensDetails

    input_tokens: Optional[float] = None

    output_tokens: Optional[float] = None

    total_tokens: Optional[float] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["input_tokens", "output_tokens", "total_tokens"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageResponseBodyTypedDict(TypedDict):
    r"""Represents an image generation response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""
    data: List[CreateImageDataTypedDict]
    r"""Represents the url or the content of an image generated."""
    usage: NotRequired[CreateImageUsageTypedDict]


class CreateImageResponseBody(BaseModel):
    r"""Represents an image generation response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""

    data: List[CreateImageData]
    r"""Represents the url or the content of an image generated."""

    usage: Optional[CreateImageUsage] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["usage"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
