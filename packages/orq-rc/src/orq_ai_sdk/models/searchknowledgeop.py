"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


SearchType = Literal["vector_search", "keyword_search", "hybrid_search"]
r"""The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`"""


class SearchKnowledgeOrExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledgeOrExists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledgeOrKnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeNin = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNin", Union[str, float, bool]
)


class SearchKnowledgeOrNinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledgeOrKnowledgeNinTypedDict]


class SearchKnowledgeOrNin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledgeOrKnowledgeNin]


SearchKnowledgeOrKnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeIn = TypeAliasType(
    "SearchKnowledgeOrKnowledgeIn", Union[str, float, bool]
)


class SearchKnowledgeOrInTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledgeOrKnowledgeInTypedDict]


class SearchKnowledgeOrIn(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledgeOrKnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledgeOrLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeOrLte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeOrLtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledgeOrLt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledgeOrGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeOrGte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeOr3TypedDict(TypedDict):
    gt: float


class SearchKnowledgeOr3(BaseModel):
    gt: float


SearchKnowledgeOrKnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeNe = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNe", Union[str, float, bool]
)


class SearchKnowledgeOrNeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledgeOrKnowledgeNeTypedDict


class SearchKnowledgeOrNe(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledgeOrKnowledgeNe


SearchKnowledgeOrKnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeEq = TypeAliasType(
    "SearchKnowledgeOrKnowledgeEq", Union[str, float, bool]
)


class SearchKnowledgeOrEqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledgeOrKnowledgeEqTypedDict


class SearchKnowledgeOrEq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledgeOrKnowledgeEq


SearchKnowledgeFilterByOrTypedDict = TypeAliasType(
    "SearchKnowledgeFilterByOrTypedDict",
    Union[
        SearchKnowledgeOrEqTypedDict,
        SearchKnowledgeOrNeTypedDict,
        SearchKnowledgeOr3TypedDict,
        SearchKnowledgeOrGteTypedDict,
        SearchKnowledgeOrLtTypedDict,
        SearchKnowledgeOrLteTypedDict,
        SearchKnowledgeOrInTypedDict,
        SearchKnowledgeOrNinTypedDict,
        SearchKnowledgeOrExistsTypedDict,
    ],
)


SearchKnowledgeFilterByOr = TypeAliasType(
    "SearchKnowledgeFilterByOr",
    Union[
        SearchKnowledgeOrEq,
        SearchKnowledgeOrNe,
        SearchKnowledgeOr3,
        SearchKnowledgeOrGte,
        SearchKnowledgeOrLt,
        SearchKnowledgeOrLte,
        SearchKnowledgeOrIn,
        SearchKnowledgeOrNin,
        SearchKnowledgeOrExists,
    ],
)


class FilterByOrTypedDict(TypedDict):
    r"""Or"""

    or_: List[Dict[str, SearchKnowledgeFilterByOrTypedDict]]


class FilterByOr(BaseModel):
    r"""Or"""

    or_: Annotated[
        List[Dict[str, SearchKnowledgeFilterByOr]], pydantic.Field(alias="or")
    ]


class SearchKnowledgeAndExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledgeAndExists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledgeAndKnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeNin = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNin", Union[str, float, bool]
)


class SearchKnowledgeAndNinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledgeAndKnowledgeNinTypedDict]


class SearchKnowledgeAndNin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledgeAndKnowledgeNin]


SearchKnowledgeAndKnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeIn = TypeAliasType(
    "SearchKnowledgeAndKnowledgeIn", Union[str, float, bool]
)


class SearchKnowledgeAndInTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledgeAndKnowledgeInTypedDict]


class SearchKnowledgeAndIn(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledgeAndKnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledgeAndLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeAndLte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeAndLtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledgeAndLt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledgeAndGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeAndGte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeAnd3TypedDict(TypedDict):
    gt: float


class SearchKnowledgeAnd3(BaseModel):
    gt: float


SearchKnowledgeAndKnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeNe = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNe", Union[str, float, bool]
)


class SearchKnowledgeAndNeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledgeAndKnowledgeNeTypedDict


class SearchKnowledgeAndNe(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledgeAndKnowledgeNe


SearchKnowledgeAndKnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeEq = TypeAliasType(
    "SearchKnowledgeAndKnowledgeEq", Union[str, float, bool]
)


class SearchKnowledgeAndEqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledgeAndKnowledgeEqTypedDict


class SearchKnowledgeAndEq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledgeAndKnowledgeEq


SearchKnowledgeFilterByAndTypedDict = TypeAliasType(
    "SearchKnowledgeFilterByAndTypedDict",
    Union[
        SearchKnowledgeAndEqTypedDict,
        SearchKnowledgeAndNeTypedDict,
        SearchKnowledgeAnd3TypedDict,
        SearchKnowledgeAndGteTypedDict,
        SearchKnowledgeAndLtTypedDict,
        SearchKnowledgeAndLteTypedDict,
        SearchKnowledgeAndInTypedDict,
        SearchKnowledgeAndNinTypedDict,
        SearchKnowledgeAndExistsTypedDict,
    ],
)


SearchKnowledgeFilterByAnd = TypeAliasType(
    "SearchKnowledgeFilterByAnd",
    Union[
        SearchKnowledgeAndEq,
        SearchKnowledgeAndNe,
        SearchKnowledgeAnd3,
        SearchKnowledgeAndGte,
        SearchKnowledgeAndLt,
        SearchKnowledgeAndLte,
        SearchKnowledgeAndIn,
        SearchKnowledgeAndNin,
        SearchKnowledgeAndExists,
    ],
)


class FilterByAndTypedDict(TypedDict):
    r"""And"""

    and_: List[Dict[str, SearchKnowledgeFilterByAndTypedDict]]


class FilterByAnd(BaseModel):
    r"""And"""

    and_: Annotated[
        List[Dict[str, SearchKnowledgeFilterByAnd]], pydantic.Field(alias="and")
    ]


class SearchKnowledge1ExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledge1Exists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledge1KnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeNin = TypeAliasType(
    "SearchKnowledge1KnowledgeNin", Union[str, float, bool]
)


class SearchKnowledge1NinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledge1KnowledgeNinTypedDict]


class SearchKnowledge1Nin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledge1KnowledgeNin]


SearchKnowledge1KnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeIn = TypeAliasType(
    "SearchKnowledge1KnowledgeIn", Union[str, float, bool]
)


class SearchKnowledge1InTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledge1KnowledgeInTypedDict]


class SearchKnowledge1In(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledge1KnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledge1LteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledge1Lte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledge1LtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledge1Lt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledge1GteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledge1Gte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledge13TypedDict(TypedDict):
    gt: float


class SearchKnowledge13(BaseModel):
    gt: float


SearchKnowledge1KnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeNe = TypeAliasType(
    "SearchKnowledge1KnowledgeNe", Union[str, float, bool]
)


class SearchKnowledge1NeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledge1KnowledgeNeTypedDict


class SearchKnowledge1Ne(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledge1KnowledgeNe


SearchKnowledge1KnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeEq = TypeAliasType(
    "SearchKnowledge1KnowledgeEq", Union[str, float, bool]
)


class SearchKnowledge1EqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledge1KnowledgeEqTypedDict


class SearchKnowledge1Eq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledge1KnowledgeEq


FilterBy1TypedDict = TypeAliasType(
    "FilterBy1TypedDict",
    Union[
        SearchKnowledge1EqTypedDict,
        SearchKnowledge1NeTypedDict,
        SearchKnowledge13TypedDict,
        SearchKnowledge1GteTypedDict,
        SearchKnowledge1LtTypedDict,
        SearchKnowledge1LteTypedDict,
        SearchKnowledge1InTypedDict,
        SearchKnowledge1NinTypedDict,
        SearchKnowledge1ExistsTypedDict,
    ],
)


FilterBy1 = TypeAliasType(
    "FilterBy1",
    Union[
        SearchKnowledge1Eq,
        SearchKnowledge1Ne,
        SearchKnowledge13,
        SearchKnowledge1Gte,
        SearchKnowledge1Lt,
        SearchKnowledge1Lte,
        SearchKnowledge1In,
        SearchKnowledge1Nin,
        SearchKnowledge1Exists,
    ],
)


FilterByTypedDict = TypeAliasType(
    "FilterByTypedDict",
    Union[FilterByAndTypedDict, FilterByOrTypedDict, Dict[str, FilterBy1TypedDict]],
)
r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""


FilterBy = TypeAliasType(
    "FilterBy", Union[FilterByAnd, FilterByOr, Dict[str, FilterBy1]]
)
r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""


class SearchOptionsTypedDict(TypedDict):
    r"""Additional search options"""

    include_vectors: NotRequired[bool]
    r"""Whether to include the vector in the chunk"""
    include_metadata: NotRequired[bool]
    r"""Whether to include the metadata in the chunk"""
    include_scores: NotRequired[bool]
    r"""Whether to include the scores in the chunk"""


class SearchOptions(BaseModel):
    r"""Additional search options"""

    include_vectors: Optional[bool] = None
    r"""Whether to include the vector in the chunk"""

    include_metadata: Optional[bool] = None
    r"""Whether to include the metadata in the chunk"""

    include_scores: Optional[bool] = None
    r"""Whether to include the scores in the chunk"""


SearchKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
    "litellm",
    "openailike",
    "cerebras",
    "bytedance",
]

SearchKnowledgeModelType = Literal["rerank"]


class SearchKnowledgeModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class SearchKnowledgeModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class SearchKnowledgeRerankConfigTypedDict(TypedDict):
    r"""Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings."""

    enabled: NotRequired[bool]
    provider: NotRequired[SearchKnowledgeProvider]
    top_k: NotRequired[int]
    r"""The number of results to return by the reranking model"""
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[SearchKnowledgeModelType]
    model_parameters: NotRequired[SearchKnowledgeModelParametersTypedDict]


class SearchKnowledgeRerankConfig(BaseModel):
    r"""Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings."""

    enabled: Optional[bool] = None

    provider: Optional[SearchKnowledgeProvider] = None

    top_k: Optional[int] = None
    r"""The number of results to return by the reranking model"""

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[SearchKnowledgeModelType] = None

    model_parameters: Optional[SearchKnowledgeModelParameters] = None


SearchKnowledgeKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
    "litellm",
    "openailike",
    "cerebras",
    "bytedance",
]


class SearchKnowledgeAgenticRagConfigTypedDict(TypedDict):
    r"""Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings."""

    model_db_id: str
    provider: SearchKnowledgeKnowledgeProvider
    integration_id: NotRequired[Nullable[str]]


class SearchKnowledgeAgenticRagConfig(BaseModel):
    r"""Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings."""

    model_db_id: str

    provider: SearchKnowledgeKnowledgeProvider

    integration_id: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["integration_id"]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class SearchKnowledgeRequestBodyTypedDict(TypedDict):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""
    top_k: NotRequired[int]
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`."""
    threshold: NotRequired[float]
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""
    search_type: NotRequired[SearchType]
    r"""The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`"""
    filter_by: NotRequired[FilterByTypedDict]
    r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""
    search_options: NotRequired[SearchOptionsTypedDict]
    r"""Additional search options"""
    rerank_config: NotRequired[Nullable[SearchKnowledgeRerankConfigTypedDict]]
    r"""Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings."""
    agentic_rag_config: NotRequired[SearchKnowledgeAgenticRagConfigTypedDict]
    r"""Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings."""


class SearchKnowledgeRequestBody(BaseModel):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""

    top_k: Optional[int] = None
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`."""

    threshold: Optional[float] = None
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""

    search_type: Optional[SearchType] = "hybrid_search"
    r"""The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`"""

    filter_by: Optional[FilterBy] = None
    r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""

    search_options: Optional[SearchOptions] = None
    r"""Additional search options"""

    rerank_config: OptionalNullable[SearchKnowledgeRerankConfig] = UNSET
    r"""Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings."""

    agentic_rag_config: Optional[SearchKnowledgeAgenticRagConfig] = None
    r"""Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "top_k",
            "threshold",
            "search_type",
            "filter_by",
            "search_options",
            "rerank_config",
            "agentic_rag_config",
        ]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class SearchKnowledgeRequestTypedDict(TypedDict):
    knowledge_id: str
    r"""The unique identifier or key of the knowledge base"""
    request_body: NotRequired[SearchKnowledgeRequestBodyTypedDict]
    r"""A search request for chunks in a knowledge base"""


class SearchKnowledgeRequest(BaseModel):
    knowledge_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier or key of the knowledge base"""

    request_body: Annotated[
        Optional[SearchKnowledgeRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None
    r"""A search request for chunks in a knowledge base"""


class ScoresTypedDict(TypedDict):
    rerank_score: NotRequired[float]
    search_score: NotRequired[float]


class Scores(BaseModel):
    rerank_score: Optional[float] = None

    search_score: Optional[float] = None


class MatchesTypedDict(TypedDict):
    id: str
    text: str
    vector: NotRequired[List[float]]
    metadata: NotRequired[Dict[str, Any]]
    scores: NotRequired[ScoresTypedDict]


class Matches(BaseModel):
    id: str

    text: str

    vector: Optional[List[float]] = None

    metadata: Optional[Dict[str, Any]] = None

    scores: Optional[Scores] = None


class SearchKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Search knowledge base"""

    matches: List[MatchesTypedDict]


class SearchKnowledgeResponseBody(BaseModel):
    r"""Search knowledge base"""

    matches: List[Matches]
