"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SearchKnowledgeDollarOrDollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class SearchKnowledgeDollarOrDollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


SearchKnowledgeDollarOrKnowledgeDollarNinTypedDict = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarOrKnowledgeDollarNin = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarNin", Union[str, float, bool]
)


class SearchKnowledgeDollarOrDollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[SearchKnowledgeDollarOrKnowledgeDollarNinTypedDict]


class SearchKnowledgeDollarOrDollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[
        List[SearchKnowledgeDollarOrKnowledgeDollarNin], pydantic.Field(alias="$nin")
    ]


SearchKnowledgeDollarOrKnowledgeDollarInTypedDict = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarInTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarOrKnowledgeDollarIn = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarIn", Union[str, float, bool]
)


class SearchKnowledgeDollarOrDollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[SearchKnowledgeDollarOrKnowledgeDollarInTypedDict]


class SearchKnowledgeDollarOrDollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[
        List[SearchKnowledgeDollarOrKnowledgeDollarIn], pydantic.Field(alias="$in")
    ]


class SearchKnowledgeDollarOrDollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class SearchKnowledgeDollarOrDollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class SearchKnowledgeDollarOrDollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class SearchKnowledgeDollarOrDollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class SearchKnowledgeDollarOrDollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class SearchKnowledgeDollarOrDollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class SearchKnowledgeDollarOr3TypedDict(TypedDict):
    dollar_gt: float


class SearchKnowledgeDollarOr3(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


SearchKnowledgeDollarOrKnowledgeDollarNeTypedDict = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarOrKnowledgeDollarNe = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarNe", Union[str, float, bool]
)


class SearchKnowledgeDollarOrDollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: SearchKnowledgeDollarOrKnowledgeDollarNeTypedDict


class SearchKnowledgeDollarOrDollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[
        SearchKnowledgeDollarOrKnowledgeDollarNe, pydantic.Field(alias="$ne")
    ]


SearchKnowledgeDollarOrKnowledgeDollarEqTypedDict = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarOrKnowledgeDollarEq = TypeAliasType(
    "SearchKnowledgeDollarOrKnowledgeDollarEq", Union[str, float, bool]
)


class SearchKnowledgeDollarOrDollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: SearchKnowledgeDollarOrKnowledgeDollarEqTypedDict


class SearchKnowledgeDollarOrDollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[
        SearchKnowledgeDollarOrKnowledgeDollarEq, pydantic.Field(alias="$eq")
    ]


SearchKnowledgeFilterDollarOrTypedDict = TypeAliasType(
    "SearchKnowledgeFilterDollarOrTypedDict",
    Union[
        SearchKnowledgeDollarOrDollarEqTypedDict,
        SearchKnowledgeDollarOrDollarNeTypedDict,
        SearchKnowledgeDollarOr3TypedDict,
        SearchKnowledgeDollarOrDollarGteTypedDict,
        SearchKnowledgeDollarOrDollarLtTypedDict,
        SearchKnowledgeDollarOrDollarLteTypedDict,
        SearchKnowledgeDollarOrDollarInTypedDict,
        SearchKnowledgeDollarOrDollarNinTypedDict,
        SearchKnowledgeDollarOrDollarExistsTypedDict,
    ],
)


SearchKnowledgeFilterDollarOr = TypeAliasType(
    "SearchKnowledgeFilterDollarOr",
    Union[
        SearchKnowledgeDollarOrDollarEq,
        SearchKnowledgeDollarOrDollarNe,
        SearchKnowledgeDollarOr3,
        SearchKnowledgeDollarOrDollarGte,
        SearchKnowledgeDollarOrDollarLt,
        SearchKnowledgeDollarOrDollarLte,
        SearchKnowledgeDollarOrDollarIn,
        SearchKnowledgeDollarOrDollarNin,
        SearchKnowledgeDollarOrDollarExists,
    ],
)


class FilterDollarOrTypedDict(TypedDict):
    r"""Or"""

    dollar_or: List[Dict[str, SearchKnowledgeFilterDollarOrTypedDict]]


class FilterDollarOr(BaseModel):
    r"""Or"""

    dollar_or: Annotated[
        List[Dict[str, SearchKnowledgeFilterDollarOr]], pydantic.Field(alias="$or")
    ]


class SearchKnowledgeDollarAndDollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class SearchKnowledgeDollarAndDollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


SearchKnowledgeDollarAndKnowledgeDollarNinTypedDict = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarAndKnowledgeDollarNin = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarNin", Union[str, float, bool]
)


class SearchKnowledgeDollarAndDollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[SearchKnowledgeDollarAndKnowledgeDollarNinTypedDict]


class SearchKnowledgeDollarAndDollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[
        List[SearchKnowledgeDollarAndKnowledgeDollarNin], pydantic.Field(alias="$nin")
    ]


SearchKnowledgeDollarAndKnowledgeDollarInTypedDict = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarInTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarAndKnowledgeDollarIn = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarIn", Union[str, float, bool]
)


class SearchKnowledgeDollarAndDollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[SearchKnowledgeDollarAndKnowledgeDollarInTypedDict]


class SearchKnowledgeDollarAndDollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[
        List[SearchKnowledgeDollarAndKnowledgeDollarIn], pydantic.Field(alias="$in")
    ]


class SearchKnowledgeDollarAndDollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class SearchKnowledgeDollarAndDollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class SearchKnowledgeDollarAndDollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class SearchKnowledgeDollarAndDollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class SearchKnowledgeDollarAndDollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class SearchKnowledgeDollarAndDollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class SearchKnowledgeDollarAnd3TypedDict(TypedDict):
    dollar_gt: float


class SearchKnowledgeDollarAnd3(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


SearchKnowledgeDollarAndKnowledgeDollarNeTypedDict = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarAndKnowledgeDollarNe = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarNe", Union[str, float, bool]
)


class SearchKnowledgeDollarAndDollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: SearchKnowledgeDollarAndKnowledgeDollarNeTypedDict


class SearchKnowledgeDollarAndDollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[
        SearchKnowledgeDollarAndKnowledgeDollarNe, pydantic.Field(alias="$ne")
    ]


SearchKnowledgeDollarAndKnowledgeDollarEqTypedDict = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeDollarAndKnowledgeDollarEq = TypeAliasType(
    "SearchKnowledgeDollarAndKnowledgeDollarEq", Union[str, float, bool]
)


class SearchKnowledgeDollarAndDollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: SearchKnowledgeDollarAndKnowledgeDollarEqTypedDict


class SearchKnowledgeDollarAndDollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[
        SearchKnowledgeDollarAndKnowledgeDollarEq, pydantic.Field(alias="$eq")
    ]


SearchKnowledgeFilterDollarAndTypedDict = TypeAliasType(
    "SearchKnowledgeFilterDollarAndTypedDict",
    Union[
        SearchKnowledgeDollarAndDollarEqTypedDict,
        SearchKnowledgeDollarAndDollarNeTypedDict,
        SearchKnowledgeDollarAnd3TypedDict,
        SearchKnowledgeDollarAndDollarGteTypedDict,
        SearchKnowledgeDollarAndDollarLtTypedDict,
        SearchKnowledgeDollarAndDollarLteTypedDict,
        SearchKnowledgeDollarAndDollarInTypedDict,
        SearchKnowledgeDollarAndDollarNinTypedDict,
        SearchKnowledgeDollarAndDollarExistsTypedDict,
    ],
)


SearchKnowledgeFilterDollarAnd = TypeAliasType(
    "SearchKnowledgeFilterDollarAnd",
    Union[
        SearchKnowledgeDollarAndDollarEq,
        SearchKnowledgeDollarAndDollarNe,
        SearchKnowledgeDollarAnd3,
        SearchKnowledgeDollarAndDollarGte,
        SearchKnowledgeDollarAndDollarLt,
        SearchKnowledgeDollarAndDollarLte,
        SearchKnowledgeDollarAndDollarIn,
        SearchKnowledgeDollarAndDollarNin,
        SearchKnowledgeDollarAndDollarExists,
    ],
)


class FilterDollarAndTypedDict(TypedDict):
    r"""And"""

    dollar_and: List[Dict[str, SearchKnowledgeFilterDollarAndTypedDict]]


class FilterDollarAnd(BaseModel):
    r"""And"""

    dollar_and: Annotated[
        List[Dict[str, SearchKnowledgeFilterDollarAnd]], pydantic.Field(alias="$and")
    ]


class SearchKnowledge1DollarExistsTypedDict(TypedDict):
    r"""Exists"""

    dollar_exists: bool


class SearchKnowledge1DollarExists(BaseModel):
    r"""Exists"""

    dollar_exists: Annotated[bool, pydantic.Field(alias="$exists")]


SearchKnowledge1KnowledgeDollarNinTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarNinTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeDollarNin = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarNin", Union[str, float, bool]
)


class SearchKnowledge1DollarNinTypedDict(TypedDict):
    r"""Not in"""

    dollar_nin: List[SearchKnowledge1KnowledgeDollarNinTypedDict]


class SearchKnowledge1DollarNin(BaseModel):
    r"""Not in"""

    dollar_nin: Annotated[
        List[SearchKnowledge1KnowledgeDollarNin], pydantic.Field(alias="$nin")
    ]


SearchKnowledge1KnowledgeDollarInTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarInTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeDollarIn = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarIn", Union[str, float, bool]
)


class SearchKnowledge1DollarInTypedDict(TypedDict):
    r"""In"""

    dollar_in: List[SearchKnowledge1KnowledgeDollarInTypedDict]


class SearchKnowledge1DollarIn(BaseModel):
    r"""In"""

    dollar_in: Annotated[
        List[SearchKnowledge1KnowledgeDollarIn], pydantic.Field(alias="$in")
    ]


class SearchKnowledge1DollarLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    dollar_lte: float


class SearchKnowledge1DollarLte(BaseModel):
    r"""Less than or equal to"""

    dollar_lte: Annotated[float, pydantic.Field(alias="$lte")]


class SearchKnowledge1DollarLtTypedDict(TypedDict):
    r"""Less than"""

    dollar_lt: float


class SearchKnowledge1DollarLt(BaseModel):
    r"""Less than"""

    dollar_lt: Annotated[float, pydantic.Field(alias="$lt")]


class SearchKnowledge1DollarGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    dollar_gte: float


class SearchKnowledge1DollarGte(BaseModel):
    r"""Greater than or equal to"""

    dollar_gte: Annotated[float, pydantic.Field(alias="$gte")]


class SearchKnowledge13TypedDict(TypedDict):
    dollar_gt: float


class SearchKnowledge13(BaseModel):
    dollar_gt: Annotated[float, pydantic.Field(alias="$gt")]


SearchKnowledge1KnowledgeDollarNeTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarNeTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeDollarNe = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarNe", Union[str, float, bool]
)


class SearchKnowledge1DollarNeTypedDict(TypedDict):
    r"""Not equal to"""

    dollar_ne: SearchKnowledge1KnowledgeDollarNeTypedDict


class SearchKnowledge1DollarNe(BaseModel):
    r"""Not equal to"""

    dollar_ne: Annotated[SearchKnowledge1KnowledgeDollarNe, pydantic.Field(alias="$ne")]


SearchKnowledge1KnowledgeDollarEqTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarEqTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeDollarEq = TypeAliasType(
    "SearchKnowledge1KnowledgeDollarEq", Union[str, float, bool]
)


class SearchKnowledge1DollarEqTypedDict(TypedDict):
    r"""Equal to"""

    dollar_eq: SearchKnowledge1KnowledgeDollarEqTypedDict


class SearchKnowledge1DollarEq(BaseModel):
    r"""Equal to"""

    dollar_eq: Annotated[SearchKnowledge1KnowledgeDollarEq, pydantic.Field(alias="$eq")]


Filter1TypedDict = TypeAliasType(
    "Filter1TypedDict",
    Union[
        SearchKnowledge1DollarEqTypedDict,
        SearchKnowledge1DollarNeTypedDict,
        SearchKnowledge13TypedDict,
        SearchKnowledge1DollarGteTypedDict,
        SearchKnowledge1DollarLtTypedDict,
        SearchKnowledge1DollarLteTypedDict,
        SearchKnowledge1DollarInTypedDict,
        SearchKnowledge1DollarNinTypedDict,
        SearchKnowledge1DollarExistsTypedDict,
    ],
)


Filter1 = TypeAliasType(
    "Filter1",
    Union[
        SearchKnowledge1DollarEq,
        SearchKnowledge1DollarNe,
        SearchKnowledge13,
        SearchKnowledge1DollarGte,
        SearchKnowledge1DollarLt,
        SearchKnowledge1DollarLte,
        SearchKnowledge1DollarIn,
        SearchKnowledge1DollarNin,
        SearchKnowledge1DollarExists,
    ],
)


FilterTypedDict = TypeAliasType(
    "FilterTypedDict",
    Union[
        FilterDollarAndTypedDict, FilterDollarOrTypedDict, Dict[str, Filter1TypedDict]
    ],
)
r"""The filter to apply to the search"""


Filter = TypeAliasType(
    "Filter", Union[FilterDollarAnd, FilterDollarOr, Dict[str, Filter1]]
)
r"""The filter to apply to the search"""


class SearchOptionsTypedDict(TypedDict):
    r"""Additional search options"""

    include_vectors: NotRequired[bool]
    r"""Whether to include the vector in the chunk"""
    include_metadata: NotRequired[bool]
    r"""Whether to include the metadata in the chunk"""
    include_scores: NotRequired[bool]
    r"""Whether to include the scores in the chunk"""


class SearchOptions(BaseModel):
    r"""Additional search options"""

    include_vectors: Optional[bool] = None
    r"""Whether to include the vector in the chunk"""

    include_metadata: Optional[bool] = None
    r"""Whether to include the metadata in the chunk"""

    include_scores: Optional[bool] = None
    r"""Whether to include the scores in the chunk"""


class SearchKnowledgeRequestBodyTypedDict(TypedDict):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""
    top_k: NotRequired[int]
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`"""
    threshold: NotRequired[float]
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""
    filter_: NotRequired[FilterTypedDict]
    r"""The filter to apply to the search"""
    search_options: NotRequired[SearchOptionsTypedDict]
    r"""Additional search options"""


class SearchKnowledgeRequestBody(BaseModel):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""

    top_k: Optional[int] = None
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`"""

    threshold: Optional[float] = None
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""

    filter_: Annotated[Optional[Filter], pydantic.Field(alias="filter")] = None
    r"""The filter to apply to the search"""

    search_options: Optional[SearchOptions] = None
    r"""Additional search options"""


class SearchKnowledgeRequestTypedDict(TypedDict):
    knowledge_id: str
    r"""The unique identifier or key of the knowledge base"""
    request_body: NotRequired[SearchKnowledgeRequestBodyTypedDict]
    r"""A search request for chunks in a knowledge base"""


class SearchKnowledgeRequest(BaseModel):
    knowledge_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier or key of the knowledge base"""

    request_body: Annotated[
        Optional[SearchKnowledgeRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None
    r"""A search request for chunks in a knowledge base"""


class ScoresTypedDict(TypedDict):
    rerank_score: NotRequired[float]
    search_score: NotRequired[float]


class Scores(BaseModel):
    rerank_score: Optional[float] = None

    search_score: Optional[float] = None


class MatchesTypedDict(TypedDict):
    id: str
    text: str
    vector: NotRequired[List[float]]
    metadata: NotRequired[Dict[str, Any]]
    scores: NotRequired[ScoresTypedDict]


class Matches(BaseModel):
    id: str

    text: str

    vector: Optional[List[float]] = None

    metadata: Optional[Dict[str, Any]] = None

    scores: Optional[Scores] = None


class SearchKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Search knowledge base"""

    matches: List[MatchesTypedDict]


class SearchKnowledgeResponseBody(BaseModel):
    r"""Search knowledge base"""

    matches: List[Matches]
