"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .publiccontact import PublicContact, PublicContactTypedDict
from .publicidentity import PublicIdentity, PublicIdentityTypedDict
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, MultipartFormMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


CreateImageEditQuality = Literal[
    "auto",
    "high",
    "medium",
    "low",
    "standard",
]
r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""


CreateImageEditResponseFormat = Literal[
    "url",
    "b64_json",
]
r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""


class CreateImageEditFallbacksTypedDict(TypedDict):
    model: str
    r"""Fallback model identifier"""


class CreateImageEditFallbacks(BaseModel):
    model: str
    r"""Fallback model identifier"""


class CreateImageEditRetryTypedDict(TypedDict):
    r"""Retry configuration for the request"""

    count: NotRequired[float]
    r"""Number of retry attempts (1-5)"""
    on_codes: NotRequired[List[float]]
    r"""HTTP status codes that trigger retry logic"""


class CreateImageEditRetry(BaseModel):
    r"""Retry configuration for the request"""

    count: Optional[float] = 3
    r"""Number of retry attempts (1-5)"""

    on_codes: Optional[List[float]] = None
    r"""HTTP status codes that trigger retry logic"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageEditType = Literal["exact_match",]


class CreateImageEditCacheTypedDict(TypedDict):
    r"""Cache configuration for the request."""

    type: CreateImageEditType
    ttl: NotRequired[float]
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""


class CreateImageEditCache(BaseModel):
    r"""Cache configuration for the request."""

    type: CreateImageEditType

    ttl: Optional[float] = 1800
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageEditLoadBalancerType = Literal["weight_based",]


class CreateImageEditLoadBalancerModelsTypedDict(TypedDict):
    model: str
    r"""Model identifier for load balancing"""
    weight: NotRequired[float]
    r"""Weight assigned to this model for load balancing"""


class CreateImageEditLoadBalancerModels(BaseModel):
    model: str
    r"""Model identifier for load balancing"""

    weight: Optional[float] = 0.5
    r"""Weight assigned to this model for load balancing"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["weight"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditLoadBalancer1TypedDict(TypedDict):
    type: CreateImageEditLoadBalancerType
    models: List[CreateImageEditLoadBalancerModelsTypedDict]


class CreateImageEditLoadBalancer1(BaseModel):
    type: CreateImageEditLoadBalancerType

    models: List[CreateImageEditLoadBalancerModels]


CreateImageEditLoadBalancerTypedDict = CreateImageEditLoadBalancer1TypedDict
r"""Load balancer configuration for the request."""


CreateImageEditLoadBalancer = CreateImageEditLoadBalancer1
r"""Load balancer configuration for the request."""


class CreateImageEditTimeoutTypedDict(TypedDict):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditTimeout(BaseModel):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditRouterImagesEditsRetryTypedDict(TypedDict):
    r"""Retry configuration for the request"""

    count: NotRequired[float]
    r"""Number of retry attempts (1-5)"""
    on_codes: NotRequired[List[float]]
    r"""HTTP status codes that trigger retry logic"""


class CreateImageEditRouterImagesEditsRetry(BaseModel):
    r"""Retry configuration for the request"""

    count: Optional[float] = 3
    r"""Number of retry attempts (1-5)"""

    on_codes: Optional[List[float]] = None
    r"""HTTP status codes that trigger retry logic"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditRouterImagesEditsFallbacksTypedDict(TypedDict):
    model: str
    r"""Fallback model identifier"""


class CreateImageEditRouterImagesEditsFallbacks(BaseModel):
    model: str
    r"""Fallback model identifier"""


CreateImageEditVersion = Literal["latest",]
r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageEditPromptTypedDict(TypedDict):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""
    version: CreateImageEditVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageEditPrompt(BaseModel):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""

    version: CreateImageEditVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


CreateImageEditRouterImagesEditsType = Literal["exact_match",]


class CreateImageEditRouterImagesEditsCacheTypedDict(TypedDict):
    r"""Cache configuration for the request."""

    type: CreateImageEditRouterImagesEditsType
    ttl: NotRequired[float]
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""


class CreateImageEditRouterImagesEditsCache(BaseModel):
    r"""Cache configuration for the request."""

    type: CreateImageEditRouterImagesEditsType

    ttl: Optional[float] = 1800
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageEditLoadBalancerRouterImagesEditsType = Literal["weight_based",]


class CreateImageEditLoadBalancerRouterImagesEditsModelsTypedDict(TypedDict):
    model: str
    r"""Model identifier for load balancing"""
    weight: NotRequired[float]
    r"""Weight assigned to this model for load balancing"""


class CreateImageEditLoadBalancerRouterImagesEditsModels(BaseModel):
    model: str
    r"""Model identifier for load balancing"""

    weight: Optional[float] = 0.5
    r"""Weight assigned to this model for load balancing"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["weight"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditLoadBalancerRouterImagesEdits1TypedDict(TypedDict):
    type: CreateImageEditLoadBalancerRouterImagesEditsType
    models: List[CreateImageEditLoadBalancerRouterImagesEditsModelsTypedDict]


class CreateImageEditLoadBalancerRouterImagesEdits1(BaseModel):
    type: CreateImageEditLoadBalancerRouterImagesEditsType

    models: List[CreateImageEditLoadBalancerRouterImagesEditsModels]


CreateImageEditRouterImagesEditsLoadBalancerTypedDict = (
    CreateImageEditLoadBalancerRouterImagesEdits1TypedDict
)
r"""Array of models with weights for load balancing requests"""


CreateImageEditRouterImagesEditsLoadBalancer = (
    CreateImageEditLoadBalancerRouterImagesEdits1
)
r"""Array of models with weights for load balancing requests"""


class CreateImageEditRouterImagesEditsTimeoutTypedDict(TypedDict):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditRouterImagesEditsTimeout(BaseModel):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditOrqTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name to display on the trace. If not specified, the default system name will be used."""
    retry: NotRequired[CreateImageEditRouterImagesEditsRetryTypedDict]
    r"""Retry configuration for the request"""
    fallbacks: NotRequired[List[CreateImageEditRouterImagesEditsFallbacksTypedDict]]
    r"""Array of fallback models to use if primary model fails"""
    prompt: NotRequired[CreateImageEditPromptTypedDict]
    r"""Prompt configuration for the request"""
    identity: NotRequired[PublicIdentityTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[PublicContactTypedDict]
    r"""@deprecated Use identity instead. Information about the contact making the request."""
    cache: NotRequired[CreateImageEditRouterImagesEditsCacheTypedDict]
    r"""Cache configuration for the request."""
    load_balancer: NotRequired[CreateImageEditRouterImagesEditsLoadBalancerTypedDict]
    r"""Array of models with weights for load balancing requests"""
    timeout: NotRequired[CreateImageEditRouterImagesEditsTimeoutTypedDict]
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""


class CreateImageEditOrq(BaseModel):
    name: Optional[str] = None
    r"""The name to display on the trace. If not specified, the default system name will be used."""

    retry: Optional[CreateImageEditRouterImagesEditsRetry] = None
    r"""Retry configuration for the request"""

    fallbacks: Optional[List[CreateImageEditRouterImagesEditsFallbacks]] = None
    r"""Array of fallback models to use if primary model fails"""

    prompt: Optional[CreateImageEditPrompt] = None
    r"""Prompt configuration for the request"""

    identity: Optional[PublicIdentity] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Annotated[
        Optional[PublicContact],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    cache: Optional[CreateImageEditRouterImagesEditsCache] = None
    r"""Cache configuration for the request."""

    load_balancer: Optional[CreateImageEditRouterImagesEditsLoadBalancer] = None
    r"""Array of models with weights for load balancing requests"""

    timeout: Optional[CreateImageEditRouterImagesEditsTimeout] = None
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "name",
                "retry",
                "fallbacks",
                "prompt",
                "identity",
                "contact",
                "cache",
                "load_balancer",
                "timeout",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditRequestBodyTypedDict(TypedDict):
    model: str
    r"""The model to use for image edit. [Check models](https://docs.orq.ai/docs/ai-gateway-supported-models#image-models)"""
    prompt: str
    r"""A text description of the desired image(s)."""
    image: NotRequired[Any]
    r"""The image(s) to edit. Must be a supported image file or an array of images.  Each image should be a png, webp, or jpg file less than 50MB. You can provide up to 16 images."""
    n: NotRequired[Nullable[int]]
    r"""The number of images to generate. Must be between 1 and 10."""
    size: NotRequired[Nullable[str]]
    r"""The size of the generated images"""
    quality: NotRequired[Nullable[CreateImageEditQuality]]
    r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""
    response_format: NotRequired[CreateImageEditResponseFormat]
    r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""
    user: NotRequired[str]
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""
    name: NotRequired[str]
    r"""The name to display on the trace. If not specified, the default system name will be used."""
    fallbacks: NotRequired[List[CreateImageEditFallbacksTypedDict]]
    r"""Array of fallback models to use if primary model fails"""
    retry: NotRequired[CreateImageEditRetryTypedDict]
    r"""Retry configuration for the request"""
    cache: NotRequired[CreateImageEditCacheTypedDict]
    r"""Cache configuration for the request."""
    load_balancer: NotRequired[CreateImageEditLoadBalancerTypedDict]
    r"""Load balancer configuration for the request."""
    timeout: NotRequired[CreateImageEditTimeoutTypedDict]
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""
    orq: NotRequired[CreateImageEditOrqTypedDict]


class CreateImageEditRequestBody(BaseModel):
    model: Annotated[str, FieldMetadata(multipart=True)]
    r"""The model to use for image edit. [Check models](https://docs.orq.ai/docs/ai-gateway-supported-models#image-models)"""

    prompt: Annotated[str, FieldMetadata(multipart=True)]
    r"""A text description of the desired image(s)."""

    image: Annotated[Optional[Any], FieldMetadata(multipart=True)] = None
    r"""The image(s) to edit. Must be a supported image file or an array of images.  Each image should be a png, webp, or jpg file less than 50MB. You can provide up to 16 images."""

    n: Annotated[OptionalNullable[int], FieldMetadata(multipart=True)] = 1
    r"""The number of images to generate. Must be between 1 and 10."""

    size: Annotated[OptionalNullable[str], FieldMetadata(multipart=True)] = UNSET
    r"""The size of the generated images"""

    quality: Annotated[
        OptionalNullable[CreateImageEditQuality], FieldMetadata(multipart=True)
    ] = UNSET
    r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""

    response_format: Annotated[
        Optional[CreateImageEditResponseFormat], FieldMetadata(multipart=True)
    ] = None
    r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""

    user: Annotated[Optional[str], FieldMetadata(multipart=True)] = None
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""

    name: Annotated[Optional[str], FieldMetadata(multipart=True)] = None
    r"""The name to display on the trace. If not specified, the default system name will be used."""

    fallbacks: Annotated[
        Optional[List[CreateImageEditFallbacks]],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None
    r"""Array of fallback models to use if primary model fails"""

    retry: Annotated[
        Optional[CreateImageEditRetry],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None
    r"""Retry configuration for the request"""

    cache: Annotated[
        Optional[CreateImageEditCache],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None
    r"""Cache configuration for the request."""

    load_balancer: Annotated[
        Optional[CreateImageEditLoadBalancer],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None
    r"""Load balancer configuration for the request."""

    timeout: Annotated[
        Optional[CreateImageEditTimeout],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    orq: Annotated[
        Optional[CreateImageEditOrq],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "image",
                "n",
                "size",
                "quality",
                "response_format",
                "user",
                "name",
                "fallbacks",
                "retry",
                "cache",
                "load_balancer",
                "timeout",
                "orq",
            ]
        )
        nullable_fields = set(["n", "size", "quality"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateImageEditDataTypedDict(TypedDict):
    b64_json: NotRequired[str]
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""
    url: NotRequired[str]
    r"""The URL of the generated image, if response_format is url (default)"""


class CreateImageEditData(BaseModel):
    b64_json: Optional[str] = None
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""

    url: Optional[str] = None
    r"""The URL of the generated image, if response_format is url (default)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["b64_json", "url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditInputTokensDetailsTypedDict(TypedDict):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""
    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageEditInputTokensDetails(BaseModel):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""

    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageEditUsageTypedDict(TypedDict):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""
    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""
    output_tokens: float
    r"""The number of output tokens generated by the model."""
    input_tokens_details: CreateImageEditInputTokensDetailsTypedDict
    r"""The input tokens detailed information for the image generation."""


class CreateImageEditUsage(BaseModel):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""

    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""

    output_tokens: float
    r"""The number of output tokens generated by the model."""

    input_tokens_details: CreateImageEditInputTokensDetails
    r"""The input tokens detailed information for the image generation."""


class CreateImageEditResponseBodyTypedDict(TypedDict):
    r"""Represents an image edit response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""
    data: List[CreateImageEditDataTypedDict]
    r"""The list of generated images."""
    output_format: NotRequired[str]
    r"""The output format of the image generation"""
    size: NotRequired[str]
    r"""The size of the image generated"""
    quality: NotRequired[str]
    r"""The quality of the image generated"""
    usage: NotRequired[CreateImageEditUsageTypedDict]
    r"""The token usage information for the image generation."""


class CreateImageEditResponseBody(BaseModel):
    r"""Represents an image edit response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""

    data: List[CreateImageEditData]
    r"""The list of generated images."""

    output_format: Optional[str] = None
    r"""The output format of the image generation"""

    size: Optional[str] = None
    r"""The size of the image generated"""

    quality: Optional[str] = None
    r"""The quality of the image generated"""

    usage: Optional[CreateImageEditUsage] = None
    r"""The token usage information for the image generation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["output_format", "size", "quality", "usage"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
