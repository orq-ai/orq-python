"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .publiccontact import PublicContact, PublicContactTypedDict
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, MultipartFormMetadata
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict, deprecated


CreateImageEditQuality = Literal[
    "auto",
    "high",
    "medium",
    "low",
    "standard",
]
r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""


CreateImageEditResponseFormat = Literal[
    "url",
    "b64_json",
]
r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""


class CreateImageEditRetryTypedDict(TypedDict):
    r"""Retry configuration for the request"""

    count: NotRequired[float]
    r"""Number of retry attempts (1-5)"""
    on_codes: NotRequired[List[float]]
    r"""HTTP status codes that trigger retry logic"""


class CreateImageEditRetry(BaseModel):
    r"""Retry configuration for the request"""

    count: Optional[float] = 3
    r"""Number of retry attempts (1-5)"""

    on_codes: Optional[List[float]] = None
    r"""HTTP status codes that trigger retry logic"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditFallbacksTypedDict(TypedDict):
    model: str
    r"""Fallback model identifier"""


class CreateImageEditFallbacks(BaseModel):
    model: str
    r"""Fallback model identifier"""


CreateImageEditVersion = Literal["latest",]
r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageEditPromptTypedDict(TypedDict):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""
    version: CreateImageEditVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageEditPrompt(BaseModel):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""

    version: CreateImageEditVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageEditContactTypedDict(TypedDict):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageEditContact(BaseModel):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageEditType = Literal["exact_match",]


class CreateImageEditCacheTypedDict(TypedDict):
    r"""Cache configuration for the request."""

    type: CreateImageEditType
    ttl: NotRequired[float]
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""


class CreateImageEditCache(BaseModel):
    r"""Cache configuration for the request."""

    type: CreateImageEditType

    ttl: Optional[float] = 1800
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageEditLoadBalancerType = Literal["weight_based",]


class CreateImageEditLoadBalancerModelsTypedDict(TypedDict):
    model: str
    r"""Model identifier for load balancing"""
    weight: NotRequired[float]
    r"""Weight assigned to this model for load balancing"""


class CreateImageEditLoadBalancerModels(BaseModel):
    model: str
    r"""Model identifier for load balancing"""

    weight: Optional[float] = 0.5
    r"""Weight assigned to this model for load balancing"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["weight"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditLoadBalancer1TypedDict(TypedDict):
    type: CreateImageEditLoadBalancerType
    models: List[CreateImageEditLoadBalancerModelsTypedDict]


class CreateImageEditLoadBalancer1(BaseModel):
    type: CreateImageEditLoadBalancerType

    models: List[CreateImageEditLoadBalancerModels]


CreateImageEditLoadBalancerTypedDict = CreateImageEditLoadBalancer1TypedDict
r"""Array of models with weights for load balancing requests"""


CreateImageEditLoadBalancer = CreateImageEditLoadBalancer1
r"""Array of models with weights for load balancing requests"""


class CreateImageEditTimeoutTypedDict(TypedDict):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditTimeout(BaseModel):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageEditOrqTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name to display on the trace. If not specified, the default system name will be used."""
    retry: NotRequired[CreateImageEditRetryTypedDict]
    r"""Retry configuration for the request"""
    fallbacks: NotRequired[List[CreateImageEditFallbacksTypedDict]]
    r"""Array of fallback models to use if primary model fails"""
    prompt: NotRequired[CreateImageEditPromptTypedDict]
    r"""Prompt configuration for the request"""
    identity: NotRequired[PublicContactTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[CreateImageEditContactTypedDict]
    cache: NotRequired[CreateImageEditCacheTypedDict]
    r"""Cache configuration for the request."""
    load_balancer: NotRequired[CreateImageEditLoadBalancerTypedDict]
    r"""Array of models with weights for load balancing requests"""
    timeout: NotRequired[CreateImageEditTimeoutTypedDict]
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""


class CreateImageEditOrq(BaseModel):
    name: Optional[str] = None
    r"""The name to display on the trace. If not specified, the default system name will be used."""

    retry: Optional[CreateImageEditRetry] = None
    r"""Retry configuration for the request"""

    fallbacks: Optional[List[CreateImageEditFallbacks]] = None
    r"""Array of fallback models to use if primary model fails"""

    prompt: Optional[CreateImageEditPrompt] = None
    r"""Prompt configuration for the request"""

    identity: Optional[PublicContact] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Optional[CreateImageEditContact] = None

    cache: Optional[CreateImageEditCache] = None
    r"""Cache configuration for the request."""

    load_balancer: Optional[CreateImageEditLoadBalancer] = None
    r"""Array of models with weights for load balancing requests"""

    timeout: Optional[CreateImageEditTimeout] = None
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "name",
                "retry",
                "fallbacks",
                "prompt",
                "identity",
                "contact",
                "cache",
                "load_balancer",
                "timeout",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditRequestBodyTypedDict(TypedDict):
    model: str
    r"""The model to use for image edit. [Check models](https://docs.orq.ai/docs/ai-gateway-supported-models#image-models)"""
    prompt: str
    r"""A text description of the desired image(s)."""
    image: NotRequired[Any]
    r"""The image(s) to edit. Must be a supported image file or an array of images.  Each image should be a png, webp, or jpg file less than 50MB. You can provide up to 16 images."""
    n: NotRequired[Nullable[int]]
    r"""The number of images to generate. Must be between 1 and 10."""
    size: NotRequired[Nullable[str]]
    r"""The size of the generated images"""
    quality: NotRequired[Nullable[CreateImageEditQuality]]
    r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""
    response_format: NotRequired[CreateImageEditResponseFormat]
    r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""
    user: NotRequired[str]
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""
    orq: NotRequired[CreateImageEditOrqTypedDict]


class CreateImageEditRequestBody(BaseModel):
    model: Annotated[str, FieldMetadata(multipart=True)]
    r"""The model to use for image edit. [Check models](https://docs.orq.ai/docs/ai-gateway-supported-models#image-models)"""

    prompt: Annotated[str, FieldMetadata(multipart=True)]
    r"""A text description of the desired image(s)."""

    image: Annotated[Optional[Any], FieldMetadata(multipart=True)] = None
    r"""The image(s) to edit. Must be a supported image file or an array of images.  Each image should be a png, webp, or jpg file less than 50MB. You can provide up to 16 images."""

    n: Annotated[OptionalNullable[int], FieldMetadata(multipart=True)] = 1
    r"""The number of images to generate. Must be between 1 and 10."""

    size: Annotated[OptionalNullable[str], FieldMetadata(multipart=True)] = UNSET
    r"""The size of the generated images"""

    quality: Annotated[
        OptionalNullable[CreateImageEditQuality], FieldMetadata(multipart=True)
    ] = UNSET
    r"""The quality of the image that will be generated. Auto will automatically select the best quality for the given model."""

    response_format: Annotated[
        Optional[CreateImageEditResponseFormat], FieldMetadata(multipart=True)
    ] = None
    r"""The format in which the generated images are returned. Some of the models only return the image in base64 format."""

    user: Annotated[Optional[str], FieldMetadata(multipart=True)] = None
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""

    orq: Annotated[
        Optional[CreateImageEditOrq],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["image", "n", "size", "quality", "response_format", "user", "orq"]
        )
        nullable_fields = set(["n", "size", "quality"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateImageEditDataTypedDict(TypedDict):
    b64_json: NotRequired[str]
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""
    url: NotRequired[str]
    r"""The URL of the generated image, if response_format is url (default)"""


class CreateImageEditData(BaseModel):
    b64_json: Optional[str] = None
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""

    url: Optional[str] = None
    r"""The URL of the generated image, if response_format is url (default)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["b64_json", "url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageEditInputTokensDetailsTypedDict(TypedDict):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""
    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageEditInputTokensDetails(BaseModel):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""

    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageEditUsageTypedDict(TypedDict):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""
    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""
    output_tokens: float
    r"""The number of output tokens generated by the model."""
    input_tokens_details: CreateImageEditInputTokensDetailsTypedDict
    r"""The input tokens detailed information for the image generation."""


class CreateImageEditUsage(BaseModel):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""

    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""

    output_tokens: float
    r"""The number of output tokens generated by the model."""

    input_tokens_details: CreateImageEditInputTokensDetails
    r"""The input tokens detailed information for the image generation."""


class CreateImageEditResponseBodyTypedDict(TypedDict):
    r"""Represents an image edit response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""
    data: List[CreateImageEditDataTypedDict]
    r"""The list of generated images."""
    output_format: NotRequired[str]
    r"""The output format of the image generation"""
    size: NotRequired[str]
    r"""The size of the image generated"""
    quality: NotRequired[str]
    r"""The quality of the image generated"""
    usage: NotRequired[CreateImageEditUsageTypedDict]
    r"""The token usage information for the image generation."""


class CreateImageEditResponseBody(BaseModel):
    r"""Represents an image edit response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""

    data: List[CreateImageEditData]
    r"""The list of generated images."""

    output_format: Optional[str] = None
    r"""The output format of the image generation"""

    size: Optional[str] = None
    r"""The size of the image generated"""

    quality: Optional[str] = None
    r"""The quality of the image generated"""

    usage: Optional[CreateImageEditUsage] = None
    r"""The token usage information for the image generation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["output_format", "size", "quality", "usage"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
