"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import model_serializer
from typing import Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


UpdateKnowledgeRetrievalSettingsKnowledgeRequestType = Literal["hybrid_search"]

UpdateKnowledgeRetrievalSettingsKnowledgeRequestProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelType = Literal["rerank"]


class UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigInputTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeRequestProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelType]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelParametersTypedDict
    ]


class UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigInput(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeRequestProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelType] = (
        None
    )

    model_parameters: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeRequestModelParameters
    ] = None


class UpdateKnowledgeRetrievalSettings3TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeRequestType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigInputTypedDict]
    ]


class UpdateKnowledgeRetrievalSettings3(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeRequestType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigInput
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeRetrievalSettingsKnowledgeType = Literal["keyword_search"]

UpdateKnowledgeRetrievalSettingsKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsKnowledgeModelType = Literal["rerank"]


class UpdateKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsRerankConfigInputTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeModelType]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict
    ]


class UpdateKnowledgeRetrievalSettingsRerankConfigInput(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeModelType] = None

    model_parameters: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeModelParameters
    ] = None


class UpdateKnowledgeRetrievalSettings2TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[UpdateKnowledgeRetrievalSettingsRerankConfigInputTypedDict]
    ]


class UpdateKnowledgeRetrievalSettings2(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        UpdateKnowledgeRetrievalSettingsRerankConfigInput
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeRetrievalSettingsType = Literal["vector_search"]

UpdateKnowledgeRetrievalSettingsProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsModelType = Literal["rerank"]


class UpdateKnowledgeRetrievalSettingsModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[UpdateKnowledgeRetrievalSettingsProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[UpdateKnowledgeRetrievalSettingsModelType]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsModelParametersTypedDict
    ]


class UpdateKnowledgeRetrievalSettingsRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[UpdateKnowledgeRetrievalSettingsProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[UpdateKnowledgeRetrievalSettingsModelType] = None

    model_parameters: Optional[UpdateKnowledgeRetrievalSettingsModelParameters] = None


class UpdateKnowledgeRetrievalSettings1TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[UpdateKnowledgeRetrievalSettingsRerankConfigTypedDict]
    ]


class UpdateKnowledgeRetrievalSettings1(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[UpdateKnowledgeRetrievalSettingsRerankConfig] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeRetrievalSettingsTypedDict = TypeAliasType(
    "UpdateKnowledgeRetrievalSettingsTypedDict",
    Union[
        UpdateKnowledgeRetrievalSettings1TypedDict,
        UpdateKnowledgeRetrievalSettings2TypedDict,
        UpdateKnowledgeRetrievalSettings3TypedDict,
    ],
)


UpdateKnowledgeRetrievalSettings = TypeAliasType(
    "UpdateKnowledgeRetrievalSettings",
    Union[
        UpdateKnowledgeRetrievalSettings1,
        UpdateKnowledgeRetrievalSettings2,
        UpdateKnowledgeRetrievalSettings3,
    ],
)


class UpdateKnowledgeRequestBodyTypedDict(TypedDict):
    description: NotRequired[str]
    r"""The description of the knowledge base."""
    model: NotRequired[str]
    r"""The embeddings model used for the knowledge base. If the models is provided and is different than the previous set model, all the datasources in the knowledge base will be re-embedded."""
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    retrieval_settings: NotRequired[UpdateKnowledgeRetrievalSettingsTypedDict]


class UpdateKnowledgeRequestBody(BaseModel):
    description: Optional[str] = None
    r"""The description of the knowledge base."""

    model: Optional[str] = None
    r"""The embeddings model used for the knowledge base. If the models is provided and is different than the previous set model, all the datasources in the knowledge base will be re-embedded."""

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    retrieval_settings: Optional[UpdateKnowledgeRetrievalSettings] = None


class UpdateKnowledgeRequestTypedDict(TypedDict):
    knowledge_id: str
    r"""The unique identifier of the knowledge base"""
    request_body: UpdateKnowledgeRequestBodyTypedDict


class UpdateKnowledgeRequest(BaseModel):
    knowledge_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the knowledge base"""

    request_body: Annotated[
        UpdateKnowledgeRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


class UpdateKnowledgeMetadataTypedDict(TypedDict):
    word_count: NotRequired[int]
    document_count: NotRequired[int]
    sentences_count: NotRequired[int]


class UpdateKnowledgeMetadata(BaseModel):
    word_count: Optional[int] = 0

    document_count: Optional[int] = 0

    sentences_count: Optional[int] = 0


UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType = Literal[
    "hybrid_search"
]

UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType = Literal[
    "rerank"
]


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParameters(
    BaseModel
):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfigTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    provider: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider
    ]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType
    ]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONProvider
    ] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelType
    ] = None

    model_parameters: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateKnowledgeRetrievalSettingsKnowledge3TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[
            UpdateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfigTypedDict
        ]
    ]


class UpdateKnowledgeRetrievalSettingsKnowledge3(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ApplicationJSONType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200RerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Type = Literal["keyword_search"]

UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Provider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType = Literal["rerank"]


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Provider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType
    ]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Provider] = (
        None
    )

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelType
    ] = None

    model_parameters: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponse200ModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateKnowledgeRetrievalSettingsKnowledge2TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Type
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[UpdateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict]
    ]


class UpdateKnowledgeRetrievalSettingsKnowledge2(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponse200Type

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeRetrievalSettingsKnowledgeResponseType = Literal["vector_search"]

UpdateKnowledgeRetrievalSettingsKnowledgeResponseProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelType = Literal["rerank"]


class UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeResponseProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelType]
    model_parameters: NotRequired[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeResponseProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelType] = (
        None
    )

    model_parameters: Optional[
        UpdateKnowledgeRetrievalSettingsKnowledgeResponseModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UpdateKnowledgeRetrievalSettingsKnowledge1TypedDict(TypedDict):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponseType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict]
    ]


class UpdateKnowledgeRetrievalSettingsKnowledge1(BaseModel):
    type: UpdateKnowledgeRetrievalSettingsKnowledgeResponseType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        UpdateKnowledgeRetrievalSettingsKnowledgeRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UpdateKnowledgeKnowledgeRetrievalSettingsTypedDict = TypeAliasType(
    "UpdateKnowledgeKnowledgeRetrievalSettingsTypedDict",
    Union[
        UpdateKnowledgeRetrievalSettingsKnowledge1TypedDict,
        UpdateKnowledgeRetrievalSettingsKnowledge2TypedDict,
        UpdateKnowledgeRetrievalSettingsKnowledge3TypedDict,
    ],
)


UpdateKnowledgeKnowledgeRetrievalSettings = TypeAliasType(
    "UpdateKnowledgeKnowledgeRetrievalSettings",
    Union[
        UpdateKnowledgeRetrievalSettingsKnowledge1,
        UpdateKnowledgeRetrievalSettingsKnowledge2,
        UpdateKnowledgeRetrievalSettingsKnowledge3,
    ],
)


class UpdateKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Knowledge Base object"""

    id: str
    r"""The unique identifier of the knowledge base."""
    created_by_id: str
    r"""The id of the resource"""
    created: str
    r"""The creation date of the knowledge base."""
    key: str
    r"""The unique key of the knowledge base."""
    metadata: UpdateKnowledgeMetadataTypedDict
    model: str
    r"""The embeddings model used for the knowledge base."""
    retrieval_settings: UpdateKnowledgeKnowledgeRetrievalSettingsTypedDict
    update_by_id: str
    r"""The id of the resource"""
    updated: str
    r"""The last update date of the knowledge base."""
    description: NotRequired[str]
    r"""The description of the knowledge base."""
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""


class UpdateKnowledgeResponseBody(BaseModel):
    r"""Knowledge Base object"""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the knowledge base."""

    created_by_id: str
    r"""The id of the resource"""

    created: str
    r"""The creation date of the knowledge base."""

    key: str
    r"""The unique key of the knowledge base."""

    metadata: UpdateKnowledgeMetadata

    model: str
    r"""The embeddings model used for the knowledge base."""

    retrieval_settings: UpdateKnowledgeKnowledgeRetrievalSettings

    update_by_id: str
    r"""The id of the resource"""

    updated: str
    r"""The last update date of the knowledge base."""

    description: Optional[str] = None
    r"""The description of the knowledge base."""

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
