"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .partdeltaevent import PartDeltaEvent, PartDeltaEventTypedDict
from .partdoneevent import PartDoneEvent, PartDoneEventTypedDict
from .responsedoneevent import ResponseDoneEvent, ResponseDoneEventTypedDict
from .responsefailedevent import ResponseFailedEvent, ResponseFailedEventTypedDict
from .responsestartedevent import ResponseStartedEvent, ResponseStartedEventTypedDict
from .tooldoneevent import ToolDoneEvent, ToolDoneEventTypedDict
from .toolfailedevent import ToolFailedEvent, ToolFailedEventTypedDict
from .toolreviewdoneevent import ToolReviewDoneEvent, ToolReviewDoneEventTypedDict
from .toolreviewrequestedevent import (
    ToolReviewRequestedEvent,
    ToolReviewRequestedEventTypedDict,
)
from .toolstartedevent import ToolStartedEvent, ToolStartedEventTypedDict
from .usermessagerequest import UserMessageRequest, UserMessageRequestTypedDict
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CreateConversationResponseRequestBodyTypedDict(TypedDict):
    message: UserMessageRequestTypedDict
    r"""The user message to send to the model"""
    model: str
    r"""The model to use for generation in format provider/model_id (e.g., openai/gpt-4o)."""
    task_id: NotRequired[str]
    r"""Task ID for continuing a previous conversation turn"""
    stream: NotRequired[bool]
    r"""Whether to stream the response (default: true)"""


class CreateConversationResponseRequestBody(BaseModel):
    message: UserMessageRequest
    r"""The user message to send to the model"""

    model: str
    r"""The model to use for generation in format provider/model_id (e.g., openai/gpt-4o)."""

    task_id: Optional[str] = None
    r"""Task ID for continuing a previous conversation turn"""

    stream: Optional[bool] = True
    r"""Whether to stream the response (default: true)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["task_id", "stream"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateConversationResponseRequestTypedDict(TypedDict):
    conversation_id: str
    r"""The unique identifier of the conversation"""
    request_body: CreateConversationResponseRequestBodyTypedDict


class CreateConversationResponseRequest(BaseModel):
    conversation_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the conversation"""

    request_body: Annotated[
        CreateConversationResponseRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


CreateConversationResponseResponseStreamingEventType = Literal["part.done",]


CreateConversationResponsePartKind = Literal["reasoning",]
r"""Type discriminator indicating this is a reasoning part"""


class CreateConversationResponsePartReasoningPartTypedDict(TypedDict):
    r"""A message part containing reasoning or chain-of-thought content"""

    kind: CreateConversationResponsePartKind
    r"""Type discriminator indicating this is a reasoning part"""
    reasoning: str
    r"""The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking."""
    id: NotRequired[str]
    r"""Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys."""
    signature: NotRequired[str]
    r"""Optional cryptographic signature to verify the authenticity and integrity of the reasoning content"""


class CreateConversationResponsePartReasoningPart(BaseModel):
    r"""A message part containing reasoning or chain-of-thought content"""

    kind: CreateConversationResponsePartKind
    r"""Type discriminator indicating this is a reasoning part"""

    reasoning: str
    r"""The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking."""

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "reasoning_01khxca96y2stjzkf5htdd3yhw"
    )
    r"""Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys."""

    signature: Optional[str] = None
    r"""Optional cryptographic signature to verify the authenticity and integrity of the reasoning content"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["_id", "metadata", "signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateConversationResponseResponseStreamingEventDataTypedDict(TypedDict):
    part_id: str
    r"""Unique identifier for this part. Matches the partId from part.delta events."""
    part: Any


class CreateConversationResponseResponseStreamingEventData(BaseModel):
    part_id: Annotated[str, pydantic.Field(alias="partId")]
    r"""Unique identifier for this part. Matches the partId from part.delta events."""

    part: Any


class ResponseStreamingEventPartDoneEventTypedDict(TypedDict):
    r"""Emitted when a part has been fully streamed. Contains the complete part with all content."""

    type: CreateConversationResponseResponseStreamingEventType
    timestamp: str
    r"""ISO timestamp of when the event occurred"""
    data: CreateConversationResponseResponseStreamingEventDataTypedDict


class ResponseStreamingEventPartDoneEvent(BaseModel):
    r"""Emitted when a part has been fully streamed. Contains the complete part with all content."""

    type: CreateConversationResponseResponseStreamingEventType

    timestamp: str
    r"""ISO timestamp of when the event occurred"""

    data: CreateConversationResponseResponseStreamingEventData


ResponseStreamingEventType = Literal["part.delta",]


DeltaKind = Literal["reasoning",]
r"""Type discriminator indicating this is a reasoning part"""


class DeltaReasoningPartTypedDict(TypedDict):
    r"""A message part containing reasoning or chain-of-thought content"""

    kind: DeltaKind
    r"""Type discriminator indicating this is a reasoning part"""
    reasoning: str
    r"""The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking."""
    id: NotRequired[str]
    r"""Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys."""
    signature: NotRequired[str]
    r"""Optional cryptographic signature to verify the authenticity and integrity of the reasoning content"""


class DeltaReasoningPart(BaseModel):
    r"""A message part containing reasoning or chain-of-thought content"""

    kind: DeltaKind
    r"""Type discriminator indicating this is a reasoning part"""

    reasoning: str
    r"""The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking."""

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "reasoning_01khxca96t516wdtrat89p5cck"
    )
    r"""Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys."""

    signature: Optional[str] = None
    r"""Optional cryptographic signature to verify the authenticity and integrity of the reasoning content"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["_id", "metadata", "signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseStreamingEventDataTypedDict(TypedDict):
    part_id: str
    r"""Unique identifier for this part. Format: {kind}_{ulid}. Use to correlate with part.done event."""
    delta: Any


class ResponseStreamingEventData(BaseModel):
    part_id: Annotated[str, pydantic.Field(alias="partId")]
    r"""Unique identifier for this part. Format: {kind}_{ulid}. Use to correlate with part.done event."""

    delta: Any


class ResponseStreamingEventPartDeltaEventTypedDict(TypedDict):
    r"""Emitted for each content chunk streamed from the LLM. The delta field contains a discriminated union based on the kind field."""

    type: ResponseStreamingEventType
    timestamp: str
    r"""ISO timestamp of when the event occurred"""
    data: ResponseStreamingEventDataTypedDict


class ResponseStreamingEventPartDeltaEvent(BaseModel):
    r"""Emitted for each content chunk streamed from the LLM. The delta field contains a discriminated union based on the kind field."""

    type: ResponseStreamingEventType

    timestamp: str
    r"""ISO timestamp of when the event occurred"""

    data: ResponseStreamingEventData


CreateConversationResponseResponseStreamingEventTypedDict = TypeAliasType(
    "CreateConversationResponseResponseStreamingEventTypedDict",
    Union[
        ResponseStartedEventTypedDict,
        ResponseDoneEventTypedDict,
        ResponseFailedEventTypedDict,
        ToolStartedEventTypedDict,
        ToolDoneEventTypedDict,
        ToolFailedEventTypedDict,
        ToolReviewRequestedEventTypedDict,
        ToolReviewDoneEventTypedDict,
        PartDeltaEventTypedDict,
        PartDoneEventTypedDict,
        ResponseStartedEventTypedDict,
        ResponseDoneEventTypedDict,
        ResponseFailedEventTypedDict,
        ToolStartedEventTypedDict,
        ToolDoneEventTypedDict,
        ToolFailedEventTypedDict,
        ToolReviewRequestedEventTypedDict,
        ToolReviewDoneEventTypedDict,
        ResponseStreamingEventPartDeltaEventTypedDict,
        ResponseStreamingEventPartDoneEventTypedDict,
    ],
)
r"""Union of all possible streaming events. Each event has a type field for discrimination."""


CreateConversationResponseResponseStreamingEvent = Annotated[
    Union[
        Annotated[ResponseStartedEvent, Tag("response.started")],
        Annotated[ResponseDoneEvent, Tag("response.done")],
        Annotated[ResponseFailedEvent, Tag("response.failed")],
        Annotated[ToolStartedEvent, Tag("tool.started")],
        Annotated[ToolDoneEvent, Tag("tool.done")],
        Annotated[ToolFailedEvent, Tag("tool.failed")],
        Annotated[ToolReviewRequestedEvent, Tag("tool.review.requested")],
        Annotated[ToolReviewDoneEvent, Tag("tool.review.done")],
        Annotated[PartDeltaEvent, Tag("part.delta")],
        Annotated[PartDoneEvent, Tag("part.done")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""Union of all possible streaming events. Each event has a type field for discrimination."""


class CreateConversationResponseResponseBodyTypedDict(TypedDict):
    r"""Response successfully created."""

    data: NotRequired[CreateConversationResponseResponseStreamingEventTypedDict]


class CreateConversationResponseResponseBody(BaseModel):
    r"""Response successfully created."""

    data: Optional[CreateConversationResponseResponseStreamingEvent] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["data"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    CreateConversationResponsePartReasoningPart.model_rebuild()
except NameError:
    pass
try:
    CreateConversationResponseResponseStreamingEventData.model_rebuild()
except NameError:
    pass
try:
    DeltaReasoningPart.model_rebuild()
except NameError:
    pass
try:
    ResponseStreamingEventData.model_rebuild()
except NameError:
    pass
