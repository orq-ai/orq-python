"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, QueryParamMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ListKnowledgeBasesRequestTypedDict(TypedDict):
    limit: NotRequired[float]
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""
    starting_after: NotRequired[str]
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""
    ending_before: NotRequired[str]
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""


class ListKnowledgeBasesRequest(BaseModel):
    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""

    starting_after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""

    ending_before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""


ListKnowledgeBasesObject = Literal["list"]


class ListKnowledgeBasesMetadataTypedDict(TypedDict):
    word_count: NotRequired[int]
    document_count: NotRequired[int]
    sentences_count: NotRequired[int]


class ListKnowledgeBasesMetadata(BaseModel):
    word_count: Optional[int] = 0

    document_count: Optional[int] = 0

    sentences_count: Optional[int] = 0


ListKnowledgeBasesRetrievalSettingsKnowledgeType = Literal["hybrid_search"]

ListKnowledgeBasesRetrievalSettingsKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

ListKnowledgeBasesRetrievalSettingsKnowledgeModelType = Literal["rerank"]


class ListKnowledgeBasesRetrievalSettingsKnowledgeModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[ListKnowledgeBasesRetrievalSettingsKnowledgeProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[ListKnowledgeBasesRetrievalSettingsKnowledgeModelType]
    model_parameters: NotRequired[
        ListKnowledgeBasesRetrievalSettingsKnowledgeModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class ListKnowledgeBasesRetrievalSettingsRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[ListKnowledgeBasesRetrievalSettingsKnowledgeProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[ListKnowledgeBasesRetrievalSettingsKnowledgeModelType] = None

    model_parameters: Optional[
        ListKnowledgeBasesRetrievalSettingsKnowledgeModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ListKnowledgeBasesRetrievalSettings3TypedDict(TypedDict):
    type: ListKnowledgeBasesRetrievalSettingsKnowledgeType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[ListKnowledgeBasesRetrievalSettingsRerankConfigTypedDict]
    ]


class ListKnowledgeBasesRetrievalSettings3(BaseModel):
    type: ListKnowledgeBasesRetrievalSettingsKnowledgeType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[ListKnowledgeBasesRetrievalSettingsRerankConfig] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListKnowledgeBasesRetrievalSettingsType = Literal["keyword_search"]

ListKnowledgeBasesRetrievalSettingsProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

ListKnowledgeBasesRetrievalSettingsModelType = Literal["rerank"]


class ListKnowledgeBasesRetrievalSettingsModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeResponseRerankConfigTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    provider: NotRequired[ListKnowledgeBasesRetrievalSettingsProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[ListKnowledgeBasesRetrievalSettingsModelType]
    model_parameters: NotRequired[
        ListKnowledgeBasesRetrievalSettingsModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeResponseRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[ListKnowledgeBasesRetrievalSettingsProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[ListKnowledgeBasesRetrievalSettingsModelType] = None

    model_parameters: Optional[ListKnowledgeBasesRetrievalSettingsModelParameters] = (
        None
    )

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ListKnowledgeBasesRetrievalSettings2TypedDict(TypedDict):
    type: ListKnowledgeBasesRetrievalSettingsType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[
            ListKnowledgeBasesRetrievalSettingsKnowledgeResponseRerankConfigTypedDict
        ]
    ]


class ListKnowledgeBasesRetrievalSettings2(BaseModel):
    type: ListKnowledgeBasesRetrievalSettingsType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        ListKnowledgeBasesRetrievalSettingsKnowledgeResponseRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListKnowledgeBasesRetrievalSettingsKnowledgeResponseType = Literal["vector_search"]

ListKnowledgeBasesRetrievalSettingsKnowledgeResponseProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelType = Literal["rerank"]


class ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[ListKnowledgeBasesRetrievalSettingsKnowledgeResponseProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[
        ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelType
    ]
    model_parameters: NotRequired[
        ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class ListKnowledgeBasesRetrievalSettingsKnowledgeRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[ListKnowledgeBasesRetrievalSettingsKnowledgeResponseProvider] = (
        None
    )

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[
        ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelType
    ] = None

    model_parameters: Optional[
        ListKnowledgeBasesRetrievalSettingsKnowledgeResponseModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ListKnowledgeBasesRetrievalSettings1TypedDict(TypedDict):
    type: ListKnowledgeBasesRetrievalSettingsKnowledgeResponseType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[ListKnowledgeBasesRetrievalSettingsKnowledgeRerankConfigTypedDict]
    ]


class ListKnowledgeBasesRetrievalSettings1(BaseModel):
    type: ListKnowledgeBasesRetrievalSettingsKnowledgeResponseType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        ListKnowledgeBasesRetrievalSettingsKnowledgeRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListKnowledgeBasesRetrievalSettingsTypedDict = TypeAliasType(
    "ListKnowledgeBasesRetrievalSettingsTypedDict",
    Union[
        ListKnowledgeBasesRetrievalSettings1TypedDict,
        ListKnowledgeBasesRetrievalSettings2TypedDict,
        ListKnowledgeBasesRetrievalSettings3TypedDict,
    ],
)


ListKnowledgeBasesRetrievalSettings = TypeAliasType(
    "ListKnowledgeBasesRetrievalSettings",
    Union[
        ListKnowledgeBasesRetrievalSettings1,
        ListKnowledgeBasesRetrievalSettings2,
        ListKnowledgeBasesRetrievalSettings3,
    ],
)


class ListKnowledgeBasesDataTypedDict(TypedDict):
    r"""Knowledge Base object"""

    id: str
    r"""The unique identifier of the knowledge base."""
    created_by_id: str
    r"""The id of the resource"""
    created: str
    r"""The creation date of the knowledge base."""
    key: str
    r"""The unique key of the knowledge base."""
    metadata: ListKnowledgeBasesMetadataTypedDict
    model: str
    r"""The embeddings model used for the knowledge base."""
    retrieval_settings: ListKnowledgeBasesRetrievalSettingsTypedDict
    update_by_id: str
    r"""The id of the resource"""
    updated: str
    r"""The last update date of the knowledge base."""
    description: NotRequired[str]
    r"""The description of the knowledge base."""
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""


class ListKnowledgeBasesData(BaseModel):
    r"""Knowledge Base object"""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the knowledge base."""

    created_by_id: str
    r"""The id of the resource"""

    created: str
    r"""The creation date of the knowledge base."""

    key: str
    r"""The unique key of the knowledge base."""

    metadata: ListKnowledgeBasesMetadata

    model: str
    r"""The embeddings model used for the knowledge base."""

    retrieval_settings: ListKnowledgeBasesRetrievalSettings

    update_by_id: str
    r"""The id of the resource"""

    updated: str
    r"""The last update date of the knowledge base."""

    description: Optional[str] = None
    r"""The description of the knowledge base."""

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""


class ListKnowledgeBasesResponseBodyTypedDict(TypedDict):
    r"""Knowledge bases retrieved"""

    object: ListKnowledgeBasesObject
    data: List[ListKnowledgeBasesDataTypedDict]
    has_more: bool


class ListKnowledgeBasesResponseBody(BaseModel):
    r"""Knowledge bases retrieved"""

    object: ListKnowledgeBasesObject

    data: List[ListKnowledgeBasesData]

    has_more: bool
