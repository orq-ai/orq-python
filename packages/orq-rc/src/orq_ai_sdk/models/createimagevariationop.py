"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .publiccontact import PublicContact, PublicContactTypedDict
from orq_ai_sdk.types import BaseModel, Nullable, OptionalNullable, UNSET_SENTINEL
from orq_ai_sdk.utils import FieldMetadata, MultipartFormMetadata
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict, deprecated


CreateImageVariationResponseFormat = Literal[
    "url",
    "b64_json",
]
r"""The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."""


Size = Literal[
    "256x256",
    "512x512",
    "1024x1024",
]
r"""The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."""


class CreateImageVariationRetryTypedDict(TypedDict):
    r"""Retry configuration for the request"""

    count: NotRequired[float]
    r"""Number of retry attempts (1-5)"""
    on_codes: NotRequired[List[float]]
    r"""HTTP status codes that trigger retry logic"""


class CreateImageVariationRetry(BaseModel):
    r"""Retry configuration for the request"""

    count: Optional[float] = 3
    r"""Number of retry attempts (1-5)"""

    on_codes: Optional[List[float]] = None
    r"""HTTP status codes that trigger retry logic"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "on_codes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageVariationFallbacksTypedDict(TypedDict):
    model: str
    r"""Fallback model identifier"""


class CreateImageVariationFallbacks(BaseModel):
    model: str
    r"""Fallback model identifier"""


CreateImageVariationVersion = Literal["latest",]
r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageVariationPromptTypedDict(TypedDict):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""
    version: CreateImageVariationVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


class CreateImageVariationPrompt(BaseModel):
    r"""Prompt configuration for the request"""

    id: str
    r"""Unique identifier of the prompt to use"""

    version: CreateImageVariationVersion
    r"""Version of the prompt to use (currently only \"latest\" supported)"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageVariationContactTypedDict(TypedDict):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class CreateImageVariationContact(BaseModel):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageVariationType = Literal["exact_match",]


class CreateImageVariationCacheTypedDict(TypedDict):
    r"""Cache configuration for the request."""

    type: CreateImageVariationType
    ttl: NotRequired[float]
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""


class CreateImageVariationCache(BaseModel):
    r"""Cache configuration for the request."""

    type: CreateImageVariationType

    ttl: Optional[float] = 1800
    r"""Time to live for cached responses in seconds. Maximum 259200 seconds (3 days)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageVariationLoadBalancerType = Literal["weight_based",]


class CreateImageVariationLoadBalancer1TypedDict(TypedDict):
    type: CreateImageVariationLoadBalancerType
    model: str
    r"""Model identifier for load balancing"""
    weight: NotRequired[float]
    r"""Weight assigned to this model for load balancing"""


class CreateImageVariationLoadBalancer1(BaseModel):
    type: CreateImageVariationLoadBalancerType

    model: str
    r"""Model identifier for load balancing"""

    weight: Optional[float] = 0.5
    r"""Weight assigned to this model for load balancing"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["weight"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateImageVariationLoadBalancerTypedDict = CreateImageVariationLoadBalancer1TypedDict


CreateImageVariationLoadBalancer = CreateImageVariationLoadBalancer1


class CreateImageVariationTimeoutTypedDict(TypedDict):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageVariationTimeout(BaseModel):
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    call_timeout: float
    r"""Timeout value in milliseconds"""


class CreateImageVariationOrqTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name to display on the trace. If not specified, the default system name will be used."""
    retry: NotRequired[CreateImageVariationRetryTypedDict]
    r"""Retry configuration for the request"""
    fallbacks: NotRequired[List[CreateImageVariationFallbacksTypedDict]]
    r"""Array of fallback models to use if primary model fails"""
    prompt: NotRequired[CreateImageVariationPromptTypedDict]
    r"""Prompt configuration for the request"""
    identity: NotRequired[PublicContactTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[CreateImageVariationContactTypedDict]
    cache: NotRequired[CreateImageVariationCacheTypedDict]
    r"""Cache configuration for the request."""
    load_balancer: NotRequired[List[CreateImageVariationLoadBalancerTypedDict]]
    r"""Array of models with weights for load balancing requests"""
    timeout: NotRequired[CreateImageVariationTimeoutTypedDict]
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""


class CreateImageVariationOrq(BaseModel):
    name: Optional[str] = None
    r"""The name to display on the trace. If not specified, the default system name will be used."""

    retry: Optional[CreateImageVariationRetry] = None
    r"""Retry configuration for the request"""

    fallbacks: Optional[List[CreateImageVariationFallbacks]] = None
    r"""Array of fallback models to use if primary model fails"""

    prompt: Optional[CreateImageVariationPrompt] = None
    r"""Prompt configuration for the request"""

    identity: Optional[PublicContact] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Optional[CreateImageVariationContact] = None

    cache: Optional[CreateImageVariationCache] = None
    r"""Cache configuration for the request."""

    load_balancer: Optional[List[CreateImageVariationLoadBalancer]] = None
    r"""Array of models with weights for load balancing requests"""

    timeout: Optional[CreateImageVariationTimeout] = None
    r"""Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "name",
                "retry",
                "fallbacks",
                "prompt",
                "identity",
                "contact",
                "cache",
                "load_balancer",
                "timeout",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageVariationRequestBodyTypedDict(TypedDict):
    r"""input"""

    model: str
    r"""The model to use for image generation."""
    image: NotRequired[Any]
    r"""The image to edit. Must be a supported image file. It should be a png, webp, or jpg file less than 50MB."""
    n: NotRequired[Nullable[int]]
    r"""The number of images to generate. Must be between 1 and 10."""
    response_format: NotRequired[CreateImageVariationResponseFormat]
    r"""The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."""
    size: NotRequired[Size]
    r"""The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."""
    user: NotRequired[str]
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""
    orq: NotRequired[CreateImageVariationOrqTypedDict]


class CreateImageVariationRequestBody(BaseModel):
    r"""input"""

    model: Annotated[str, FieldMetadata(multipart=True)]
    r"""The model to use for image generation."""

    image: Annotated[Optional[Any], FieldMetadata(multipart=True)] = None
    r"""The image to edit. Must be a supported image file. It should be a png, webp, or jpg file less than 50MB."""

    n: Annotated[OptionalNullable[int], FieldMetadata(multipart=True)] = 1
    r"""The number of images to generate. Must be between 1 and 10."""

    response_format: Annotated[
        Optional[CreateImageVariationResponseFormat], FieldMetadata(multipart=True)
    ] = "url"
    r"""The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."""

    size: Annotated[Optional[Size], FieldMetadata(multipart=True)] = "1024x1024"
    r"""The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."""

    user: Annotated[Optional[str], FieldMetadata(multipart=True)] = None
    r"""A unique identifier representing your end-user, which can help to monitor and detect abuse."""

    orq: Annotated[
        Optional[CreateImageVariationOrq],
        FieldMetadata(multipart=MultipartFormMetadata(json=True)),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["image", "n", "response_format", "size", "user", "orq"])
        nullable_fields = set(["n"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CreateImageVariationDataTypedDict(TypedDict):
    b64_json: NotRequired[str]
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""
    url: NotRequired[str]
    r"""The URL of the generated image, if response_format is url (default)"""


class CreateImageVariationData(BaseModel):
    b64_json: Optional[str] = None
    r"""The base64-encoded JSON of the generated image, if response_format is b64_json"""

    url: Optional[str] = None
    r"""The URL of the generated image, if response_format is url (default)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["b64_json", "url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateImageVariationInputTokensDetailsTypedDict(TypedDict):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""
    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageVariationInputTokensDetails(BaseModel):
    r"""The input tokens detailed information for the image generation."""

    text_tokens: float
    r"""The number of text tokens in the input prompt."""

    image_tokens: float
    r"""The number of image tokens in the input prompt."""


class CreateImageVariationUsageTypedDict(TypedDict):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""
    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""
    output_tokens: float
    r"""The number of output tokens generated by the model."""
    input_tokens_details: CreateImageVariationInputTokensDetailsTypedDict
    r"""The input tokens detailed information for the image generation."""


class CreateImageVariationUsage(BaseModel):
    r"""The token usage information for the image generation."""

    total_tokens: float
    r"""The total number of tokens (images and text) used for the image generation."""

    input_tokens: float
    r"""The number of tokens (images and text) in the input prompt."""

    output_tokens: float
    r"""The number of output tokens generated by the model."""

    input_tokens_details: CreateImageVariationInputTokensDetails
    r"""The input tokens detailed information for the image generation."""


class CreateImageVariationResponseBodyTypedDict(TypedDict):
    r"""Represents an image variation response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""
    data: List[CreateImageVariationDataTypedDict]
    r"""The list of generated images."""
    output_format: NotRequired[str]
    r"""The output format of the image generation"""
    size: NotRequired[str]
    r"""The size of the image generated"""
    quality: NotRequired[str]
    r"""The quality of the image generated"""
    usage: NotRequired[CreateImageVariationUsageTypedDict]
    r"""The token usage information for the image generation."""


class CreateImageVariationResponseBody(BaseModel):
    r"""Represents an image variation response from the API."""

    created: float
    r"""The Unix timestamp (in seconds) of when the image was created."""

    data: List[CreateImageVariationData]
    r"""The list of generated images."""

    output_format: Optional[str] = None
    r"""The output format of the image generation"""

    size: Optional[str] = None
    r"""The size of the image generated"""

    quality: Optional[str] = None
    r"""The quality of the image generated"""

    usage: Optional[CreateImageVariationUsage] = None
    r"""The token usage information for the image generation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["output_format", "size", "quality", "usage"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
