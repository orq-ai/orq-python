"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel
import pydantic
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


StreamRunAgentRole2 = Literal["tool",]


StreamRunAgentRole1 = Literal["user",]


StreamRunAgentRoleTypedDict = TypeAliasType(
    "StreamRunAgentRoleTypedDict", Union[StreamRunAgentRole1, StreamRunAgentRole2]
)
r"""Message role (user or tool for continuing executions)"""


StreamRunAgentRole = TypeAliasType(
    "StreamRunAgentRole", Union[StreamRunAgentRole1, StreamRunAgentRole2]
)
r"""Message role (user or tool for continuing executions)"""


StreamRunAgentPublicMessagePartAgentsRequestKind = Literal["tool_result",]


class PublicMessagePartToolResultPartTypedDict(TypedDict):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: StreamRunAgentPublicMessagePartAgentsRequestKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartToolResultPart(BaseModel):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: StreamRunAgentPublicMessagePartAgentsRequestKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


StreamRunAgentPublicMessagePartAgentsKind = Literal["file",]


class StreamRunAgentFile2TypedDict(TypedDict):
    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class StreamRunAgentFile2(BaseModel):
    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class StreamRunAgentFile1TypedDict(TypedDict):
    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class StreamRunAgentFile1(BaseModel):
    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


StreamRunAgentPublicMessagePartFileTypedDict = TypeAliasType(
    "StreamRunAgentPublicMessagePartFileTypedDict",
    Union[StreamRunAgentFile1TypedDict, StreamRunAgentFile2TypedDict],
)


StreamRunAgentPublicMessagePartFile = TypeAliasType(
    "StreamRunAgentPublicMessagePartFile",
    Union[StreamRunAgentFile1, StreamRunAgentFile2],
)


class PublicMessagePartFilePartTypedDict(TypedDict):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: StreamRunAgentPublicMessagePartAgentsKind
    file: StreamRunAgentPublicMessagePartFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartFilePart(BaseModel):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: StreamRunAgentPublicMessagePartAgentsKind

    file: StreamRunAgentPublicMessagePartFile

    metadata: Optional[Dict[str, Any]] = None


StreamRunAgentPublicMessagePartKind = Literal["text",]


class PublicMessagePartTextPartTypedDict(TypedDict):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: StreamRunAgentPublicMessagePartKind
    text: str


class PublicMessagePartTextPart(BaseModel):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: StreamRunAgentPublicMessagePartKind

    text: str


StreamRunAgentPublicMessagePartTypedDict = TypeAliasType(
    "StreamRunAgentPublicMessagePartTypedDict",
    Union[
        PublicMessagePartTextPartTypedDict,
        PublicMessagePartFilePartTypedDict,
        PublicMessagePartToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


StreamRunAgentPublicMessagePart = TypeAliasType(
    "StreamRunAgentPublicMessagePart",
    Union[
        PublicMessagePartTextPart,
        PublicMessagePartFilePart,
        PublicMessagePartToolResultPart,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class StreamRunAgentMessageTypedDict(TypedDict):
    r"""The A2A format message containing the task for the agent to perform."""

    role: StreamRunAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[StreamRunAgentPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class StreamRunAgentMessage(BaseModel):
    r"""The A2A format message containing the task for the agent to perform."""

    role: StreamRunAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[StreamRunAgentPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""


class StreamRunAgentContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class StreamRunAgentContact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class StreamRunAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class StreamRunAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class StreamRunAgentMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class StreamRunAgentMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


StreamRunAgentConfigurationAgentsType = Literal["query",]


class StreamRunAgentConfiguration2TypedDict(TypedDict):
    type: StreamRunAgentConfigurationAgentsType
    query: str


class StreamRunAgentConfiguration2(BaseModel):
    type: StreamRunAgentConfigurationAgentsType

    query: str


StreamRunAgentConfigurationType = Literal["last_user_message",]


class StreamRunAgentConfiguration1TypedDict(TypedDict):
    type: StreamRunAgentConfigurationType


class StreamRunAgentConfiguration1(BaseModel):
    type: StreamRunAgentConfigurationType


StreamRunAgentConfigurationTypedDict = TypeAliasType(
    "StreamRunAgentConfigurationTypedDict",
    Union[StreamRunAgentConfiguration1TypedDict, StreamRunAgentConfiguration2TypedDict],
)
r"""Defines the configuration settings which can either be for a user message or a text entry."""


StreamRunAgentConfiguration = TypeAliasType(
    "StreamRunAgentConfiguration",
    Union[StreamRunAgentConfiguration1, StreamRunAgentConfiguration2],
)
r"""Defines the configuration settings which can either be for a user message or a text entry."""


class StreamRunAgentKnowledgeBasesTypedDict(TypedDict):
    configuration: StreamRunAgentConfigurationTypedDict
    r"""Defines the configuration settings which can either be for a user message or a text entry."""


class StreamRunAgentKnowledgeBases(BaseModel):
    configuration: StreamRunAgentConfiguration
    r"""Defines the configuration settings which can either be for a user message or a text entry."""


class StreamRunAgentTeamOfAgentsTypedDict(TypedDict):
    id: str
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class StreamRunAgentTeamOfAgents(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools13Type = Literal[
    "function",
]


class StreamRunAgentRunAgentRequestToolFunctionTypedDict(TypedDict):
    name: str
    description: NotRequired[str]
    strict: NotRequired[bool]
    parameters: NotRequired[Dict[str, Any]]


class StreamRunAgentRunAgentRequestToolFunction(BaseModel):
    name: str

    description: Optional[str] = None

    strict: Optional[bool] = None

    parameters: Optional[Dict[str, Any]] = None


class RunAgentRequestToolFunctionToolTypedDict(TypedDict):
    r"""Custom function tool with configurable parameters"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools13Type
    key: str
    function: StreamRunAgentRunAgentRequestToolFunctionTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    description: NotRequired[str]
    requires_approval: NotRequired[bool]


class RunAgentRequestToolFunctionTool(BaseModel):
    r"""Custom function tool with configurable parameters"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools13Type

    key: str

    function: StreamRunAgentRunAgentRequestToolFunction

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    display_name: Optional[str] = None

    description: Optional[str] = None

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools12Type = Literal[
    "code",
]


RunAgentRequestToolLanguage = Literal["python",]


class RunAgentRequestToolCodeToolTypedDict(TypedDict):
    language: RunAgentRequestToolLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[Dict[str, Any]]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class RunAgentRequestToolCodeTool(BaseModel):
    language: RunAgentRequestToolLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[Dict[str, Any]] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class RunAgentRequestToolCodeExecutionToolTypedDict(TypedDict):
    r"""Executes code in a secure sandbox environment"""

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools12Type
    code_tool: RunAgentRequestToolCodeToolTypedDict
    id: NotRequired[str]
    requires_approval: NotRequired[bool]


class RunAgentRequestToolCodeExecutionTool(BaseModel):
    r"""Executes code in a secure sandbox environment"""

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools12Type

    code_tool: RunAgentRequestToolCodeTool

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11Type = Literal[
    "http",
]


RunAgentRequestToolMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class RunAgentRequestToolBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: RunAgentRequestToolMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, str]]
    r"""The headers to send with the request."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class RunAgentRequestToolBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: RunAgentRequestToolMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, str]] = None
    r"""The headers to send with the request."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11HTTPType = (
    Literal[
        "string",
        "number",
        "boolean",
    ]
)
r"""The type of the argument."""


RunAgentRequestToolDefaultValueTypedDict = TypeAliasType(
    "RunAgentRequestToolDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


RunAgentRequestToolDefaultValue = TypeAliasType(
    "RunAgentRequestToolDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class RunAgentRequestToolArgumentsTypedDict(TypedDict):
    type: (
        StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11HTTPType
    )
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[RunAgentRequestToolDefaultValueTypedDict]
    r"""The default value of the argument."""


class RunAgentRequestToolArguments(BaseModel):
    type: (
        StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11HTTPType
    )
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[RunAgentRequestToolDefaultValue] = None
    r"""The default value of the argument."""


class RunAgentRequestToolHTTPTypedDict(TypedDict):
    blueprint: RunAgentRequestToolBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, RunAgentRequestToolArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class RunAgentRequestToolHTTP(BaseModel):
    blueprint: RunAgentRequestToolBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, RunAgentRequestToolArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class RunAgentRequestToolHTTPToolTypedDict(TypedDict):
    r"""Makes HTTP requests to external APIs"""

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11Type
    http: RunAgentRequestToolHTTPTypedDict
    id: NotRequired[str]
    requires_approval: NotRequired[bool]


class RunAgentRequestToolHTTPTool(BaseModel):
    r"""Makes HTTP requests to external APIs"""

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: str
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools11Type

    http: RunAgentRequestToolHTTP

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "01K62YGY99XT5HTD1YVGV5G48D"
    )

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools10Type = Literal[
    "current_date",
]


class RunAgentRequestToolCurrentDateToolTypedDict(TypedDict):
    r"""Provides the current date and time"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools10Type
    requires_approval: NotRequired[bool]


class RunAgentRequestToolCurrentDateTool(BaseModel):
    r"""Provides the current date and time"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools10Type

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools9Type = Literal[
    "query_knowledge_base",
]


class RunAgentRequestToolQueryKnowledgeBaseToolTypedDict(TypedDict):
    r"""Queries knowledge bases for information"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools9Type
    requires_approval: NotRequired[bool]


class RunAgentRequestToolQueryKnowledgeBaseTool(BaseModel):
    r"""Queries knowledge bases for information"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools9Type

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools8Type = Literal[
    "retrieve_knowledge_bases",
]


class RunAgentRequestToolRetrieveKnowledgeBasesToolTypedDict(TypedDict):
    r"""Lists available knowledge bases"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools8Type
    requires_approval: NotRequired[bool]


class RunAgentRequestToolRetrieveKnowledgeBasesTool(BaseModel):
    r"""Lists available knowledge bases"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools8Type

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools7Type = Literal[
    "retrieve_memory_stores",
]


class RunAgentRequestToolRetrieveMemoryStoresToolTypedDict(TypedDict):
    r"""Lists available memory stores"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools7Type
    requires_approval: NotRequired[bool]


class RunAgentRequestToolRetrieveMemoryStoresTool(BaseModel):
    r"""Lists available memory stores"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsTools7Type

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsToolsType = Literal[
    "write_memory_store",
]


class RunAgentRequestToolWriteMemoryStoreToolTypedDict(TypedDict):
    r"""Writes information to agent memory stores"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsToolsType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolWriteMemoryStoreTool(BaseModel):
    r"""Writes information to agent memory stores"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsToolsType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsType = Literal[
    "query_memory_store",
]


class RunAgentRequestToolQueryMemoryStoreToolTypedDict(TypedDict):
    r"""Queries agent memory stores for context"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolQueryMemoryStoreTool(BaseModel):
    r"""Queries agent memory stores for context"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodySettingsType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodyType = Literal[
    "retrieve_agents",
]


class RunAgentRequestToolRetrieveAgentsToolTypedDict(TypedDict):
    r"""Retrieves available agents in the system"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodyType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolRetrieveAgentsTool(BaseModel):
    r"""Retrieves available agents in the system"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestRequestBodyType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsRequestType = Literal["call_sub_agent",]


class RunAgentRequestToolCallSubAgentToolTypedDict(TypedDict):
    r"""Delegates tasks to specialized sub-agents"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolCallSubAgentTool(BaseModel):
    r"""Delegates tasks to specialized sub-agents"""

    type: StreamRunAgentRunAgentRequestToolAgentsRequestType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolAgentsType = Literal["web_scraper",]


class RunAgentRequestToolWebScraperToolTypedDict(TypedDict):
    r"""Scrapes and extracts content from web pages"""

    type: StreamRunAgentRunAgentRequestToolAgentsType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolWebScraperTool(BaseModel):
    r"""Scrapes and extracts content from web pages"""

    type: StreamRunAgentRunAgentRequestToolAgentsType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolType = Literal["google_search",]


class RunAgentRequestToolGoogleSearchToolTypedDict(TypedDict):
    r"""Performs Google searches to retrieve web content"""

    type: StreamRunAgentRunAgentRequestToolType
    requires_approval: NotRequired[bool]


class RunAgentRequestToolGoogleSearchTool(BaseModel):
    r"""Performs Google searches to retrieve web content"""

    type: StreamRunAgentRunAgentRequestToolType

    requires_approval: Optional[bool] = False


StreamRunAgentRunAgentRequestToolTypedDict = TypeAliasType(
    "StreamRunAgentRunAgentRequestToolTypedDict",
    Union[
        RunAgentRequestToolGoogleSearchToolTypedDict,
        RunAgentRequestToolWebScraperToolTypedDict,
        RunAgentRequestToolCallSubAgentToolTypedDict,
        RunAgentRequestToolRetrieveAgentsToolTypedDict,
        RunAgentRequestToolQueryMemoryStoreToolTypedDict,
        RunAgentRequestToolWriteMemoryStoreToolTypedDict,
        RunAgentRequestToolRetrieveMemoryStoresToolTypedDict,
        RunAgentRequestToolRetrieveKnowledgeBasesToolTypedDict,
        RunAgentRequestToolQueryKnowledgeBaseToolTypedDict,
        RunAgentRequestToolCurrentDateToolTypedDict,
        RunAgentRequestToolHTTPToolTypedDict,
        RunAgentRequestToolCodeExecutionToolTypedDict,
        RunAgentRequestToolFunctionToolTypedDict,
    ],
)
r"""Available tools for agent execution. Each tool provides specific capabilities to interact with external systems, retrieve information, or perform specialized tasks."""


StreamRunAgentRunAgentRequestTool = TypeAliasType(
    "StreamRunAgentRunAgentRequestTool",
    Union[
        RunAgentRequestToolGoogleSearchTool,
        RunAgentRequestToolWebScraperTool,
        RunAgentRequestToolCallSubAgentTool,
        RunAgentRequestToolRetrieveAgentsTool,
        RunAgentRequestToolQueryMemoryStoreTool,
        RunAgentRequestToolWriteMemoryStoreTool,
        RunAgentRequestToolRetrieveMemoryStoresTool,
        RunAgentRequestToolRetrieveKnowledgeBasesTool,
        RunAgentRequestToolQueryKnowledgeBaseTool,
        RunAgentRequestToolCurrentDateTool,
        RunAgentRequestToolHTTPTool,
        RunAgentRequestToolCodeExecutionTool,
        RunAgentRequestToolFunctionTool,
    ],
)
r"""Available tools for agent execution. Each tool provides specific capabilities to interact with external systems, retrieve information, or perform specialized tasks."""


StreamRunAgentToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class StreamRunAgentSettingsTypedDict(TypedDict):
    tools: List[StreamRunAgentRunAgentRequestToolTypedDict]
    r"""Tools available to the agent"""
    tool_approval_required: NotRequired[StreamRunAgentToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""


class StreamRunAgentSettings(BaseModel):
    tools: List[StreamRunAgentRunAgentRequestTool]
    r"""Tools available to the agent"""

    tool_approval_required: Optional[StreamRunAgentToolApprovalRequired] = "none"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""


class StreamRunAgentRequestBodyTypedDict(TypedDict):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""
    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""
    role: str
    r"""Specifies the agent's function and area of expertise."""
    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""
    message: StreamRunAgentMessageTypedDict
    r"""The A2A format message containing the task for the agent to perform."""
    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    settings: StreamRunAgentSettingsTypedDict
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[StreamRunAgentContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[StreamRunAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[StreamRunAgentMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    description: NotRequired[str]
    r"""A brief summary of the agent's purpose."""
    system_prompt: NotRequired[str]
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""
    memory_stores: NotRequired[List[str]]
    knowledge_bases: NotRequired[List[StreamRunAgentKnowledgeBasesTypedDict]]
    team_of_agents: NotRequired[List[StreamRunAgentTeamOfAgentsTypedDict]]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""
    stream_timeout_seconds: NotRequired[float]
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""


class StreamRunAgentRequestBody(BaseModel):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""

    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""

    role: str
    r"""Specifies the agent's function and area of expertise."""

    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""

    message: StreamRunAgentMessage
    r"""The A2A format message containing the task for the agent to perform."""

    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    settings: StreamRunAgentSettings

    task_id: Annotated[Optional[str], pydantic.Field(alias="taskId")] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[StreamRunAgentContact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[StreamRunAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[StreamRunAgentMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    description: Optional[str] = None
    r"""A brief summary of the agent's purpose."""

    system_prompt: Optional[str] = None
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""

    memory_stores: Optional[List[str]] = None

    knowledge_bases: Optional[List[StreamRunAgentKnowledgeBases]] = None

    team_of_agents: Optional[List[StreamRunAgentTeamOfAgents]] = None
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""

    stream_timeout_seconds: Optional[float] = None
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""


class StreamRunAgentAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(frozen=True)
class StreamRunAgentAgentsResponseBody(OrqError):
    r"""Model not found"""

    data: StreamRunAgentAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: StreamRunAgentAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class StreamRunAgentResponseBodyTypedDict(TypedDict):
    r"""SSE stream of agent events"""

    data: str
    r"""JSON-encoded event data"""


class StreamRunAgentResponseBody(BaseModel):
    r"""SSE stream of agent events"""

    data: str
    r"""JSON-encoded event data"""
