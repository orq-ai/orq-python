"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    RequestMetadata,
)
import pydantic
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


Status = Literal[
    "inactive",
    "approval_required",
    "in_progress",
]


class ListAgentTasksRequestBodyTypedDict(TypedDict):
    status: List[Status]


class ListAgentTasksRequestBody(BaseModel):
    status: List[Status]


class ListAgentTasksRequestTypedDict(TypedDict):
    agent_key: str
    limit: NotRequired[float]
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""
    starting_after: NotRequired[str]
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""
    ending_before: NotRequired[str]
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""
    request_body: NotRequired[ListAgentTasksRequestBodyTypedDict]


class ListAgentTasksRequest(BaseModel):
    agent_key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]

    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""

    starting_after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""

    ending_before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""

    request_body: Annotated[
        Optional[ListAgentTasksRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None


class ListAgentTasksAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(frozen=True)
class ListAgentTasksAgentsResponseBody(OrqError):
    r"""No agent tasks found"""

    data: ListAgentTasksAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: ListAgentTasksAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class ListAgentTasksModelTypedDict(TypedDict):
    id: str
    r"""The database ID of the primary model"""
    integration_id: NotRequired[str]
    r"""Optional integration ID for custom model configurations"""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""
    max_tokens: NotRequired[int]
    r"""Maximum number of tokens for model responses"""
    temperature: NotRequired[float]
    r"""Temperature setting for model responses"""


class ListAgentTasksModel(BaseModel):
    id: str
    r"""The database ID of the primary model"""

    integration_id: Optional[str] = None
    r"""Optional integration ID for custom model configurations"""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""

    max_tokens: Optional[int] = None
    r"""Maximum number of tokens for model responses"""

    temperature: Optional[float] = None
    r"""Temperature setting for model responses"""


ListAgentTasksToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class ListAgentTasksConditionsTypedDict(TypedDict):
    condition: str
    r"""The argument of the tool call to evaluate"""
    operator: str
    r"""The operator to use"""
    value: str
    r"""The value to compare against"""


class ListAgentTasksConditions(BaseModel):
    condition: str
    r"""The argument of the tool call to evaluate"""

    operator: str
    r"""The operator to use"""

    value: str
    r"""The value to compare against"""


class ListAgentTasksToolsTypedDict(TypedDict):
    id: str
    r"""The id of the resource"""
    action_type: str
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]
    conditions: NotRequired[List[ListAgentTasksConditionsTypedDict]]
    mcp_server: NotRequired[str]
    r"""The id of the resource"""
    timeout: NotRequired[float]
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class ListAgentTasksTools(BaseModel):
    id: str
    r"""The id of the resource"""

    action_type: str

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False

    conditions: Optional[List[ListAgentTasksConditions]] = None

    mcp_server: Annotated[Optional[str], pydantic.Field(alias="mcpServer")] = None
    r"""The id of the resource"""

    timeout: Optional[float] = 120
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class ListAgentTasksSettingsTypedDict(TypedDict):
    max_execution_time: int
    r"""Max execution time in seconds"""
    tools: List[ListAgentTasksToolsTypedDict]
    max_iterations: NotRequired[int]
    tool_approval_required: NotRequired[ListAgentTasksToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class ListAgentTasksSettings(BaseModel):
    max_execution_time: int
    r"""Max execution time in seconds"""

    tools: List[ListAgentTasksTools]

    max_iterations: Optional[int] = 10

    tool_approval_required: Optional[ListAgentTasksToolApprovalRequired] = (
        "respect_tool"
    )
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class AgentManifestSnapshotTypedDict(TypedDict):
    id: str
    key: str
    role: str
    description: str
    instructions: str
    model: ListAgentTasksModelTypedDict
    system_prompt: NotRequired[str]
    settings: NotRequired[ListAgentTasksSettingsTypedDict]
    project_id: NotRequired[str]


class AgentManifestSnapshot(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    key: str

    role: str

    description: str

    instructions: str

    model: ListAgentTasksModel

    system_prompt: Optional[str] = None

    settings: Optional[ListAgentTasksSettings] = None

    project_id: Optional[str] = None


class ListAgentTasksMemoryTypedDict(TypedDict):
    r"""Memory configuration for this execution"""

    entity_id: str
    r"""Entity identifier used for memory store isolation (user/session/conversation)"""


class ListAgentTasksMemory(BaseModel):
    r"""Memory configuration for this execution"""

    entity_id: str
    r"""Entity identifier used for memory store isolation (user/session/conversation)"""


class ListAgentTasksStateTypedDict(TypedDict):
    waiting_for_approval: NotRequired[bool]
    inactive: NotRequired[bool]
    error: NotRequired[str]
    iteration: NotRequired[int]
    accumulated_execution_time: NotRequired[float]


class ListAgentTasksState(BaseModel):
    waiting_for_approval: Optional[bool] = False

    inactive: Optional[bool] = True

    error: Optional[str] = None

    iteration: Optional[int] = 1

    accumulated_execution_time: Optional[float] = 0


class ListAgentTasksMetricsTypedDict(TypedDict):
    input_cost: NotRequired[float]
    output_cost: NotRequired[float]
    total_cost: NotRequired[float]
    prompt_tokens: NotRequired[int]
    completion_tokens: NotRequired[int]
    total_tokens: NotRequired[int]


class ListAgentTasksMetrics(BaseModel):
    input_cost: Optional[float] = 0

    output_cost: Optional[float] = 0

    total_cost: Optional[float] = 0

    prompt_tokens: Optional[int] = 0

    completion_tokens: Optional[int] = 0

    total_tokens: Optional[int] = 0


class TasksTypedDict(TypedDict):
    id: str
    agent_manifest_snapshot: AgentManifestSnapshotTypedDict
    workspace_id: str
    state: ListAgentTasksStateTypedDict
    metrics: ListAgentTasksMetricsTypedDict
    created_by_id: NotRequired[str]
    updated_by_id: NotRequired[str]
    created: NotRequired[str]
    updated: NotRequired[str]
    name: NotRequired[str]
    memory: NotRequired[ListAgentTasksMemoryTypedDict]
    r"""Memory configuration for this execution"""


class Tasks(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    agent_manifest_snapshot: AgentManifestSnapshot

    workspace_id: str

    state: ListAgentTasksState

    metrics: ListAgentTasksMetrics

    created_by_id: Optional[str] = None

    updated_by_id: Optional[str] = None

    created: Optional[str] = None

    updated: Optional[str] = None

    name: Optional[str] = None

    memory: Optional[ListAgentTasksMemory] = None
    r"""Memory configuration for this execution"""


class ListAgentTasksResponseBodyTypedDict(TypedDict):
    r"""Agent tasks retrieved"""

    tasks: List[TasksTypedDict]
    overall_total: float


class ListAgentTasksResponseBody(BaseModel):
    r"""Agent tasks retrieved"""

    tasks: List[Tasks]

    overall_total: float
