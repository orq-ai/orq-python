"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata
import pydantic
from pydantic import ConfigDict
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SyncMcpToolRequestTypedDict(TypedDict):
    tool_id: str
    r"""The ID of the MCP tool to sync"""


class SyncMcpToolRequest(BaseModel):
    tool_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The ID of the MCP tool to sync"""


SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType = Literal["code",]


SyncMcpToolResponseBodyToolsResponse200ApplicationJSON5Type = Literal["object",]
r"""The type must be \"object\" """


class SyncMcpToolResponseBodyToolsParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class SyncMcpToolResponseBodyToolsParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


SyncMcpToolResponseBodyLanguage = Literal["python",]


class SyncMcpToolResponseBodyCodeToolTypedDict(TypedDict):
    language: SyncMcpToolResponseBodyLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[SyncMcpToolResponseBodyToolsParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class SyncMcpToolResponseBodyCodeTool(BaseModel):
    language: SyncMcpToolResponseBodyLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[SyncMcpToolResponseBodyToolsParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class SyncMcpToolResponseBodyToolsResponseSyncResultTypedDict(TypedDict):
    tools_total: float
    tools_added: float
    tools_removed: float
    errors: List[str]


class SyncMcpToolResponseBodyToolsResponseSyncResult(BaseModel):
    tools_total: Annotated[float, pydantic.Field(alias="toolsTotal")]

    tools_added: Annotated[float, pydantic.Field(alias="toolsAdded")]

    tools_removed: Annotated[float, pydantic.Field(alias="toolsRemoved")]

    errors: List[str]


class SyncMcpToolResponseBody5TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType
    code_tool: SyncMcpToolResponseBodyCodeToolTypedDict
    sync_result: SyncMcpToolResponseBodyToolsResponseSyncResultTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class SyncMcpToolResponseBody5(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType

    code_tool: SyncMcpToolResponseBodyCodeTool

    sync_result: Annotated[
        SyncMcpToolResponseBodyToolsResponseSyncResult,
        pydantic.Field(alias="syncResult"),
    ]

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFZ83V1RAXJSJC3BJC3J"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus] = (
        "live"
    )
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


SyncMcpToolResponseBodyToolsResponse200Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


SyncMcpToolResponseBodyToolsResponse200Type = Literal["mcp",]


class SyncMcpToolResponseBodyHeadersTypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class SyncMcpToolResponseBodyHeaders(BaseModel):
    value: str

    encrypted: Optional[bool] = False


SyncMcpToolResponseBodyToolsResponse200ApplicationJSON4Type = Literal["object",]


class SyncMcpToolResponseBodyToolsSchemaTypedDict(TypedDict):
    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON4Type
    properties: NotRequired[Dict[str, Any]]
    required: NotRequired[List[str]]


class SyncMcpToolResponseBodyToolsSchema(BaseModel):
    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON4Type

    properties: Optional[Dict[str, Any]] = None

    required: Optional[List[str]] = None


class SyncMcpToolResponseBodyToolsTypedDict(TypedDict):
    name: str
    schema_: SyncMcpToolResponseBodyToolsSchemaTypedDict
    id: NotRequired[str]
    description: NotRequired[str]


class SyncMcpToolResponseBodyTools(BaseModel):
    name: str

    schema_: Annotated[
        SyncMcpToolResponseBodyToolsSchema, pydantic.Field(alias="schema")
    ]

    id: Optional[str] = "01KABAYFZ7MAA8SHJEC30ZSTAS"

    description: Optional[str] = None


SyncMcpToolResponseBodyConnectionType = Literal[
    "http",
    "sse",
]
r"""The connection type used by the MCP server"""


class SyncMcpToolResponseBodyMcpTypedDict(TypedDict):
    server_url: str
    r"""The MCP server URL (cached for execution)"""
    tools: List[SyncMcpToolResponseBodyToolsTypedDict]
    r"""Array of tools available from the MCP server"""
    connection_type: SyncMcpToolResponseBodyConnectionType
    r"""The connection type used by the MCP server"""
    headers: NotRequired[Dict[str, SyncMcpToolResponseBodyHeadersTypedDict]]
    r"""HTTP headers for MCP server requests with encryption support"""


class SyncMcpToolResponseBodyMcp(BaseModel):
    server_url: str
    r"""The MCP server URL (cached for execution)"""

    tools: List[SyncMcpToolResponseBodyTools]
    r"""Array of tools available from the MCP server"""

    connection_type: SyncMcpToolResponseBodyConnectionType
    r"""The connection type used by the MCP server"""

    headers: Optional[Dict[str, SyncMcpToolResponseBodyHeaders]] = None
    r"""HTTP headers for MCP server requests with encryption support"""


class SyncMcpToolResponseBodyToolsSyncResultTypedDict(TypedDict):
    tools_total: float
    tools_added: float
    tools_removed: float
    errors: List[str]


class SyncMcpToolResponseBodyToolsSyncResult(BaseModel):
    tools_total: Annotated[float, pydantic.Field(alias="toolsTotal")]

    tools_added: Annotated[float, pydantic.Field(alias="toolsAdded")]

    tools_removed: Annotated[float, pydantic.Field(alias="toolsRemoved")]

    errors: List[str]


class SyncMcpToolResponseBody4TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: SyncMcpToolResponseBodyToolsResponse200Type
    mcp: SyncMcpToolResponseBodyMcpTypedDict
    sync_result: SyncMcpToolResponseBodyToolsSyncResultTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[SyncMcpToolResponseBodyToolsResponse200Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class SyncMcpToolResponseBody4(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: SyncMcpToolResponseBodyToolsResponse200Type

    mcp: SyncMcpToolResponseBodyMcp

    sync_result: Annotated[
        SyncMcpToolResponseBodyToolsSyncResult, pydantic.Field(alias="syncResult")
    ]

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFZ5H92W19X395KGBNN1"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[SyncMcpToolResponseBodyToolsResponse200Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


SyncMcpToolResponseBodyToolsResponseStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


SyncMcpToolResponseBodyToolsResponseType = Literal["http",]


SyncMcpToolResponseBodyMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class SyncMcpToolHeaders2TypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class SyncMcpToolHeaders2(BaseModel):
    value: str

    encrypted: Optional[bool] = False


SyncMcpToolResponseBodyToolsHeadersTypedDict = TypeAliasType(
    "SyncMcpToolResponseBodyToolsHeadersTypedDict",
    Union[SyncMcpToolHeaders2TypedDict, str],
)


SyncMcpToolResponseBodyToolsHeaders = TypeAliasType(
    "SyncMcpToolResponseBodyToolsHeaders", Union[SyncMcpToolHeaders2, str]
)


class SyncMcpToolResponseBodyBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: SyncMcpToolResponseBodyMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, SyncMcpToolResponseBodyToolsHeadersTypedDict]]
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class SyncMcpToolResponseBodyBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: SyncMcpToolResponseBodyMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, SyncMcpToolResponseBodyToolsHeaders]] = None
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


SyncMcpToolResponseBodyToolsResponse200ApplicationJSON3Type = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


SyncMcpToolResponseBodyDefaultValueTypedDict = TypeAliasType(
    "SyncMcpToolResponseBodyDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


SyncMcpToolResponseBodyDefaultValue = TypeAliasType(
    "SyncMcpToolResponseBodyDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class SyncMcpToolResponseBodyArgumentsTypedDict(TypedDict):
    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[SyncMcpToolResponseBodyDefaultValueTypedDict]
    r"""The default value of the argument."""


class SyncMcpToolResponseBodyArguments(BaseModel):
    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[SyncMcpToolResponseBodyDefaultValue] = None
    r"""The default value of the argument."""


class SyncMcpToolResponseBodyHTTPTypedDict(TypedDict):
    blueprint: SyncMcpToolResponseBodyBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, SyncMcpToolResponseBodyArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class SyncMcpToolResponseBodyHTTP(BaseModel):
    blueprint: SyncMcpToolResponseBodyBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, SyncMcpToolResponseBodyArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class SyncMcpToolResponseBodySyncResultTypedDict(TypedDict):
    tools_total: float
    tools_added: float
    tools_removed: float
    errors: List[str]


class SyncMcpToolResponseBodySyncResult(BaseModel):
    tools_total: Annotated[float, pydantic.Field(alias="toolsTotal")]

    tools_added: Annotated[float, pydantic.Field(alias="toolsAdded")]

    tools_removed: Annotated[float, pydantic.Field(alias="toolsRemoved")]

    errors: List[str]


class SyncMcpToolResponseBody3TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: SyncMcpToolResponseBodyToolsResponseType
    http: SyncMcpToolResponseBodyHTTPTypedDict
    sync_result: SyncMcpToolResponseBodySyncResultTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[SyncMcpToolResponseBodyToolsResponseStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class SyncMcpToolResponseBody3(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: SyncMcpToolResponseBodyToolsResponseType

    http: SyncMcpToolResponseBodyHTTP

    sync_result: Annotated[
        SyncMcpToolResponseBodySyncResult, pydantic.Field(alias="syncResult")
    ]

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFZ2ZTMV6DFW16RTPQ6A"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[SyncMcpToolResponseBodyToolsResponseStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


SyncMcpToolResponseBodyToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


SyncMcpToolResponseBodyToolsType = Literal["json_schema",]


class SyncMcpToolResponseBodySchemaTypedDict(TypedDict):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: str
    r"""The JSON Schema type"""
    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""
    required: List[str]
    r"""Array of required property names"""


class SyncMcpToolResponseBodySchema(BaseModel):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: str
    r"""The JSON Schema type"""

    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""

    required: List[str]
    r"""Array of required property names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class SyncMcpToolResponseBodyJSONSchemaTypedDict(TypedDict):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: str
    r"""A description of what the response format is for. This will be shown to the user."""
    schema_: SyncMcpToolResponseBodySchemaTypedDict
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class SyncMcpToolResponseBodyJSONSchema(BaseModel):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: str
    r"""A description of what the response format is for. This will be shown to the user."""

    schema_: Annotated[SyncMcpToolResponseBodySchema, pydantic.Field(alias="schema")]
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class ResponseBodySyncResultTypedDict(TypedDict):
    tools_total: float
    tools_added: float
    tools_removed: float
    errors: List[str]


class ResponseBodySyncResult(BaseModel):
    tools_total: Annotated[float, pydantic.Field(alias="toolsTotal")]

    tools_added: Annotated[float, pydantic.Field(alias="toolsAdded")]

    tools_removed: Annotated[float, pydantic.Field(alias="toolsRemoved")]

    errors: List[str]


class SyncMcpToolResponseBody2TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: SyncMcpToolResponseBodyToolsType
    json_schema: SyncMcpToolResponseBodyJSONSchemaTypedDict
    sync_result: ResponseBodySyncResultTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[SyncMcpToolResponseBodyToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class SyncMcpToolResponseBody2(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: SyncMcpToolResponseBodyToolsType

    json_schema: SyncMcpToolResponseBodyJSONSchema

    sync_result: Annotated[ResponseBodySyncResult, pydantic.Field(alias="syncResult")]

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFZ07E4VZ9Z5677TT90R"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[SyncMcpToolResponseBodyToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


SyncMcpToolResponseBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


SyncMcpToolResponseBodyType = Literal["function",]


SyncMcpToolResponseBodyToolsResponse200ApplicationJSON1Type = Literal["object",]
r"""The type must be \"object\" """


class SyncMcpToolResponseBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class SyncMcpToolResponseBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class SyncMcpToolResponseBodyFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[SyncMcpToolResponseBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class SyncMcpToolResponseBodyFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[SyncMcpToolResponseBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class SyncResultTypedDict(TypedDict):
    tools_total: float
    tools_added: float
    tools_removed: float
    errors: List[str]


class SyncResult(BaseModel):
    tools_total: Annotated[float, pydantic.Field(alias="toolsTotal")]

    tools_added: Annotated[float, pydantic.Field(alias="toolsAdded")]

    tools_removed: Annotated[float, pydantic.Field(alias="toolsRemoved")]

    errors: List[str]


class SyncMcpToolResponseBody1TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: SyncMcpToolResponseBodyType
    function: SyncMcpToolResponseBodyFunctionTypedDict
    sync_result: SyncResultTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[SyncMcpToolResponseBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class SyncMcpToolResponseBody1(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: SyncMcpToolResponseBodyType

    function: SyncMcpToolResponseBodyFunction

    sync_result: Annotated[SyncResult, pydantic.Field(alias="syncResult")]

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFYZKE5RXKQ74RE34TJC"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[SyncMcpToolResponseBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


SyncMcpToolResponseBodyTypedDict = TypeAliasType(
    "SyncMcpToolResponseBodyTypedDict",
    Union[
        SyncMcpToolResponseBody1TypedDict,
        SyncMcpToolResponseBody2TypedDict,
        SyncMcpToolResponseBody3TypedDict,
        SyncMcpToolResponseBody4TypedDict,
        SyncMcpToolResponseBody5TypedDict,
    ],
)
r"""Successfully synced MCP tool."""


SyncMcpToolResponseBody = TypeAliasType(
    "SyncMcpToolResponseBody",
    Union[
        SyncMcpToolResponseBody1,
        SyncMcpToolResponseBody2,
        SyncMcpToolResponseBody3,
        SyncMcpToolResponseBody4,
        SyncMcpToolResponseBody5,
    ],
)
r"""Successfully synced MCP tool."""
