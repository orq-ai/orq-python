"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


RoleToolMessage = Literal["tool",]
r"""Tool message"""


RoleUserMessage = Literal["user",]
r"""User message"""


InvokeAgentRoleTypedDict = TypeAliasType(
    "InvokeAgentRoleTypedDict", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


InvokeAgentRole = TypeAliasType(
    "InvokeAgentRole", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


InvokeAgentPublicMessagePartKind = Literal["tool_result",]


class ToolResultPartTypedDict(TypedDict):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: InvokeAgentPublicMessagePartKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class ToolResultPart(BaseModel):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: InvokeAgentPublicMessagePartKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


PublicMessagePartKind = Literal["file",]


class FileInURIFormatTypedDict(TypedDict):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class FileInURIFormat(BaseModel):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class BinaryFormatTypedDict(TypedDict):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class BinaryFormat(BaseModel):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


PublicMessagePartFileTypedDict = TypeAliasType(
    "PublicMessagePartFileTypedDict",
    Union[BinaryFormatTypedDict, FileInURIFormatTypedDict],
)


PublicMessagePartFile = TypeAliasType(
    "PublicMessagePartFile", Union[BinaryFormat, FileInURIFormat]
)


class FilePartTypedDict(TypedDict):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: PublicMessagePartKind
    file: PublicMessagePartFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class FilePart(BaseModel):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: PublicMessagePartKind

    file: PublicMessagePartFile

    metadata: Optional[Dict[str, Any]] = None


Kind = Literal["text",]


class TextPartTypedDict(TypedDict):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: Kind
    text: str


class TextPart(BaseModel):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: Kind

    text: str


PublicMessagePartTypedDict = TypeAliasType(
    "PublicMessagePartTypedDict",
    Union[TextPartTypedDict, FilePartTypedDict, ToolResultPartTypedDict],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


PublicMessagePart = TypeAliasType(
    "PublicMessagePart", Union[TextPart, FilePart, ToolResultPart]
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class MessageTypedDict(TypedDict):
    role: InvokeAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[PublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class Message(BaseModel):
    role: InvokeAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[PublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""


class ContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class Contact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class InvokeAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class InvokeAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class MemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class Memory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class InvokeAgentRequestBodyTypedDict(TypedDict):
    message: MessageTypedDict
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[ContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[InvokeAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[MemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""


class InvokeAgentRequestBody(BaseModel):
    message: Message

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[Contact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[InvokeAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[Memory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""


class InvokeAgentRequestTypedDict(TypedDict):
    key: str
    r"""The key or ID of the agent to invoke"""
    request_body: NotRequired[InvokeAgentRequestBodyTypedDict]


class InvokeAgentRequest(BaseModel):
    key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The key or ID of the agent to invoke"""

    request_body: Annotated[
        Optional[InvokeAgentRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None


InvokeAgentKind = Literal["task",]
r"""A2A entity type"""


InvokeAgentState = Literal[
    "submitted",
    "working",
    "input-required",
    "completed",
    "failed",
    "canceled",
    "rejected",
    "auth-required",
    "unknown",
]
r"""Current task state"""


InvokeAgentAgentsKind = Literal["message",]


InvokeAgentAgentsRole = Literal[
    "user",
    "agent",
    "tool",
    "system",
]
r"""Extended A2A message role"""


InvokeAgentPartsAgentsResponse200ApplicationJSONKind = Literal["tool_result",]


class InvokeAgentParts5TypedDict(TypedDict):
    kind: InvokeAgentPartsAgentsResponse200ApplicationJSONKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class InvokeAgentParts5(BaseModel):
    kind: InvokeAgentPartsAgentsResponse200ApplicationJSONKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


InvokeAgentPartsAgentsResponse200Kind = Literal["tool_call",]


class InvokeAgentParts4TypedDict(TypedDict):
    kind: InvokeAgentPartsAgentsResponse200Kind
    tool_name: str
    tool_call_id: str
    arguments: Dict[str, Any]
    metadata: NotRequired[Dict[str, Any]]


class InvokeAgentParts4(BaseModel):
    kind: InvokeAgentPartsAgentsResponse200Kind

    tool_name: str

    tool_call_id: str

    arguments: Dict[str, Any]

    metadata: Optional[Dict[str, Any]] = None


InvokeAgentPartsAgentsResponseKind = Literal["file",]


class InvokeAgentFileFileInURIFormatTypedDict(TypedDict):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class InvokeAgentFileFileInURIFormat(BaseModel):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class InvokeAgentFileBinaryFormatTypedDict(TypedDict):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class InvokeAgentFileBinaryFormat(BaseModel):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


InvokeAgentPartsFileTypedDict = TypeAliasType(
    "InvokeAgentPartsFileTypedDict",
    Union[
        InvokeAgentFileBinaryFormatTypedDict, InvokeAgentFileFileInURIFormatTypedDict
    ],
)


InvokeAgentPartsFile = TypeAliasType(
    "InvokeAgentPartsFile",
    Union[InvokeAgentFileBinaryFormat, InvokeAgentFileFileInURIFormat],
)


class InvokeAgentParts3TypedDict(TypedDict):
    kind: InvokeAgentPartsAgentsResponseKind
    file: InvokeAgentPartsFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class InvokeAgentParts3(BaseModel):
    kind: InvokeAgentPartsAgentsResponseKind

    file: InvokeAgentPartsFile

    metadata: Optional[Dict[str, Any]] = None


InvokeAgentPartsAgentsKind = Literal["data",]


class InvokeAgentParts2TypedDict(TypedDict):
    kind: InvokeAgentPartsAgentsKind
    data: Dict[str, Any]
    metadata: NotRequired[Dict[str, Any]]


class InvokeAgentParts2(BaseModel):
    kind: InvokeAgentPartsAgentsKind

    data: Dict[str, Any]

    metadata: Optional[Dict[str, Any]] = None


InvokeAgentPartsKind = Literal["text",]


class InvokeAgentParts1TypedDict(TypedDict):
    kind: InvokeAgentPartsKind
    text: str


class InvokeAgentParts1(BaseModel):
    kind: InvokeAgentPartsKind

    text: str


InvokeAgentPartsTypedDict = TypeAliasType(
    "InvokeAgentPartsTypedDict",
    Union[
        InvokeAgentParts1TypedDict,
        InvokeAgentParts2TypedDict,
        InvokeAgentParts3TypedDict,
        InvokeAgentParts5TypedDict,
        InvokeAgentParts4TypedDict,
    ],
)


InvokeAgentParts = TypeAliasType(
    "InvokeAgentParts",
    Union[
        InvokeAgentParts1,
        InvokeAgentParts2,
        InvokeAgentParts3,
        InvokeAgentParts5,
        InvokeAgentParts4,
    ],
)


class InvokeAgentMessageTypedDict(TypedDict):
    r"""Optional status message"""

    kind: InvokeAgentAgentsKind
    message_id: str
    role: InvokeAgentAgentsRole
    r"""Extended A2A message role"""
    parts: List[InvokeAgentPartsTypedDict]


class InvokeAgentMessage(BaseModel):
    r"""Optional status message"""

    kind: InvokeAgentAgentsKind

    message_id: Annotated[str, pydantic.Field(alias="messageId")]

    role: InvokeAgentAgentsRole
    r"""Extended A2A message role"""

    parts: List[InvokeAgentParts]


class InvokeAgentStatusTypedDict(TypedDict):
    r"""Task status information"""

    state: InvokeAgentState
    r"""Current task state"""
    timestamp: NotRequired[str]
    r"""ISO timestamp of status update"""
    message: NotRequired[InvokeAgentMessageTypedDict]
    r"""Optional status message"""


class InvokeAgentStatus(BaseModel):
    r"""Task status information"""

    state: InvokeAgentState
    r"""Current task state"""

    timestamp: Optional[str] = None
    r"""ISO timestamp of status update"""

    message: Optional[InvokeAgentMessage] = None
    r"""Optional status message"""


class InvokeAgentResponseBodyTypedDict(TypedDict):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""
    context_id: str
    r"""The correlation ID for this execution"""
    kind: InvokeAgentKind
    r"""A2A entity type"""
    status: InvokeAgentStatusTypedDict
    r"""Task status information"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Task metadata containing workspace_id and trace_id for feedback"""


class InvokeAgentResponseBody(BaseModel):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""

    context_id: Annotated[str, pydantic.Field(alias="contextId")]
    r"""The correlation ID for this execution"""

    kind: InvokeAgentKind
    r"""A2A entity type"""

    status: InvokeAgentStatus
    r"""Task status information"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Task metadata containing workspace_id and trace_id for feedback"""
