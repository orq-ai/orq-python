"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .datapart import DataPart, DataPartTypedDict
from .errorpart import ErrorPart, ErrorPartTypedDict
from .filepart import FilePart, FilePartTypedDict
from .textpart import TextPart, TextPartTypedDict
from .toolcallpart import ToolCallPart, ToolCallPartTypedDict
from .toolresultpart import ToolResultPart, ToolResultPartTypedDict
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import (
    Annotated,
    NotRequired,
    TypeAliasType,
    TypedDict,
    deprecated,
)


InvokeAgentRoleToolMessage = Literal["tool",]
r"""Message containing tool execution results"""


InvokeAgentRoleUserMessage = Literal["user",]
r"""Message from the end user"""


InvokeAgentRoleTypedDict = TypeAliasType(
    "InvokeAgentRoleTypedDict",
    Union[InvokeAgentRoleUserMessage, InvokeAgentRoleToolMessage],
)
r"""Message role (user or tool for continuing executions)"""


InvokeAgentRole = TypeAliasType(
    "InvokeAgentRole", Union[InvokeAgentRoleUserMessage, InvokeAgentRoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


InvokeAgentPublicMessagePartTypedDict = TypeAliasType(
    "InvokeAgentPublicMessagePartTypedDict",
    Union[
        TextPartTypedDict,
        FilePartTypedDict,
        ErrorPartTypedDict,
        ToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


InvokeAgentPublicMessagePart = Annotated[
    Union[
        Annotated[TextPart, Tag("text")],
        Annotated[FilePart, Tag("file")],
        Annotated[ToolResultPart, Tag("tool_result")],
        Annotated[ErrorPart, Tag("error")],
    ],
    Discriminator(lambda m: get_discriminator(m, "kind", "kind")),
]
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class InvokeAgentA2AMessageTypedDict(TypedDict):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: InvokeAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[InvokeAgentPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class InvokeAgentA2AMessage(BaseModel):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: InvokeAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[InvokeAgentPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["messageId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InvokeAgentIdentityTypedDict(TypedDict):
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class InvokeAgentIdentity(BaseModel):
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class InvokeAgentContactTypedDict(TypedDict):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


@deprecated(
    "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
)
class InvokeAgentContact(BaseModel):
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InvokeAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class InvokeAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InvokeAgentMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class InvokeAgentMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class InvokeAgentRequestBodyTypedDict(TypedDict):
    message: InvokeAgentA2AMessageTypedDict
    r"""The A2A message to send to the agent (user input or tool results)"""
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    identity: NotRequired[InvokeAgentIdentityTypedDict]
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""
    contact: NotRequired[InvokeAgentContactTypedDict]
    r"""@deprecated Use identity instead. Information about the contact making the request."""
    thread: NotRequired[InvokeAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[InvokeAgentMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""


class InvokeAgentRequestBody(BaseModel):
    message: InvokeAgentA2AMessage
    r"""The A2A message to send to the agent (user input or tool results)"""

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    identity: Optional[InvokeAgentIdentity] = None
    r"""Information about the identity making the request. If the identity does not exist, it will be created automatically."""

    contact: Annotated[
        Optional[InvokeAgentContact],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""@deprecated Use identity instead. Information about the contact making the request."""

    thread: Optional[InvokeAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[InvokeAgentMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "task_id",
                "variables",
                "identity",
                "contact",
                "thread",
                "memory",
                "metadata",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InvokeAgentRequestTypedDict(TypedDict):
    key: str
    r"""The key or ID of the agent to invoke"""
    request_body: NotRequired[InvokeAgentRequestBodyTypedDict]


class InvokeAgentRequest(BaseModel):
    key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The key or ID of the agent to invoke"""

    request_body: Annotated[
        Optional[InvokeAgentRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["RequestBody"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


InvokeAgentKind = Literal["task",]
r"""A2A entity type identifier"""


TaskState = Literal[
    "submitted",
    "working",
    "input-required",
    "auth-required",
    "completed",
    "failed",
    "canceled",
    "rejected",
]
r"""Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution."""


InvokeAgentAgentsKind = Literal["message",]


ExtendedMessageRole = Literal[
    "user",
    "agent",
    "tool",
    "system",
]
r"""Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts)."""


InvokeAgentPartsTypedDict = TypeAliasType(
    "InvokeAgentPartsTypedDict",
    Union[
        TextPartTypedDict,
        ErrorPartTypedDict,
        DataPartTypedDict,
        FilePartTypedDict,
        ToolResultPartTypedDict,
        ToolCallPartTypedDict,
    ],
)


InvokeAgentParts = Annotated[
    Union[
        Annotated[TextPart, Tag("text")],
        Annotated[ErrorPart, Tag("error")],
        Annotated[DataPart, Tag("data")],
        Annotated[FilePart, Tag("file")],
        Annotated[ToolCallPart, Tag("tool_call")],
        Annotated[ToolResultPart, Tag("tool_result")],
    ],
    Discriminator(lambda m: get_discriminator(m, "kind", "kind")),
]


class TaskStatusMessageTypedDict(TypedDict):
    r"""Optional A2A message providing additional context about the current status"""

    kind: InvokeAgentAgentsKind
    message_id: str
    role: ExtendedMessageRole
    r"""Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts)."""
    parts: List[InvokeAgentPartsTypedDict]


class TaskStatusMessage(BaseModel):
    r"""Optional A2A message providing additional context about the current status"""

    kind: InvokeAgentAgentsKind

    message_id: Annotated[str, pydantic.Field(alias="messageId")]

    role: ExtendedMessageRole
    r"""Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts)."""

    parts: List[InvokeAgentParts]


class TaskStatusTypedDict(TypedDict):
    r"""Current task status information"""

    state: TaskState
    r"""Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution."""
    timestamp: NotRequired[str]
    r"""ISO 8601 timestamp of when the status was updated"""
    message: NotRequired[TaskStatusMessageTypedDict]
    r"""Optional A2A message providing additional context about the current status"""


class TaskStatus(BaseModel):
    r"""Current task status information"""

    state: TaskState
    r"""Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution."""

    timestamp: Optional[str] = None
    r"""ISO 8601 timestamp of when the status was updated"""

    message: Optional[TaskStatusMessage] = None
    r"""Optional A2A message providing additional context about the current status"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["timestamp", "message"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InvokeAgentA2ATaskResponseTypedDict(TypedDict):
    r"""Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution."""

    id: str
    r"""The unique ID of the created agent execution task"""
    context_id: str
    r"""The correlation ID for this execution (used for tracking)"""
    kind: InvokeAgentKind
    r"""A2A entity type identifier"""
    status: TaskStatusTypedDict
    r"""Current task status information"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Task metadata containing workspace_id and trace_id for feedback and tracking"""


class InvokeAgentA2ATaskResponse(BaseModel):
    r"""Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution."""

    id: str
    r"""The unique ID of the created agent execution task"""

    context_id: Annotated[str, pydantic.Field(alias="contextId")]
    r"""The correlation ID for this execution (used for tracking)"""

    kind: InvokeAgentKind
    r"""A2A entity type identifier"""

    status: TaskStatus
    r"""Current task status information"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Task metadata containing workspace_id and trace_id for feedback and tracking"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["metadata"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
