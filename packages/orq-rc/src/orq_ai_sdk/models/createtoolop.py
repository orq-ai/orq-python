"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import get_discriminator
import pydantic
from pydantic import ConfigDict, Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


CreateToolRequestBodyToolsRequestStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolRequestBodyToolsRequest5Type = Literal["code",]


CreateToolRequestBodyToolsRequest5CodeToolType = Literal["object",]
r"""The type must be \"object\" """


class CreateToolRequestBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: CreateToolRequestBodyToolsRequest5CodeToolType
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class CreateToolRequestBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: CreateToolRequestBodyToolsRequest5CodeToolType
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


RequestBodyLanguage = Literal["python",]


class RequestBodyCodeToolTypedDict(TypedDict):
    language: RequestBodyLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[CreateToolRequestBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class RequestBodyCodeTool(BaseModel):
    language: RequestBodyLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[CreateToolRequestBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parameters"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RequestBodyCodeExecutionToolTypedDict(TypedDict):
    r"""Executes code snippets in a sandboxed environment, currently supporting Python."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: CreateToolRequestBodyToolsRequest5Type
    code_tool: RequestBodyCodeToolTypedDict
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    status: NotRequired[CreateToolRequestBodyToolsRequestStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


class RequestBodyCodeExecutionTool(BaseModel):
    r"""Executes code snippets in a sandboxed environment, currently supporting Python."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: CreateToolRequestBodyToolsRequest5Type

    code_tool: RequestBodyCodeTool

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    status: Optional[CreateToolRequestBodyToolsRequestStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolRequestBodyToolsRequest4Type = Literal["mcp",]


class RequestBodyHeadersTypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class RequestBodyHeaders(BaseModel):
    value: str

    encrypted: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["encrypted"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RequestBodyConnectionType = Literal[
    "http",
    "sse",
]
r"""The connection type used by the MCP server"""


class RequestBodyMcpTypedDict(TypedDict):
    server_url: str
    r"""The MCP server URL (cached for execution)"""
    connection_type: RequestBodyConnectionType
    r"""The connection type used by the MCP server"""
    headers: NotRequired[Dict[str, RequestBodyHeadersTypedDict]]
    r"""HTTP headers for MCP server requests with encryption support"""


class RequestBodyMcp(BaseModel):
    server_url: str
    r"""The MCP server URL (cached for execution)"""

    connection_type: RequestBodyConnectionType
    r"""The connection type used by the MCP server"""

    headers: Optional[Dict[str, RequestBodyHeaders]] = None
    r"""HTTP headers for MCP server requests with encryption support"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["headers"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RequestBodyMCPToolTypedDict(TypedDict):
    r"""A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: CreateToolRequestBodyToolsRequest4Type
    mcp: RequestBodyMcpTypedDict
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    status: NotRequired[CreateToolRequestBodyToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


class RequestBodyMCPTool(BaseModel):
    r"""A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: CreateToolRequestBodyToolsRequest4Type

    mcp: RequestBodyMcp

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    status: Optional[CreateToolRequestBodyToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolRequestBodyToolsRequestType = Literal["http",]


CreateToolRequestBodyMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class CreateToolHeaders2TypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class CreateToolHeaders2(BaseModel):
    value: str

    encrypted: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["encrypted"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyHeadersTypedDict = TypeAliasType(
    "CreateToolRequestBodyHeadersTypedDict", Union[CreateToolHeaders2TypedDict, str]
)


CreateToolRequestBodyHeaders = TypeAliasType(
    "CreateToolRequestBodyHeaders", Union[CreateToolHeaders2, str]
)


class RequestBodyBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: CreateToolRequestBodyMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, CreateToolRequestBodyHeadersTypedDict]]
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class RequestBodyBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: CreateToolRequestBodyMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, CreateToolRequestBodyHeaders]] = None
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["headers", "body"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyToolsRequest3Type = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


RequestBodyDefaultValueTypedDict = TypeAliasType(
    "RequestBodyDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


RequestBodyDefaultValue = TypeAliasType(
    "RequestBodyDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class RequestBodyArgumentsTypedDict(TypedDict):
    type: CreateToolRequestBodyToolsRequest3Type
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[RequestBodyDefaultValueTypedDict]
    r"""The default value of the argument."""


class RequestBodyArguments(BaseModel):
    type: CreateToolRequestBodyToolsRequest3Type
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[RequestBodyDefaultValue] = None
    r"""The default value of the argument."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["send_to_model", "default_value"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateToolRequestBodyHTTPTypedDict(TypedDict):
    blueprint: RequestBodyBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, RequestBodyArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class CreateToolRequestBodyHTTP(BaseModel):
    blueprint: RequestBodyBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, RequestBodyArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RequestBodyHTTPToolTypedDict(TypedDict):
    r"""Executes HTTP requests to interact with external APIs and web services using customizable blueprints."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: CreateToolRequestBodyToolsRequestType
    http: CreateToolRequestBodyHTTPTypedDict
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    status: NotRequired[CreateToolRequestBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


class RequestBodyHTTPTool(BaseModel):
    r"""Executes HTTP requests to interact with external APIs and web services using customizable blueprints."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: CreateToolRequestBodyToolsRequestType

    http: CreateToolRequestBodyHTTP

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    status: Optional[CreateToolRequestBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RequestBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolRequestBodyToolsType = Literal["json_schema",]


class RequestBodySchemaTypedDict(TypedDict):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: str
    r"""The JSON Schema type"""
    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""
    required: List[str]
    r"""Array of required property names"""


class RequestBodySchema(BaseModel):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: str
    r"""The JSON Schema type"""

    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""

    required: List[str]
    r"""Array of required property names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class RequestBodyJSONSchemaTypedDict(TypedDict):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: str
    r"""A description of what the response format is for. This will be shown to the user."""
    schema_: RequestBodySchemaTypedDict
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class RequestBodyJSONSchema(BaseModel):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: str
    r"""A description of what the response format is for. This will be shown to the user."""

    schema_: Annotated[RequestBodySchema, pydantic.Field(alias="schema")]
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["strict"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RequestBodyJSONSchemaToolTypedDict(TypedDict):
    r"""A tool that enforces structured output format using JSON Schema for consistent response formatting."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: CreateToolRequestBodyToolsType
    json_schema: RequestBodyJSONSchemaTypedDict
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    status: NotRequired[RequestBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


class RequestBodyJSONSchemaTool(BaseModel):
    r"""A tool that enforces structured output format using JSON Schema for consistent response formatting."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: CreateToolRequestBodyToolsType

    json_schema: RequestBodyJSONSchema

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    status: Optional[RequestBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyToolsRequest1Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolRequestBodyType = Literal["function",]


CreateToolRequestBodyToolsRequest1Type = Literal["object",]
r"""The type must be \"object\" """


class RequestBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: CreateToolRequestBodyToolsRequest1Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class RequestBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: CreateToolRequestBodyToolsRequest1Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class RequestBodyFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[RequestBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class RequestBodyFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[RequestBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description", "strict", "parameters"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RequestBodyFunctionToolTypedDict(TypedDict):
    r"""A custom function tool that allows the model to call predefined functions with structured parameters."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    type: CreateToolRequestBodyType
    function: RequestBodyFunctionTypedDict
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    status: NotRequired[CreateToolRequestBodyToolsRequest1Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


class RequestBodyFunctionTool(BaseModel):
    r"""A custom function tool that allows the model to call predefined functions with structured parameters."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    type: CreateToolRequestBodyType

    function: RequestBodyFunction

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    status: Optional[CreateToolRequestBodyToolsRequest1Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolRequestBodyTypedDict = TypeAliasType(
    "CreateToolRequestBodyTypedDict",
    Union[
        RequestBodyFunctionToolTypedDict,
        RequestBodyJSONSchemaToolTypedDict,
        RequestBodyHTTPToolTypedDict,
        RequestBodyMCPToolTypedDict,
        RequestBodyCodeExecutionToolTypedDict,
    ],
)
r"""The tool to create"""


CreateToolRequestBody = Annotated[
    Union[
        Annotated[RequestBodyFunctionTool, Tag("function")],
        Annotated[RequestBodyJSONSchemaTool, Tag("json_schema")],
        Annotated[RequestBodyHTTPTool, Tag("http")],
        Annotated[RequestBodyMCPTool, Tag("mcp")],
        Annotated[RequestBodyCodeExecutionTool, Tag("code")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""The tool to create"""


CreateToolResponseBodyToolsResponse200Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolResponseBodyToolsResponse200ApplicationJSONType = Literal["code",]


CreateToolResponseBodyToolsResponse200ApplicationJSON5Type = Literal["object",]
r"""The type must be \"object\" """


class CreateToolResponseBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: CreateToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class CreateToolResponseBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: CreateToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


ResponseBodyLanguage = Literal["python",]


class ResponseBodyCodeToolTypedDict(TypedDict):
    language: ResponseBodyLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[CreateToolResponseBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class ResponseBodyCodeTool(BaseModel):
    language: ResponseBodyLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[CreateToolResponseBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parameters"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyCodeExecutionToolTypedDict(TypedDict):
    r"""Executes code snippets in a sandboxed environment, currently supporting Python."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: CreateToolResponseBodyToolsResponse200ApplicationJSONType
    code_tool: ResponseBodyCodeToolTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[CreateToolResponseBodyToolsResponse200Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class ResponseBodyCodeExecutionTool(BaseModel):
    r"""Executes code snippets in a sandboxed environment, currently supporting Python."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: CreateToolResponseBodyToolsResponse200ApplicationJSONType

    code_tool: ResponseBodyCodeTool

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KHKCN1SSGMDFSJ0YPET6E5XR"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[CreateToolResponseBodyToolsResponse200Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "display_name",
                "created_by_id",
                "updated_by_id",
                "status",
                "version_hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyToolsResponseStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolResponseBodyToolsResponse200Type = Literal["mcp",]


class ResponseBodyHeadersTypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class ResponseBodyHeaders(BaseModel):
    value: str

    encrypted: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["encrypted"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyToolsResponse200ApplicationJSON4Type = Literal["object",]


class CreateToolResponseBodySchemaTypedDict(TypedDict):
    type: CreateToolResponseBodyToolsResponse200ApplicationJSON4Type
    properties: NotRequired[Dict[str, Any]]
    required: NotRequired[List[str]]


class CreateToolResponseBodySchema(BaseModel):
    type: CreateToolResponseBodyToolsResponse200ApplicationJSON4Type

    properties: Optional[Dict[str, Any]] = None

    required: Optional[List[str]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["properties", "required"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyToolsTypedDict(TypedDict):
    name: str
    schema_: CreateToolResponseBodySchemaTypedDict
    id: NotRequired[str]
    description: NotRequired[str]


class ResponseBodyTools(BaseModel):
    name: str

    schema_: Annotated[CreateToolResponseBodySchema, pydantic.Field(alias="schema")]

    id: Optional[str] = "01KHKCN1SQY9PBKTY8ZP91ZG8V"

    description: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id", "description"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ResponseBodyConnectionType = Literal[
    "http",
    "sse",
]
r"""The connection type used by the MCP server"""


class ResponseBodyMcpTypedDict(TypedDict):
    server_url: str
    r"""The MCP server URL (cached for execution)"""
    tools: List[ResponseBodyToolsTypedDict]
    r"""Array of tools available from the MCP server"""
    connection_type: ResponseBodyConnectionType
    r"""The connection type used by the MCP server"""
    headers: NotRequired[Dict[str, ResponseBodyHeadersTypedDict]]
    r"""HTTP headers for MCP server requests with encryption support"""


class ResponseBodyMcp(BaseModel):
    server_url: str
    r"""The MCP server URL (cached for execution)"""

    tools: List[ResponseBodyTools]
    r"""Array of tools available from the MCP server"""

    connection_type: ResponseBodyConnectionType
    r"""The connection type used by the MCP server"""

    headers: Optional[Dict[str, ResponseBodyHeaders]] = None
    r"""HTTP headers for MCP server requests with encryption support"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["headers"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyMCPToolTypedDict(TypedDict):
    r"""A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: CreateToolResponseBodyToolsResponse200Type
    mcp: ResponseBodyMcpTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[CreateToolResponseBodyToolsResponseStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class ResponseBodyMCPTool(BaseModel):
    r"""A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: CreateToolResponseBodyToolsResponse200Type

    mcp: ResponseBodyMcp

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KHKCN1SNEYRMMQ9K2GCM1MNR"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[CreateToolResponseBodyToolsResponseStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "display_name",
                "created_by_id",
                "updated_by_id",
                "status",
                "version_hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolResponseBodyToolsResponseType = Literal["http",]


CreateToolResponseBodyMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class CreateToolHeadersTools2TypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class CreateToolHeadersTools2(BaseModel):
    value: str

    encrypted: Optional[bool] = False

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["encrypted"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyHeadersTypedDict = TypeAliasType(
    "CreateToolResponseBodyHeadersTypedDict",
    Union[CreateToolHeadersTools2TypedDict, str],
)


CreateToolResponseBodyHeaders = TypeAliasType(
    "CreateToolResponseBodyHeaders", Union[CreateToolHeadersTools2, str]
)


class ResponseBodyBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: CreateToolResponseBodyMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, CreateToolResponseBodyHeadersTypedDict]]
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class ResponseBodyBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: CreateToolResponseBodyMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, CreateToolResponseBodyHeaders]] = None
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["headers", "body"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyToolsResponse200ApplicationJSON3Type = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


ResponseBodyDefaultValueTypedDict = TypeAliasType(
    "ResponseBodyDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


ResponseBodyDefaultValue = TypeAliasType(
    "ResponseBodyDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class ResponseBodyArgumentsTypedDict(TypedDict):
    type: CreateToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[ResponseBodyDefaultValueTypedDict]
    r"""The default value of the argument."""


class ResponseBodyArguments(BaseModel):
    type: CreateToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[ResponseBodyDefaultValue] = None
    r"""The default value of the argument."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["send_to_model", "default_value"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateToolResponseBodyHTTPTypedDict(TypedDict):
    blueprint: ResponseBodyBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, ResponseBodyArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class CreateToolResponseBodyHTTP(BaseModel):
    blueprint: ResponseBodyBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, ResponseBodyArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyHTTPToolTypedDict(TypedDict):
    r"""Executes HTTP requests to interact with external APIs and web services using customizable blueprints."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: CreateToolResponseBodyToolsResponseType
    http: CreateToolResponseBodyHTTPTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[CreateToolResponseBodyToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class ResponseBodyHTTPTool(BaseModel):
    r"""Executes HTTP requests to interact with external APIs and web services using customizable blueprints."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: CreateToolResponseBodyToolsResponseType

    http: CreateToolResponseBodyHTTP

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KHKCN1SKGWTQBV4AKAZ761EA"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[CreateToolResponseBodyToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "display_name",
                "created_by_id",
                "updated_by_id",
                "status",
                "version_hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolResponseBodyToolsType = Literal["json_schema",]


class ResponseBodySchemaTypedDict(TypedDict):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: str
    r"""The JSON Schema type"""
    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""
    required: List[str]
    r"""Array of required property names"""


class ResponseBodySchema(BaseModel):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: str
    r"""The JSON Schema type"""

    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""

    required: List[str]
    r"""Array of required property names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class ResponseBodyJSONSchemaTypedDict(TypedDict):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: str
    r"""A description of what the response format is for. This will be shown to the user."""
    schema_: ResponseBodySchemaTypedDict
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class ResponseBodyJSONSchema(BaseModel):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: str
    r"""A description of what the response format is for. This will be shown to the user."""

    schema_: Annotated[ResponseBodySchema, pydantic.Field(alias="schema")]
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["strict"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyJSONSchemaToolTypedDict(TypedDict):
    r"""A tool that enforces structured output format using JSON Schema for consistent response formatting."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: CreateToolResponseBodyToolsType
    json_schema: ResponseBodyJSONSchemaTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[CreateToolResponseBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class ResponseBodyJSONSchemaTool(BaseModel):
    r"""A tool that enforces structured output format using JSON Schema for consistent response formatting."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: CreateToolResponseBodyToolsType

    json_schema: ResponseBodyJSONSchema

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KHKCN1SGQZFFKHNHRHFHRD5D"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[CreateToolResponseBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "display_name",
                "created_by_id",
                "updated_by_id",
                "status",
                "version_hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ResponseBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateToolResponseBodyType = Literal["function",]


CreateToolResponseBodyToolsResponse200ApplicationJSON1Type = Literal["object",]
r"""The type must be \"object\" """


class ResponseBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: CreateToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class ResponseBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: CreateToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class CreateToolResponseBodyFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[ResponseBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class CreateToolResponseBodyFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[ResponseBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["description", "strict", "parameters"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseBodyFunctionToolTypedDict(TypedDict):
    r"""A custom function tool that allows the model to call predefined functions with structured parameters."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: CreateToolResponseBodyType
    function: CreateToolResponseBodyFunctionTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[ResponseBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class ResponseBodyFunctionTool(BaseModel):
    r"""A custom function tool that allows the model to call predefined functions with structured parameters."""

    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: CreateToolResponseBodyType

    function: CreateToolResponseBodyFunction

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KHKCN1SE74Q5VT24YG8GHT60"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[ResponseBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "_id",
                "display_name",
                "created_by_id",
                "updated_by_id",
                "status",
                "version_hash",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


CreateToolResponseBodyTypedDict = TypeAliasType(
    "CreateToolResponseBodyTypedDict",
    Union[
        ResponseBodyFunctionToolTypedDict,
        ResponseBodyJSONSchemaToolTypedDict,
        ResponseBodyHTTPToolTypedDict,
        ResponseBodyMCPToolTypedDict,
        ResponseBodyCodeExecutionToolTypedDict,
    ],
)
r"""Successfully created the tool."""


CreateToolResponseBody = Annotated[
    Union[
        Annotated[ResponseBodyFunctionTool, Tag("function")],
        Annotated[ResponseBodyJSONSchemaTool, Tag("json_schema")],
        Annotated[ResponseBodyHTTPTool, Tag("http")],
        Annotated[ResponseBodyMCPTool, Tag("mcp")],
        Annotated[ResponseBodyCodeExecutionTool, Tag("code")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]
r"""Successfully created the tool."""


try:
    RequestBodyJSONSchema.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyCodeExecutionTool.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyTools.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyMCPTool.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyHTTPTool.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyJSONSchema.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyJSONSchemaTool.model_rebuild()
except NameError:
    pass
try:
    ResponseBodyFunctionTool.model_rebuild()
except NameError:
    pass
