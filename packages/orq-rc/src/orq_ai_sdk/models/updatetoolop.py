"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from pydantic import ConfigDict
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


UpdateToolRequestBodyToolsRequest5Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolRequestBodyToolsRequest5Type = Literal["code",]


UpdateToolRequestBodyToolsRequest5CodeToolType = Literal["object",]
r"""The type must be \"object\" """


class UpdateToolRequestBodyToolsParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: UpdateToolRequestBodyToolsRequest5CodeToolType
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class UpdateToolRequestBodyToolsParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: UpdateToolRequestBodyToolsRequest5CodeToolType
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


UpdateToolRequestBodyLanguage = Literal["python",]


class UpdateToolRequestBodyCodeToolTypedDict(TypedDict):
    language: UpdateToolRequestBodyLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[UpdateToolRequestBodyToolsParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolRequestBodyCodeTool(BaseModel):
    language: UpdateToolRequestBodyLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[UpdateToolRequestBodyToolsParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateCodeExecutionToolTypedDict(TypedDict):
    r"""Updates an existing code execution tool configuration."""

    type: UpdateToolRequestBodyToolsRequest5Type
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: NotRequired[str]
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: NotRequired[str]
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    status: NotRequired[UpdateToolRequestBodyToolsRequest5Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    code_tool: NotRequired[UpdateToolRequestBodyCodeToolTypedDict]


class UpdateCodeExecutionTool(BaseModel):
    r"""Updates an existing code execution tool configuration."""

    type: UpdateToolRequestBodyToolsRequest5Type

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: Optional[str] = None
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: Optional[str] = None
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    status: Optional[UpdateToolRequestBodyToolsRequest5Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    code_tool: Optional[UpdateToolRequestBodyCodeTool] = None


UpdateToolRequestBodyToolsRequest4Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolRequestBodyToolsRequest4Type = Literal["mcp",]


class UpdateToolRequestBodyHeadersTypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class UpdateToolRequestBodyHeaders(BaseModel):
    value: str

    encrypted: Optional[bool] = False


UpdateToolRequestBodyToolsRequest4McpType = Literal["object",]


class UpdateToolRequestBodyToolsSchemaTypedDict(TypedDict):
    type: UpdateToolRequestBodyToolsRequest4McpType
    properties: NotRequired[Dict[str, Any]]
    required: NotRequired[List[str]]


class UpdateToolRequestBodyToolsSchema(BaseModel):
    type: UpdateToolRequestBodyToolsRequest4McpType

    properties: Optional[Dict[str, Any]] = None

    required: Optional[List[str]] = None


class RequestBodyToolsTypedDict(TypedDict):
    name: str
    schema_: UpdateToolRequestBodyToolsSchemaTypedDict
    id: NotRequired[str]
    description: NotRequired[str]


class RequestBodyTools(BaseModel):
    name: str

    schema_: Annotated[UpdateToolRequestBodyToolsSchema, pydantic.Field(alias="schema")]

    id: Optional[str] = "01KABAYFY3PFP54H7MC3P1ZX48"

    description: Optional[str] = None


UpdateToolRequestBodyConnectionType = Literal[
    "http",
    "sse",
]
r"""The connection type used by the MCP server"""


class UpdateToolRequestBodyMcpTypedDict(TypedDict):
    server_url: NotRequired[str]
    r"""The MCP server URL (cached for execution)"""
    headers: NotRequired[Dict[str, UpdateToolRequestBodyHeadersTypedDict]]
    r"""HTTP headers for MCP server requests with encryption support"""
    tools: NotRequired[List[RequestBodyToolsTypedDict]]
    r"""Array of tools available from the MCP server"""
    connection_type: NotRequired[UpdateToolRequestBodyConnectionType]
    r"""The connection type used by the MCP server"""


class UpdateToolRequestBodyMcp(BaseModel):
    server_url: Optional[str] = None
    r"""The MCP server URL (cached for execution)"""

    headers: Optional[Dict[str, UpdateToolRequestBodyHeaders]] = None
    r"""HTTP headers for MCP server requests with encryption support"""

    tools: Optional[List[RequestBodyTools]] = None
    r"""Array of tools available from the MCP server"""

    connection_type: Optional[UpdateToolRequestBodyConnectionType] = None
    r"""The connection type used by the MCP server"""


class UpdateMCPToolTypedDict(TypedDict):
    r"""Updates an existing MCP tool configuration."""

    type: UpdateToolRequestBodyToolsRequest4Type
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: NotRequired[str]
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: NotRequired[str]
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    status: NotRequired[UpdateToolRequestBodyToolsRequest4Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    mcp: NotRequired[UpdateToolRequestBodyMcpTypedDict]


class UpdateMCPTool(BaseModel):
    r"""Updates an existing MCP tool configuration."""

    type: UpdateToolRequestBodyToolsRequest4Type

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: Optional[str] = None
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: Optional[str] = None
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    status: Optional[UpdateToolRequestBodyToolsRequest4Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    mcp: Optional[UpdateToolRequestBodyMcp] = None


UpdateToolRequestBodyToolsRequestStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolRequestBodyToolsRequestType = Literal["http",]


UpdateToolRequestBodyMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class UpdateToolHeaders2TypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class UpdateToolHeaders2(BaseModel):
    value: str

    encrypted: Optional[bool] = False


UpdateToolRequestBodyToolsHeadersTypedDict = TypeAliasType(
    "UpdateToolRequestBodyToolsHeadersTypedDict",
    Union[UpdateToolHeaders2TypedDict, str],
)


UpdateToolRequestBodyToolsHeaders = TypeAliasType(
    "UpdateToolRequestBodyToolsHeaders", Union[UpdateToolHeaders2, str]
)


class UpdateToolRequestBodyBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: UpdateToolRequestBodyMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, UpdateToolRequestBodyToolsHeadersTypedDict]]
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class UpdateToolRequestBodyBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: UpdateToolRequestBodyMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, UpdateToolRequestBodyToolsHeaders]] = None
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


UpdateToolRequestBodyToolsRequest3Type = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


UpdateToolRequestBodyDefaultValueTypedDict = TypeAliasType(
    "UpdateToolRequestBodyDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


UpdateToolRequestBodyDefaultValue = TypeAliasType(
    "UpdateToolRequestBodyDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class UpdateToolRequestBodyArgumentsTypedDict(TypedDict):
    type: UpdateToolRequestBodyToolsRequest3Type
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[UpdateToolRequestBodyDefaultValueTypedDict]
    r"""The default value of the argument."""


class UpdateToolRequestBodyArguments(BaseModel):
    type: UpdateToolRequestBodyToolsRequest3Type
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[UpdateToolRequestBodyDefaultValue] = None
    r"""The default value of the argument."""


class UpdateToolRequestBodyHTTPTypedDict(TypedDict):
    blueprint: UpdateToolRequestBodyBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, UpdateToolRequestBodyArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class UpdateToolRequestBodyHTTP(BaseModel):
    blueprint: UpdateToolRequestBodyBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, UpdateToolRequestBodyArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class UpdateHTTPToolTypedDict(TypedDict):
    r"""Updates an existing HTTP tool configuration."""

    type: UpdateToolRequestBodyToolsRequestType
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: NotRequired[str]
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: NotRequired[str]
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    status: NotRequired[UpdateToolRequestBodyToolsRequestStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    http: NotRequired[UpdateToolRequestBodyHTTPTypedDict]


class UpdateHTTPTool(BaseModel):
    r"""Updates an existing HTTP tool configuration."""

    type: UpdateToolRequestBodyToolsRequestType

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: Optional[str] = None
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: Optional[str] = None
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    status: Optional[UpdateToolRequestBodyToolsRequestStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    http: Optional[UpdateToolRequestBodyHTTP] = None


UpdateToolRequestBodyToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolRequestBodyToolsType = Literal["json_schema",]


class UpdateToolRequestBodySchemaTypedDict(TypedDict):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: str
    r"""The JSON Schema type"""
    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""
    required: List[str]
    r"""Array of required property names"""


class UpdateToolRequestBodySchema(BaseModel):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: str
    r"""The JSON Schema type"""

    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""

    required: List[str]
    r"""Array of required property names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class UpdateToolRequestBodyJSONSchemaTypedDict(TypedDict):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: str
    r"""A description of what the response format is for. This will be shown to the user."""
    schema_: UpdateToolRequestBodySchemaTypedDict
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class UpdateToolRequestBodyJSONSchema(BaseModel):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: str
    r"""A description of what the response format is for. This will be shown to the user."""

    schema_: Annotated[UpdateToolRequestBodySchema, pydantic.Field(alias="schema")]
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class UpdateJSONSchemaToolTypedDict(TypedDict):
    r"""Updates an existing JSON Schema tool configuration."""

    type: UpdateToolRequestBodyToolsType
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: NotRequired[str]
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: NotRequired[str]
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    status: NotRequired[UpdateToolRequestBodyToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    json_schema: NotRequired[UpdateToolRequestBodyJSONSchemaTypedDict]


class UpdateJSONSchemaTool(BaseModel):
    r"""Updates an existing JSON Schema tool configuration."""

    type: UpdateToolRequestBodyToolsType

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: Optional[str] = None
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: Optional[str] = None
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    status: Optional[UpdateToolRequestBodyToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    json_schema: Optional[UpdateToolRequestBodyJSONSchema] = None


UpdateToolRequestBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolRequestBodyType = Literal["function",]


UpdateToolRequestBodyToolsRequest1Type = Literal["object",]
r"""The type must be \"object\" """


class UpdateToolRequestBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: UpdateToolRequestBodyToolsRequest1Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class UpdateToolRequestBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: UpdateToolRequestBodyToolsRequest1Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class UpdateToolRequestBodyFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[UpdateToolRequestBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolRequestBodyFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[UpdateToolRequestBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateFunctionToolTypedDict(TypedDict):
    r"""Updates an existing function tool configuration."""

    type: UpdateToolRequestBodyType
    path: NotRequired[str]
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: NotRequired[str]
    r"""Unique key of the tool as it will be displayed in the UI"""
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    description: NotRequired[str]
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    status: NotRequired[UpdateToolRequestBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    function: NotRequired[UpdateToolRequestBodyFunctionTypedDict]


class UpdateFunctionTool(BaseModel):
    r"""Updates an existing function tool configuration."""

    type: UpdateToolRequestBodyType

    path: Optional[str] = None
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: Optional[str] = None
    r"""Unique key of the tool as it will be displayed in the UI"""

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    description: Optional[str] = None
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    status: Optional[UpdateToolRequestBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    function: Optional[UpdateToolRequestBodyFunction] = None


UpdateToolRequestBodyTypedDict = TypeAliasType(
    "UpdateToolRequestBodyTypedDict",
    Union[
        UpdateFunctionToolTypedDict,
        UpdateJSONSchemaToolTypedDict,
        UpdateHTTPToolTypedDict,
        UpdateMCPToolTypedDict,
        UpdateCodeExecutionToolTypedDict,
    ],
)
r"""The tool to update"""


UpdateToolRequestBody = TypeAliasType(
    "UpdateToolRequestBody",
    Union[
        UpdateFunctionTool,
        UpdateJSONSchemaTool,
        UpdateHTTPTool,
        UpdateMCPTool,
        UpdateCodeExecutionTool,
    ],
)
r"""The tool to update"""


class UpdateToolRequestTypedDict(TypedDict):
    tool_id: str
    request_body: NotRequired[UpdateToolRequestBodyTypedDict]
    r"""The tool to update"""


class UpdateToolRequest(BaseModel):
    tool_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]

    request_body: Annotated[
        Optional[UpdateToolRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None
    r"""The tool to update"""


class UpdateToolToolsResponseBodyData(BaseModel):
    error: str
    r"""Error message"""


@dataclass(unsafe_hash=True)
class UpdateToolToolsResponseBody(OrqError):
    r"""Tool not found."""

    data: UpdateToolToolsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: UpdateToolToolsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        message = body or raw_response.text
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolResponseBodyToolsResponse200ApplicationJSONType = Literal["code",]


UpdateToolResponseBodyToolsResponse200ApplicationJSON5Type = Literal["object",]
r"""The type must be \"object\" """


class UpdateToolResponseBodyToolsParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class UpdateToolResponseBodyToolsParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON5Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


UpdateToolResponseBodyLanguage = Literal["python",]


class UpdateToolResponseBodyCodeToolTypedDict(TypedDict):
    language: UpdateToolResponseBodyLanguage
    code: str
    r"""The code to execute."""
    parameters: NotRequired[UpdateToolResponseBodyToolsParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolResponseBodyCodeTool(BaseModel):
    language: UpdateToolResponseBodyLanguage

    code: str
    r"""The code to execute."""

    parameters: Optional[UpdateToolResponseBodyToolsParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolResponseBody5TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: UpdateToolResponseBodyToolsResponse200ApplicationJSONType
    code_tool: UpdateToolResponseBodyCodeToolTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class UpdateToolResponseBody5(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: UpdateToolResponseBodyToolsResponse200ApplicationJSONType

    code_tool: UpdateToolResponseBodyCodeTool

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFXT3KEN25GJ4TX40R2R"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus] = (
        "live"
    )
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


UpdateToolResponseBodyToolsResponse200Status = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolResponseBodyToolsResponse200Type = Literal["mcp",]


class UpdateToolResponseBodyHeadersTypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class UpdateToolResponseBodyHeaders(BaseModel):
    value: str

    encrypted: Optional[bool] = False


UpdateToolResponseBodyToolsResponse200ApplicationJSON4Type = Literal["object",]


class UpdateToolResponseBodyToolsSchemaTypedDict(TypedDict):
    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON4Type
    properties: NotRequired[Dict[str, Any]]
    required: NotRequired[List[str]]


class UpdateToolResponseBodyToolsSchema(BaseModel):
    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON4Type

    properties: Optional[Dict[str, Any]] = None

    required: Optional[List[str]] = None


class UpdateToolResponseBodyToolsTypedDict(TypedDict):
    name: str
    schema_: UpdateToolResponseBodyToolsSchemaTypedDict
    id: NotRequired[str]
    description: NotRequired[str]


class UpdateToolResponseBodyTools(BaseModel):
    name: str

    schema_: Annotated[
        UpdateToolResponseBodyToolsSchema, pydantic.Field(alias="schema")
    ]

    id: Optional[str] = "01KABAYFXS8119Q9NPMWZ75PS1"

    description: Optional[str] = None


UpdateToolResponseBodyConnectionType = Literal[
    "http",
    "sse",
]
r"""The connection type used by the MCP server"""


class UpdateToolResponseBodyMcpTypedDict(TypedDict):
    server_url: str
    r"""The MCP server URL (cached for execution)"""
    tools: List[UpdateToolResponseBodyToolsTypedDict]
    r"""Array of tools available from the MCP server"""
    connection_type: UpdateToolResponseBodyConnectionType
    r"""The connection type used by the MCP server"""
    headers: NotRequired[Dict[str, UpdateToolResponseBodyHeadersTypedDict]]
    r"""HTTP headers for MCP server requests with encryption support"""


class UpdateToolResponseBodyMcp(BaseModel):
    server_url: str
    r"""The MCP server URL (cached for execution)"""

    tools: List[UpdateToolResponseBodyTools]
    r"""Array of tools available from the MCP server"""

    connection_type: UpdateToolResponseBodyConnectionType
    r"""The connection type used by the MCP server"""

    headers: Optional[Dict[str, UpdateToolResponseBodyHeaders]] = None
    r"""HTTP headers for MCP server requests with encryption support"""


class UpdateToolResponseBody4TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: UpdateToolResponseBodyToolsResponse200Type
    mcp: UpdateToolResponseBodyMcpTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[UpdateToolResponseBodyToolsResponse200Status]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class UpdateToolResponseBody4(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: UpdateToolResponseBodyToolsResponse200Type

    mcp: UpdateToolResponseBodyMcp

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFXRHJ9B6737RCJP0FJR"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[UpdateToolResponseBodyToolsResponse200Status] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


UpdateToolResponseBodyToolsResponseStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolResponseBodyToolsResponseType = Literal["http",]


UpdateToolResponseBodyMethod = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class UpdateToolHeadersTools2TypedDict(TypedDict):
    value: str
    encrypted: NotRequired[bool]


class UpdateToolHeadersTools2(BaseModel):
    value: str

    encrypted: Optional[bool] = False


UpdateToolResponseBodyToolsHeadersTypedDict = TypeAliasType(
    "UpdateToolResponseBodyToolsHeadersTypedDict",
    Union[UpdateToolHeadersTools2TypedDict, str],
)


UpdateToolResponseBodyToolsHeaders = TypeAliasType(
    "UpdateToolResponseBodyToolsHeaders", Union[UpdateToolHeadersTools2, str]
)


class UpdateToolResponseBodyBlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: UpdateToolResponseBodyMethod
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, UpdateToolResponseBodyToolsHeadersTypedDict]]
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class UpdateToolResponseBodyBlueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: UpdateToolResponseBodyMethod
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, UpdateToolResponseBodyToolsHeaders]] = None
    r"""The headers to send with the request. Can be a string value or an object with value and encrypted properties."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


UpdateToolResponseBodyToolsResponse200ApplicationJSON3Type = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


UpdateToolResponseBodyDefaultValueTypedDict = TypeAliasType(
    "UpdateToolResponseBodyDefaultValueTypedDict", Union[str, float, bool]
)
r"""The default value of the argument."""


UpdateToolResponseBodyDefaultValue = TypeAliasType(
    "UpdateToolResponseBodyDefaultValue", Union[str, float, bool]
)
r"""The default value of the argument."""


class UpdateToolResponseBodyArgumentsTypedDict(TypedDict):
    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[UpdateToolResponseBodyDefaultValueTypedDict]
    r"""The default value of the argument."""


class UpdateToolResponseBodyArguments(BaseModel):
    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON3Type
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[UpdateToolResponseBodyDefaultValue] = None
    r"""The default value of the argument."""


class UpdateToolResponseBodyHTTPTypedDict(TypedDict):
    blueprint: UpdateToolResponseBodyBlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, UpdateToolResponseBodyArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class UpdateToolResponseBodyHTTP(BaseModel):
    blueprint: UpdateToolResponseBodyBlueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, UpdateToolResponseBodyArguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class UpdateToolResponseBody3TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: UpdateToolResponseBodyToolsResponseType
    http: UpdateToolResponseBodyHTTPTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[UpdateToolResponseBodyToolsResponseStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class UpdateToolResponseBody3(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: UpdateToolResponseBodyToolsResponseType

    http: UpdateToolResponseBodyHTTP

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFXP9997QRF6DDW8WXZ2"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[UpdateToolResponseBodyToolsResponseStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


UpdateToolResponseBodyToolsStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolResponseBodyToolsType = Literal["json_schema",]


class UpdateToolResponseBodySchemaTypedDict(TypedDict):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: str
    r"""The JSON Schema type"""
    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""
    required: List[str]
    r"""Array of required property names"""


class UpdateToolResponseBodySchema(BaseModel):
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: str
    r"""The JSON Schema type"""

    properties: Dict[str, Any]
    r"""The properties of the JSON Schema object"""

    required: List[str]
    r"""Array of required property names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class UpdateToolResponseBodyJSONSchemaTypedDict(TypedDict):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: str
    r"""A description of what the response format is for. This will be shown to the user."""
    schema_: UpdateToolResponseBodySchemaTypedDict
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class UpdateToolResponseBodyJSONSchema(BaseModel):
    name: str
    r"""The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: str
    r"""A description of what the response format is for. This will be shown to the user."""

    schema_: Annotated[UpdateToolResponseBodySchema, pydantic.Field(alias="schema")]
    r"""The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models."""


class UpdateToolResponseBody2TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: UpdateToolResponseBodyToolsType
    json_schema: UpdateToolResponseBodyJSONSchemaTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[UpdateToolResponseBodyToolsStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class UpdateToolResponseBody2(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: UpdateToolResponseBodyToolsType

    json_schema: UpdateToolResponseBodyJSONSchema

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFXM62KC83SVCBZ2B1S6"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[UpdateToolResponseBodyToolsStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


UpdateToolResponseBodyStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


UpdateToolResponseBodyType = Literal["function",]


UpdateToolResponseBodyToolsResponse200ApplicationJSON1Type = Literal["object",]
r"""The type must be \"object\" """


class UpdateToolResponseBodyParametersTypedDict(TypedDict):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """
    properties: Dict[str, Any]
    r"""The properties of the function parameters"""
    required: List[str]
    r"""Array of required parameter names"""


class UpdateToolResponseBodyParameters(BaseModel):
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, Any] = pydantic.Field(init=False)

    type: UpdateToolResponseBodyToolsResponse200ApplicationJSON1Type
    r"""The type must be \"object\" """

    properties: Dict[str, Any]
    r"""The properties of the function parameters"""

    required: List[str]
    r"""Array of required parameter names"""

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]


class UpdateToolResponseBodyFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[UpdateToolResponseBodyParametersTypedDict]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolResponseBodyFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[UpdateToolResponseBodyParameters] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class UpdateToolResponseBody1TypedDict(TypedDict):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    project_id: str
    workspace_id: str
    created: str
    updated: str
    type: UpdateToolResponseBodyType
    function: UpdateToolResponseBodyFunctionTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""
    created_by_id: NotRequired[str]
    r"""The id of the user that created the tool"""
    updated_by_id: NotRequired[str]
    r"""The id of the user that last updated the tool"""
    status: NotRequired[UpdateToolResponseBodyStatus]
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    version_hash: NotRequired[str]


class UpdateToolResponseBody1(BaseModel):
    path: str
    r"""Entity storage path in the format: `project/folder/subfolder/...`

    The first element identifies the project, followed by nested folders (auto-created as needed).

    With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
    """

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    project_id: str

    workspace_id: str

    created: str

    updated: str

    type: UpdateToolResponseBodyType

    function: UpdateToolResponseBodyFunction

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = (
        "tool_01KABAYFXKAMPRTKCWMKNAA8EK"
    )

    display_name: Optional[str] = None
    r"""The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used."""

    created_by_id: Optional[str] = None
    r"""The id of the user that created the tool"""

    updated_by_id: Optional[str] = None
    r"""The id of the user that last updated the tool"""

    status: Optional[UpdateToolResponseBodyStatus] = "live"
    r"""The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    version_hash: Optional[str] = None


UpdateToolResponseBodyTypedDict = TypeAliasType(
    "UpdateToolResponseBodyTypedDict",
    Union[
        UpdateToolResponseBody1TypedDict,
        UpdateToolResponseBody2TypedDict,
        UpdateToolResponseBody3TypedDict,
        UpdateToolResponseBody4TypedDict,
        UpdateToolResponseBody5TypedDict,
    ],
)
r"""Successfully updated the tool."""


UpdateToolResponseBody = TypeAliasType(
    "UpdateToolResponseBody",
    Union[
        UpdateToolResponseBody1,
        UpdateToolResponseBody2,
        UpdateToolResponseBody3,
        UpdateToolResponseBody4,
        UpdateToolResponseBody5,
    ],
)
r"""Successfully updated the tool."""
