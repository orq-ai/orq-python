"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .audiocontentpartschema import (
    AudioContentPartSchema,
    AudioContentPartSchemaTypedDict,
)
from .filecontentpartschema import FileContentPartSchema, FileContentPartSchemaTypedDict
from .imagecontentpartschema import (
    ImageContentPartSchema,
    ImageContentPartSchemaTypedDict,
)
from .reasoningpartschema import ReasoningPartSchema, ReasoningPartSchemaTypedDict
from .redactedreasoningpartschema import (
    RedactedReasoningPartSchema,
    RedactedReasoningPartSchemaTypedDict,
)
from .refusalpartschema import RefusalPartSchema, RefusalPartSchemaTypedDict
from .textcontentpartschema import TextContentPartSchema, TextContentPartSchemaTypedDict
from datetime import datetime
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    get_discriminator,
    parse_datetime,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ListDatasetDatapointsRequestTypedDict(TypedDict):
    dataset_id: str
    r"""The unique identifier of the dataset"""
    limit: NotRequired[int]
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""
    starting_after: NotRequired[str]
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""
    ending_before: NotRequired[str]
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""


class ListDatasetDatapointsRequest(BaseModel):
    dataset_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the dataset"""

    limit: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""

    starting_after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""

    ending_before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["limit", "starting_after", "ending_before"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsObject = Literal["list",]


ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole = Literal["tool",]
r"""The role of the messages author, in this case tool."""


ListDatasetDatapointsContentDatasetsResponse2TypedDict = TextContentPartSchemaTypedDict


ListDatasetDatapointsContentDatasetsResponse2 = TextContentPartSchema


ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContentTypedDict",
    Union[str, List[ListDatasetDatapointsContentDatasetsResponse2TypedDict]],
)
r"""The contents of the tool message."""


ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContent = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContent",
    Union[str, List[ListDatasetDatapointsContentDatasetsResponse2]],
)
r"""The contents of the tool message."""


ListDatasetDatapointsMessagesDatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


ListDatasetDatapointsMessagesTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class ListDatasetDatapointsMessagesCacheControlTypedDict(TypedDict):
    type: ListDatasetDatapointsMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[ListDatasetDatapointsMessagesTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class ListDatasetDatapointsMessagesCacheControl(BaseModel):
    type: ListDatasetDatapointsMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[ListDatasetDatapointsMessagesTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListDatasetDatapointsMessagesToolMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case tool."""
    content: (
        ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContentTypedDict
    )
    r"""The contents of the tool message."""
    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""
    cache_control: NotRequired[ListDatasetDatapointsMessagesCacheControlTypedDict]


class ListDatasetDatapointsMessagesToolMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case tool."""

    content: ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONContent
    r"""The contents of the tool message."""

    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""

    cache_control: Optional[ListDatasetDatapointsMessagesCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        nullable_fields = set(["tool_call_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListDatasetDatapointsContentDatasets2TypedDict = TypeAliasType(
    "ListDatasetDatapointsContentDatasets2TypedDict",
    Union[
        RefusalPartSchemaTypedDict,
        RedactedReasoningPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ReasoningPartSchemaTypedDict,
    ],
)


ListDatasetDatapointsContentDatasets2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[RefusalPartSchema, Tag("refusal")],
        Annotated[ReasoningPartSchema, Tag("reasoning")],
        Annotated[RedactedReasoningPartSchema, Tag("redacted_reasoning")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


ListDatasetDatapointsMessagesDatasetsResponse200ContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponse200ContentTypedDict",
    Union[str, List[ListDatasetDatapointsContentDatasets2TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


ListDatasetDatapointsMessagesDatasetsResponse200Content = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponse200Content",
    Union[str, List[ListDatasetDatapointsContentDatasets2]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


ListDatasetDatapointsMessagesDatasetsResponse200Role = Literal["assistant",]
r"""The role of the messages author, in this case `assistant`."""


class ListDatasetDatapointsMessagesAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class ListDatasetDatapointsMessagesAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


ListDatasetDatapointsMessagesType = Literal["function",]
r"""The type of the tool. Currently, only `function` is supported."""


class ListDatasetDatapointsMessagesFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class ListDatasetDatapointsMessagesFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListDatasetDatapointsMessagesToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: ListDatasetDatapointsMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: ListDatasetDatapointsMessagesFunctionTypedDict
    thought_signature: NotRequired[str]
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""


class ListDatasetDatapointsMessagesToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: ListDatasetDatapointsMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: ListDatasetDatapointsMessagesFunction

    thought_signature: Optional[str] = None
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["thought_signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListDatasetDatapointsMessagesAssistantMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[ListDatasetDatapointsMessagesDatasetsResponse200ContentTypedDict]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[ListDatasetDatapointsMessagesAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[ListDatasetDatapointsMessagesToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""


class ListDatasetDatapointsMessagesAssistantMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[
        ListDatasetDatapointsMessagesDatasetsResponse200Content
    ] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[ListDatasetDatapointsMessagesAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[ListDatasetDatapointsMessagesToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["content", "refusal", "name", "audio", "tool_calls"])
        nullable_fields = set(["content", "refusal", "audio"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ListDatasetDatapointsMessagesDatasetsResponseRole = Literal["user",]
r"""The role of the messages author, in this case `user`."""


ListDatasetDatapoints2Type = Literal["file",]
r"""The type of the content part. Always `file`."""


ListDatasetDatapoints2DatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


ListDatasetDatapoints2TTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class ListDatasetDatapoints2CacheControlTypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[ListDatasetDatapoints2TTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class ListDatasetDatapoints2CacheControl(BaseModel):
    type: ListDatasetDatapoints2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[ListDatasetDatapoints2TTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListDatasetDatapoints24TypedDict(TypedDict):
    type: ListDatasetDatapoints2Type
    r"""The type of the content part. Always `file`."""
    file: FileContentPartSchemaTypedDict
    r"""File data for the content part. Must contain either file_data or uri, but not both."""
    cache_control: NotRequired[ListDatasetDatapoints2CacheControlTypedDict]


class ListDatasetDatapoints24(BaseModel):
    type: ListDatasetDatapoints2Type
    r"""The type of the content part. Always `file`."""

    file: FileContentPartSchema
    r"""File data for the content part. Must contain either file_data or uri, but not both."""

    cache_control: Optional[ListDatasetDatapoints2CacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsContent2TypedDict = TypeAliasType(
    "ListDatasetDatapointsContent2TypedDict",
    Union[
        AudioContentPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ImageContentPartSchemaTypedDict,
        ListDatasetDatapoints24TypedDict,
    ],
)


ListDatasetDatapointsContent2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[ImageContentPartSchema, Tag("image_url")],
        Annotated[AudioContentPartSchema, Tag("input_audio")],
        Annotated[ListDatasetDatapoints24, Tag("file")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict",
    Union[str, List[ListDatasetDatapointsContent2TypedDict]],
)
r"""The contents of the user message."""


ListDatasetDatapointsMessagesDatasetsResponseContent = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponseContent",
    Union[str, List[ListDatasetDatapointsContent2]],
)
r"""The contents of the user message."""


class ListDatasetDatapointsMessagesUserMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `user`."""
    content: ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesUserMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `user`."""

    content: ListDatasetDatapointsMessagesDatasetsResponseContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsMessagesDatasetsRole = Literal["developer",]
r"""The role of the messages author, in this case  `developer`."""


ListDatasetDatapointsMessagesDatasetsContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the developer message."""


ListDatasetDatapointsMessagesDatasetsContent = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsContent",
    Union[str, List[TextContentPartSchema]],
)
r"""The contents of the developer message."""


class ListDatasetDatapointsMessagesDeveloperMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""
    content: ListDatasetDatapointsMessagesDatasetsContentTypedDict
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesDeveloperMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""

    content: ListDatasetDatapointsMessagesDatasetsContent
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsMessagesRole = Literal["system",]
r"""The role of the messages author, in this case `system`."""


ListDatasetDatapointsMessagesContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the system message."""


ListDatasetDatapointsMessagesContent = TypeAliasType(
    "ListDatasetDatapointsMessagesContent", Union[str, List[TextContentPartSchema]]
)
r"""The contents of the system message."""


class ListDatasetDatapointsMessagesSystemMessageTypedDict(TypedDict):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: ListDatasetDatapointsMessagesRole
    r"""The role of the messages author, in this case `system`."""
    content: ListDatasetDatapointsMessagesContentTypedDict
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesSystemMessage(BaseModel):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: ListDatasetDatapointsMessagesRole
    r"""The role of the messages author, in this case `system`."""

    content: ListDatasetDatapointsMessagesContent
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsMessagesTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesTypedDict",
    Union[
        ListDatasetDatapointsMessagesSystemMessageTypedDict,
        ListDatasetDatapointsMessagesDeveloperMessageTypedDict,
        ListDatasetDatapointsMessagesUserMessageTypedDict,
        ListDatasetDatapointsMessagesToolMessageTypedDict,
        ListDatasetDatapointsMessagesAssistantMessageTypedDict,
    ],
)


ListDatasetDatapointsMessages = Annotated[
    Union[
        Annotated[ListDatasetDatapointsMessagesSystemMessage, Tag("system")],
        Annotated[ListDatasetDatapointsMessagesDeveloperMessage, Tag("developer")],
        Annotated[ListDatasetDatapointsMessagesUserMessage, Tag("user")],
        Annotated[ListDatasetDatapointsMessagesAssistantMessage, Tag("assistant")],
        Annotated[ListDatasetDatapointsMessagesToolMessage, Tag("tool")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


ListDatasetDatapointsEvaluationsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


ListDatasetDatapointsEvaluationsDatasetsSource = Literal[
    "orq",
    "external",
]


ListDatasetDatapointsEvaluationsDatasetsType = Literal["string_array",]


class ListDatasetDatapointsEvaluations3TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: ListDatasetDatapointsEvaluationsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: ListDatasetDatapointsEvaluationsDatasetsType
    values: List[str]
    source: NotRequired[ListDatasetDatapointsEvaluationsDatasetsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class ListDatasetDatapointsEvaluations3(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: ListDatasetDatapointsEvaluationsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: ListDatasetDatapointsEvaluationsDatasetsType

    values: List[str]

    source: Optional[ListDatasetDatapointsEvaluationsDatasetsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-10T13:35:53.301Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsEvaluationsDatasetsResponseEvaluationType = Literal[
    "human_review",
]
r"""The type of evaluation"""


ListDatasetDatapointsEvaluationsSource = Literal[
    "orq",
    "external",
]


ListDatasetDatapointsEvaluationsType = Literal["number",]


class ListDatasetDatapointsEvaluations2TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: ListDatasetDatapointsEvaluationsDatasetsResponseEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: ListDatasetDatapointsEvaluationsType
    value: float
    source: NotRequired[ListDatasetDatapointsEvaluationsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class ListDatasetDatapointsEvaluations2(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: ListDatasetDatapointsEvaluationsDatasetsResponseEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: ListDatasetDatapointsEvaluationsType

    value: float

    source: Optional[ListDatasetDatapointsEvaluationsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-10T13:35:53.300Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsEvaluationsDatasetsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


ListDatasetDatapointsEvaluationsDatasetsResponseSource = Literal[
    "orq",
    "external",
]


ListDatasetDatapointsEvaluationsDatasetsResponseType = Literal["string",]


class ListDatasetDatapointsEvaluations1TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: ListDatasetDatapointsEvaluationsDatasetsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: ListDatasetDatapointsEvaluationsDatasetsResponseType
    value: str
    source: NotRequired[ListDatasetDatapointsEvaluationsDatasetsResponseSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class ListDatasetDatapointsEvaluations1(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: ListDatasetDatapointsEvaluationsDatasetsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: ListDatasetDatapointsEvaluationsDatasetsResponseType

    value: str

    source: Optional[ListDatasetDatapointsEvaluationsDatasetsResponseSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-10T13:35:53.299Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


ListDatasetDatapointsEvaluationsTypedDict = TypeAliasType(
    "ListDatasetDatapointsEvaluationsTypedDict",
    Union[
        ListDatasetDatapointsEvaluations1TypedDict,
        ListDatasetDatapointsEvaluations2TypedDict,
        ListDatasetDatapointsEvaluations3TypedDict,
    ],
)


ListDatasetDatapointsEvaluations = Annotated[
    Union[
        Annotated[ListDatasetDatapointsEvaluations1, Tag("string")],
        Annotated[ListDatasetDatapointsEvaluations2, Tag("number")],
        Annotated[ListDatasetDatapointsEvaluations3, Tag("string_array")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class ListDatasetDatapointsDataTypedDict(TypedDict):
    id: str
    r"""The unique identifier of the dataset item"""
    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""
    dataset_id: str
    r"""The unique identifier of the dataset"""
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[ListDatasetDatapointsMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]
    evaluations: NotRequired[List[ListDatasetDatapointsEvaluationsTypedDict]]
    r"""Evaluations associated with the datapoint"""
    snapshot_version: NotRequired[str]
    r"""The version of the dataset snapshot"""
    created_by_id: NotRequired[str]
    r"""The unique identifier of the user who created the dataset"""
    updated_by_id: NotRequired[str]
    r"""The unique identifier of the user who last updated the dataset"""
    created: NotRequired[datetime]
    r"""The date and time the resource was created"""
    updated: NotRequired[datetime]
    r"""The date and time the resource was last updated"""


class ListDatasetDatapointsData(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the dataset item"""

    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""

    dataset_id: str
    r"""The unique identifier of the dataset"""

    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[ListDatasetDatapointsMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    evaluations: Optional[List[ListDatasetDatapointsEvaluations]] = None
    r"""Evaluations associated with the datapoint"""

    snapshot_version: Optional[str] = None
    r"""The version of the dataset snapshot"""

    created_by_id: Optional[str] = None
    r"""The unique identifier of the user who created the dataset"""

    updated_by_id: Optional[str] = None
    r"""The unique identifier of the user who last updated the dataset"""

    created: Optional[datetime] = None
    r"""The date and time the resource was created"""

    updated: Optional[datetime] = parse_datetime("2026-02-10T13:35:38.743Z")
    r"""The date and time the resource was last updated"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "inputs",
                "messages",
                "expected_output",
                "evaluations",
                "snapshot_version",
                "created_by_id",
                "updated_by_id",
                "created",
                "updated",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ListDatasetDatapointsResponseBodyTypedDict(TypedDict):
    r"""Datapoints retrieved successfully. Returns a paginated list of datapoints."""

    object: ListDatasetDatapointsObject
    data: List[ListDatasetDatapointsDataTypedDict]
    has_more: bool


class ListDatasetDatapointsResponseBody(BaseModel):
    r"""Datapoints retrieved successfully. Returns a paginated list of datapoints."""

    object: ListDatasetDatapointsObject

    data: List[ListDatasetDatapointsData]

    has_more: bool
