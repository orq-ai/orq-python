"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata
import pydantic
from pydantic import model_serializer
from typing import Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class GetOneKnowledgeRequestTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base"""


class GetOneKnowledgeRequest(BaseModel):
    knowledge_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""Unique identifier of the knowledge base"""


class GetOneKnowledgeMetadataTypedDict(TypedDict):
    word_count: NotRequired[int]
    document_count: NotRequired[int]
    sentences_count: NotRequired[int]


class GetOneKnowledgeMetadata(BaseModel):
    word_count: Optional[int] = 0

    document_count: Optional[int] = 0

    sentences_count: Optional[int] = 0


GetOneKnowledgeRetrievalSettingsKnowledgeResponseType = Literal["hybrid_search"]

GetOneKnowledgeRetrievalSettingsKnowledgeResponseProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelType = Literal["rerank"]


class GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict(
    TypedDict
):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[GetOneKnowledgeRetrievalSettingsKnowledgeResponseProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelType]
    model_parameters: NotRequired[
        GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class GetOneKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[GetOneKnowledgeRetrievalSettingsKnowledgeResponseProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelType] = (
        None
    )

    model_parameters: Optional[
        GetOneKnowledgeRetrievalSettingsKnowledgeResponseModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetOneKnowledgeRetrievalSettings3TypedDict(TypedDict):
    type: GetOneKnowledgeRetrievalSettingsKnowledgeResponseType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[GetOneKnowledgeRetrievalSettingsKnowledgeResponseRerankConfigTypedDict]
    ]


class GetOneKnowledgeRetrievalSettings3(BaseModel):
    type: GetOneKnowledgeRetrievalSettingsKnowledgeResponseType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        GetOneKnowledgeRetrievalSettingsKnowledgeResponseRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetOneKnowledgeRetrievalSettingsKnowledgeType = Literal["keyword_search"]

GetOneKnowledgeRetrievalSettingsKnowledgeProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

GetOneKnowledgeRetrievalSettingsKnowledgeModelType = Literal["rerank"]


class GetOneKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsKnowledgeModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[GetOneKnowledgeRetrievalSettingsKnowledgeProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[GetOneKnowledgeRetrievalSettingsKnowledgeModelType]
    model_parameters: NotRequired[
        GetOneKnowledgeRetrievalSettingsKnowledgeModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class GetOneKnowledgeRetrievalSettingsKnowledgeRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[GetOneKnowledgeRetrievalSettingsKnowledgeProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[GetOneKnowledgeRetrievalSettingsKnowledgeModelType] = None

    model_parameters: Optional[
        GetOneKnowledgeRetrievalSettingsKnowledgeModelParameters
    ] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetOneKnowledgeRetrievalSettings2TypedDict(TypedDict):
    type: GetOneKnowledgeRetrievalSettingsKnowledgeType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[GetOneKnowledgeRetrievalSettingsKnowledgeRerankConfigTypedDict]
    ]


class GetOneKnowledgeRetrievalSettings2(BaseModel):
    type: GetOneKnowledgeRetrievalSettingsKnowledgeType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[
        GetOneKnowledgeRetrievalSettingsKnowledgeRerankConfig
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetOneKnowledgeRetrievalSettingsType = Literal["vector_search"]

GetOneKnowledgeRetrievalSettingsProvider = Literal[
    "cohere",
    "openai",
    "anthropic",
    "huggingface",
    "replicate",
    "google",
    "google-ai",
    "azure",
    "aws",
    "anyscale",
    "perplexity",
    "groq",
    "fal",
    "leonardoai",
    "nvidia",
    "jina",
    "togetherai",
    "elevenlabs",
]

GetOneKnowledgeRetrievalSettingsModelType = Literal["rerank"]


class GetOneKnowledgeRetrievalSettingsModelParametersTypedDict(TypedDict):
    threshold: NotRequired[float]
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsModelParameters(BaseModel):
    threshold: Optional[float] = None
    r"""The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned"""


class GetOneKnowledgeRetrievalSettingsRerankConfigTypedDict(TypedDict):
    enabled: NotRequired[bool]
    provider: NotRequired[GetOneKnowledgeRetrievalSettingsProvider]
    model: NotRequired[str]
    r"""The name of the model to use"""
    model_db_id: NotRequired[str]
    r"""The ID of the model in the database"""
    model_type: NotRequired[GetOneKnowledgeRetrievalSettingsModelType]
    model_parameters: NotRequired[
        GetOneKnowledgeRetrievalSettingsModelParametersTypedDict
    ]
    integration_id: NotRequired[Nullable[str]]
    r"""The id of the resource"""


class GetOneKnowledgeRetrievalSettingsRerankConfig(BaseModel):
    enabled: Optional[bool] = None

    provider: Optional[GetOneKnowledgeRetrievalSettingsProvider] = None

    model: Optional[str] = None
    r"""The name of the model to use"""

    model_db_id: Optional[str] = None
    r"""The ID of the model in the database"""

    model_type: Optional[GetOneKnowledgeRetrievalSettingsModelType] = None

    model_parameters: Optional[GetOneKnowledgeRetrievalSettingsModelParameters] = None

    integration_id: OptionalNullable[str] = UNSET
    r"""The id of the resource"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "enabled",
            "provider",
            "model",
            "model_db_id",
            "model_type",
            "model_parameters",
            "integration_id",
        ]
        nullable_fields = ["integration_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetOneKnowledgeRetrievalSettings1TypedDict(TypedDict):
    type: GetOneKnowledgeRetrievalSettingsType
    top_k: NotRequired[int]
    r"""Used to filter chunks that are most similar to the query"""
    threshold: NotRequired[float]
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""
    rerank_config: NotRequired[
        Nullable[GetOneKnowledgeRetrievalSettingsRerankConfigTypedDict]
    ]


class GetOneKnowledgeRetrievalSettings1(BaseModel):
    type: GetOneKnowledgeRetrievalSettingsType

    top_k: Optional[int] = 5
    r"""Used to filter chunks that are most similar to the query"""

    threshold: Optional[float] = 0
    r"""Used to filter chunks that are most similar to the query. A value of `0` will be consider disabled."""

    rerank_config: OptionalNullable[GetOneKnowledgeRetrievalSettingsRerankConfig] = (
        UNSET
    )

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["top_k", "threshold", "rerank_config"]
        nullable_fields = ["rerank_config"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


GetOneKnowledgeRetrievalSettingsTypedDict = TypeAliasType(
    "GetOneKnowledgeRetrievalSettingsTypedDict",
    Union[
        GetOneKnowledgeRetrievalSettings1TypedDict,
        GetOneKnowledgeRetrievalSettings2TypedDict,
        GetOneKnowledgeRetrievalSettings3TypedDict,
    ],
)


GetOneKnowledgeRetrievalSettings = TypeAliasType(
    "GetOneKnowledgeRetrievalSettings",
    Union[
        GetOneKnowledgeRetrievalSettings1,
        GetOneKnowledgeRetrievalSettings2,
        GetOneKnowledgeRetrievalSettings3,
    ],
)


class GetOneKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Knowledge Base object"""

    id: str
    r"""The unique identifier of the knowledge base."""
    created_by_id: str
    r"""The id of the resource"""
    created: str
    r"""The creation date of the knowledge base."""
    key: str
    r"""The unique key of the knowledge base."""
    metadata: GetOneKnowledgeMetadataTypedDict
    model: str
    r"""The embeddings model used for the knowledge base."""
    retrieval_settings: GetOneKnowledgeRetrievalSettingsTypedDict
    update_by_id: str
    r"""The id of the resource"""
    updated: str
    r"""The last update date of the knowledge base."""
    description: NotRequired[str]
    r"""The description of the knowledge base."""
    path: NotRequired[str]
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""


class GetOneKnowledgeResponseBody(BaseModel):
    r"""Knowledge Base object"""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the knowledge base."""

    created_by_id: str
    r"""The id of the resource"""

    created: str
    r"""The creation date of the knowledge base."""

    key: str
    r"""The unique key of the knowledge base."""

    metadata: GetOneKnowledgeMetadata

    model: str
    r"""The embeddings model used for the knowledge base."""

    retrieval_settings: GetOneKnowledgeRetrievalSettings

    update_by_id: str
    r"""The id of the resource"""

    updated: str
    r"""The last update date of the knowledge base."""

    description: Optional[str] = None
    r"""The description of the knowledge base."""

    path: Optional[str] = None
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
