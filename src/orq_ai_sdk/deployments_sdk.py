"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .sdkconfiguration import SDKConfiguration
from orq_ai_sdk import models, utils
from orq_ai_sdk._hooks import HookContext
from orq_ai_sdk.metrics import Metrics
from orq_ai_sdk.types import OptionalNullable, UNSET
from orq_ai_sdk.utils import eventstreaming, get_security_from_env
from typing import Any, Dict, List, Mapping, Optional, Union


class DeploymentsSDK(BaseSDK):
    metrics: Metrics

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        BaseSDK.__init__(self, sdk_config)
        self.sdk_configuration = sdk_config
        self._init_sdks()

    def _init_sdks(self):
        self.metrics = Metrics(self.sdk_configuration)

    def list(
        self,
        *,
        limit: Optional[float] = 10,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentsResponseBody]:
        r"""List all deployments

        Returns a list of your deployments. The deployments are returned sorted by creation date, with the most recent deployments appearing first.

        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
        :param starting_after: A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
        :param ending_before: A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentsRequest(
            limit=limit,
            starting_after=starting_after,
            ending_before=ending_before,
        )

        req = self._build_request(
            method="GET",
            path="/v2/deployments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="Deployments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentsResponseBody]
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.HonoAPIErrorData)
            raise models.HonoAPIError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_async(
        self,
        *,
        limit: Optional[float] = 10,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentsResponseBody]:
        r"""List all deployments

        Returns a list of your deployments. The deployments are returned sorted by creation date, with the most recent deployments appearing first.

        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
        :param starting_after: A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
        :param ending_before: A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentsRequest(
            limit=limit,
            starting_after=starting_after,
            ending_before=ending_before,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/deployments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="Deployments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentsResponseBody]
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(http_res.text, models.HonoAPIErrorData)
            raise models.HonoAPIError(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_config(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[
                Dict[str, models.DeploymentGetConfigInputs],
                Dict[str, models.DeploymentGetConfigInputsTypedDict],
            ]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[
                List[models.DeploymentGetConfigPrefixMessages],
                List[models.DeploymentGetConfigPrefixMessagesTypedDict],
            ]
        ] = None,
        messages: Optional[
            Union[
                List[models.DeploymentGetConfigMessages],
                List[models.DeploymentGetConfigMessagesTypedDict],
            ]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[
                List[models.DeploymentGetConfigDocuments],
                List[models.DeploymentGetConfigDocumentsTypedDict],
            ]
        ] = None,
        invoke_options: Optional[
            Union[
                models.DeploymentGetConfigInvokeOptions,
                models.DeploymentGetConfigInvokeOptionsTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models.DeploymentGetConfigThread,
                models.DeploymentGetConfigThreadTypedDict,
            ]
        ] = None,
        knowledge_filter: Optional[
            Union[
                models.DeploymentGetConfigKnowledgeFilter,
                models.DeploymentGetConfigKnowledgeFilterTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentGetConfigResponseBody]:
        r"""Get config

        Retrieve the deployment configuration

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentGetConfigRequestBody(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages,
                Optional[List[models.DeploymentGetConfigPrefixMessages]],
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.DeploymentGetConfigMessages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.DeploymentGetConfigDocuments]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.DeploymentGetConfigInvokeOptions]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.DeploymentGetConfigThread]
            ),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.DeploymentGetConfigKnowledgeFilter]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/deployments/get_config",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeploymentGetConfigRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentGetConfig",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentGetConfigResponseBody]
            )
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_config_async(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[
                Dict[str, models.DeploymentGetConfigInputs],
                Dict[str, models.DeploymentGetConfigInputsTypedDict],
            ]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[
                List[models.DeploymentGetConfigPrefixMessages],
                List[models.DeploymentGetConfigPrefixMessagesTypedDict],
            ]
        ] = None,
        messages: Optional[
            Union[
                List[models.DeploymentGetConfigMessages],
                List[models.DeploymentGetConfigMessagesTypedDict],
            ]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[
                List[models.DeploymentGetConfigDocuments],
                List[models.DeploymentGetConfigDocumentsTypedDict],
            ]
        ] = None,
        invoke_options: Optional[
            Union[
                models.DeploymentGetConfigInvokeOptions,
                models.DeploymentGetConfigInvokeOptionsTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models.DeploymentGetConfigThread,
                models.DeploymentGetConfigThreadTypedDict,
            ]
        ] = None,
        knowledge_filter: Optional[
            Union[
                models.DeploymentGetConfigKnowledgeFilter,
                models.DeploymentGetConfigKnowledgeFilterTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentGetConfigResponseBody]:
        r"""Get config

        Retrieve the deployment configuration

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentGetConfigRequestBody(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages,
                Optional[List[models.DeploymentGetConfigPrefixMessages]],
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.DeploymentGetConfigMessages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.DeploymentGetConfigDocuments]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.DeploymentGetConfigInvokeOptions]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.DeploymentGetConfigThread]
            ),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.DeploymentGetConfigKnowledgeFilter]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/deployments/get_config",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeploymentGetConfigRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentGetConfig",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["401", "4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentGetConfigResponseBody]
            )
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, ["401", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def invoke(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[Dict[str, models.Inputs], Dict[str, models.InputsTypedDict]]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[List[models.PrefixMessages], List[models.PrefixMessagesTypedDict]]
        ] = None,
        messages: Optional[
            Union[List[models.Messages], List[models.MessagesTypedDict]]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[List[models.Documents], List[models.DocumentsTypedDict]]
        ] = None,
        invoke_options: Optional[
            Union[models.InvokeOptions, models.InvokeOptionsTypedDict]
        ] = None,
        thread: Optional[Union[models.Thread, models.ThreadTypedDict]] = None,
        knowledge_filter: Optional[
            Union[models.KnowledgeFilter, models.KnowledgeFilterTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentInvokeResponseBody]:
        r"""Invoke

        Invoke a deployment with a given payload

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.Deployments(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages, Optional[List[models.PrefixMessages]]
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.Messages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.Documents]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.InvokeOptions]
            ),
            thread=utils.get_pydantic_model(thread, Optional[models.Thread]),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.KnowledgeFilter]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/deployments/invoke",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeploymentInvokeGlobals(
                environment=self.sdk_configuration.globals.environment,
                contact_id=self.sdk_configuration.globals.contact_id,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.Deployments
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentInvoke",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentInvokeResponseBody]
            )
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def invoke_async(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[Dict[str, models.Inputs], Dict[str, models.InputsTypedDict]]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[List[models.PrefixMessages], List[models.PrefixMessagesTypedDict]]
        ] = None,
        messages: Optional[
            Union[List[models.Messages], List[models.MessagesTypedDict]]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[List[models.Documents], List[models.DocumentsTypedDict]]
        ] = None,
        invoke_options: Optional[
            Union[models.InvokeOptions, models.InvokeOptionsTypedDict]
        ] = None,
        thread: Optional[Union[models.Thread, models.ThreadTypedDict]] = None,
        knowledge_filter: Optional[
            Union[models.KnowledgeFilter, models.KnowledgeFilterTypedDict]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.DeploymentInvokeResponseBody]:
        r"""Invoke

        Invoke a deployment with a given payload

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.Deployments(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages, Optional[List[models.PrefixMessages]]
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.Messages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.Documents]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.InvokeOptions]
            ),
            thread=utils.get_pydantic_model(thread, Optional[models.Thread]),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.KnowledgeFilter]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/deployments/invoke",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            _globals=models.DeploymentInvokeGlobals(
                environment=self.sdk_configuration.globals.environment,
                contact_id=self.sdk_configuration.globals.contact_id,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.Deployments
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentInvoke",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.DeploymentInvokeResponseBody]
            )
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def stream(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[
                Dict[str, models.DeploymentStreamInputs],
                Dict[str, models.DeploymentStreamInputsTypedDict],
            ]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[
                List[models.DeploymentStreamPrefixMessages],
                List[models.DeploymentStreamPrefixMessagesTypedDict],
            ]
        ] = None,
        messages: Optional[
            Union[
                List[models.DeploymentStreamMessages],
                List[models.DeploymentStreamMessagesTypedDict],
            ]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[
                List[models.DeploymentStreamDocuments],
                List[models.DeploymentStreamDocumentsTypedDict],
            ]
        ] = None,
        invoke_options: Optional[
            Union[
                models.DeploymentStreamInvokeOptions,
                models.DeploymentStreamInvokeOptionsTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[models.DeploymentStreamThread, models.DeploymentStreamThreadTypedDict]
        ] = None,
        knowledge_filter: Optional[
            Union[
                models.DeploymentStreamKnowledgeFilter,
                models.DeploymentStreamKnowledgeFilterTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStream[models.DeploymentStreamResponseBody]]:
        r"""Stream

        Stream deployment generation. Only supported for completions and chat completions.

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentStreamRequestBody(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages, Optional[List[models.DeploymentStreamPrefixMessages]]
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.DeploymentStreamMessages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.DeploymentStreamDocuments]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.DeploymentStreamInvokeOptions]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.DeploymentStreamThread]
            ),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.DeploymentStreamKnowledgeFilter]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/deployments/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            _globals=models.DeploymentStreamGlobals(
                environment=self.sdk_configuration.globals.environment,
                contact_id=self.sdk_configuration.globals.contact_id,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeploymentStreamRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStream(
                http_res,
                lambda raw: utils.unmarshal_json(
                    raw, models.DeploymentStreamResponseBody
                ),
                sentinel="[DONE]",
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def stream_async(
        self,
        *,
        key: str,
        inputs: Optional[
            Union[
                Dict[str, models.DeploymentStreamInputs],
                Dict[str, models.DeploymentStreamInputsTypedDict],
            ]
        ] = None,
        context: Optional[Dict[str, Any]] = None,
        prefix_messages: Optional[
            Union[
                List[models.DeploymentStreamPrefixMessages],
                List[models.DeploymentStreamPrefixMessagesTypedDict],
            ]
        ] = None,
        messages: Optional[
            Union[
                List[models.DeploymentStreamMessages],
                List[models.DeploymentStreamMessagesTypedDict],
            ]
        ] = None,
        file_ids: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        extra_params: Optional[Dict[str, Any]] = None,
        documents: Optional[
            Union[
                List[models.DeploymentStreamDocuments],
                List[models.DeploymentStreamDocumentsTypedDict],
            ]
        ] = None,
        invoke_options: Optional[
            Union[
                models.DeploymentStreamInvokeOptions,
                models.DeploymentStreamInvokeOptionsTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[models.DeploymentStreamThread, models.DeploymentStreamThreadTypedDict]
        ] = None,
        knowledge_filter: Optional[
            Union[
                models.DeploymentStreamKnowledgeFilter,
                models.DeploymentStreamKnowledgeFilterTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStreamAsync[models.DeploymentStreamResponseBody]]:
        r"""Stream

        Stream deployment generation. Only supported for completions and chat completions.

        :param key: The deployment key to invoke
        :param inputs: Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration
        :param prefix_messages: A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
        :param messages: A list of messages to send to the deployment.
        :param file_ids: A list of file IDs that are associated with the deployment request.
        :param metadata: Key-value pairs that you want to attach to the log generated by this request.
        :param extra_params: Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
        :param documents: A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
        :param invoke_options:
        :param thread:
        :param knowledge_filter: A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeploymentStreamRequestBody(
            key=key,
            inputs=inputs,
            context=context,
            prefix_messages=utils.get_pydantic_model(
                prefix_messages, Optional[List[models.DeploymentStreamPrefixMessages]]
            ),
            messages=utils.get_pydantic_model(
                messages, Optional[List[models.DeploymentStreamMessages]]
            ),
            file_ids=file_ids,
            metadata=metadata,
            extra_params=extra_params,
            documents=utils.get_pydantic_model(
                documents, Optional[List[models.DeploymentStreamDocuments]]
            ),
            invoke_options=utils.get_pydantic_model(
                invoke_options, Optional[models.DeploymentStreamInvokeOptions]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.DeploymentStreamThread]
            ),
            knowledge_filter=utils.get_pydantic_model(
                knowledge_filter, Optional[models.DeploymentStreamKnowledgeFilter]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/deployments/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            _globals=models.DeploymentStreamGlobals(
                environment=self.sdk_configuration.globals.environment,
                contact_id=self.sdk_configuration.globals.contact_id,
            ),
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DeploymentStreamRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeploymentStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStreamAsync(
                http_res,
                lambda raw: utils.unmarshal_json(
                    raw, models.DeploymentStreamResponseBody
                ),
                sentinel="[DONE]",
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_experiment(
        self,
        *,
        deployment_key: str,
        experiment_key: str,
        dataset_id: str,
        type_: models.CreateDeploymentExperimentType,
        evaluators: Optional[List[str]] = None,
        path: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.CreateDeploymentExperimentResponseBody]:
        r"""Create an experiment from a deployment

        Create an experiment from a deployment

        :param deployment_key: Deployment Key
        :param experiment_key: The unique key of the experiment
        :param dataset_id: The id of the dataset to run the experiment on
        :param type:
        :param evaluators: The list of evaluators to use for the experiment. You can apply multiple evaluators to the same experiment. By default we always consider latency and cost as evaluators.
        :param path: The path where the experiment needs to be stored. If not provided, the experiment will be stored in the same path of the dataset used for the experiment.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration. If not provided, the default variant of the deployment will be used to create the experiment
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDeploymentExperimentRequest(
            deployment_key=deployment_key,
            request_body=models.CreateDeploymentExperimentRequestBody(
                experiment_key=experiment_key,
                evaluators=evaluators,
                path=path,
                dataset_id=dataset_id,
                type=type_,
                context=context,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/deployments/{deployment_key}/experiment",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.CreateDeploymentExperimentRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateDeploymentExperiment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.CreateDeploymentExperimentResponseBody]
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_experiment_async(
        self,
        *,
        deployment_key: str,
        experiment_key: str,
        dataset_id: str,
        type_: models.CreateDeploymentExperimentType,
        evaluators: Optional[List[str]] = None,
        path: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.CreateDeploymentExperimentResponseBody]:
        r"""Create an experiment from a deployment

        Create an experiment from a deployment

        :param deployment_key: Deployment Key
        :param experiment_key: The unique key of the experiment
        :param dataset_id: The id of the dataset to run the experiment on
        :param type:
        :param evaluators: The list of evaluators to use for the experiment. You can apply multiple evaluators to the same experiment. By default we always consider latency and cost as evaluators.
        :param path: The path where the experiment needs to be stored. If not provided, the experiment will be stored in the same path of the dataset used for the experiment.
        :param context: Key-value pairs that match your data model and fields declared in your deployment routing configuration. If not provided, the default variant of the deployment will be used to create the experiment
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateDeploymentExperimentRequest(
            deployment_key=deployment_key,
            request_body=models.CreateDeploymentExperimentRequestBody(
                experiment_key=experiment_key,
                evaluators=evaluators,
                path=path,
                dataset_id=dataset_id,
                type=type_,
                context=context,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/deployments/{deployment_key}/experiment",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.CreateDeploymentExperimentRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateDeploymentExperiment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, Optional[models.CreateDeploymentExperimentResponseBody]
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
