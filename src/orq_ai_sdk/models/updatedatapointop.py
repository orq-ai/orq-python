"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .audiocontentpartschema import (
    AudioContentPartSchema,
    AudioContentPartSchemaTypedDict,
)
from .filecontentpartschema import FileContentPartSchema, FileContentPartSchemaTypedDict
from .imagecontentpartschema import (
    ImageContentPartSchema,
    ImageContentPartSchemaTypedDict,
)
from .reasoningpartschema import ReasoningPartSchema, ReasoningPartSchemaTypedDict
from .redactedreasoningpartschema import (
    RedactedReasoningPartSchema,
    RedactedReasoningPartSchemaTypedDict,
)
from .refusalpartschema import RefusalPartSchema, RefusalPartSchemaTypedDict
from .textcontentpartschema import TextContentPartSchema, TextContentPartSchemaTypedDict
from datetime import datetime
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
    parse_datetime,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


UpdateDatapointMessagesDatasetsRequestRequestBody5Role = Literal["tool",]
r"""The role of the messages author, in this case tool."""


UpdateDatapointContentDatasetsRequest2TypedDict = TextContentPartSchemaTypedDict


UpdateDatapointContentDatasetsRequest2 = TextContentPartSchema


UpdateDatapointMessagesDatasetsRequestRequestBody5ContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestRequestBody5ContentTypedDict",
    Union[str, List[UpdateDatapointContentDatasetsRequest2TypedDict]],
)
r"""The contents of the tool message."""


UpdateDatapointMessagesDatasetsRequestRequestBody5Content = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestRequestBody5Content",
    Union[str, List[UpdateDatapointContentDatasetsRequest2]],
)
r"""The contents of the tool message."""


UpdateDatapointMessagesDatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


UpdateDatapointMessagesTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class UpdateDatapointMessagesCacheControlTypedDict(TypedDict):
    type: UpdateDatapointMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[UpdateDatapointMessagesTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class UpdateDatapointMessagesCacheControl(BaseModel):
    type: UpdateDatapointMessagesDatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[UpdateDatapointMessagesTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesToolMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsRequestRequestBody5Role
    r"""The role of the messages author, in this case tool."""
    content: UpdateDatapointMessagesDatasetsRequestRequestBody5ContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""
    cache_control: NotRequired[UpdateDatapointMessagesCacheControlTypedDict]


class UpdateDatapointMessagesToolMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsRequestRequestBody5Role
    r"""The role of the messages author, in this case tool."""

    content: UpdateDatapointMessagesDatasetsRequestRequestBody5Content
    r"""The contents of the tool message."""

    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""

    cache_control: Optional[UpdateDatapointMessagesCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        nullable_fields = set(["tool_call_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdateDatapointContentDatasets2TypedDict = TypeAliasType(
    "UpdateDatapointContentDatasets2TypedDict",
    Union[
        RefusalPartSchemaTypedDict,
        RedactedReasoningPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ReasoningPartSchemaTypedDict,
    ],
)


UpdateDatapointContentDatasets2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[RefusalPartSchema, Tag("refusal")],
        Annotated[ReasoningPartSchema, Tag("reasoning")],
        Annotated[RedactedReasoningPartSchema, Tag("redacted_reasoning")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


UpdateDatapointMessagesDatasetsRequestRequestBodyContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestRequestBodyContentTypedDict",
    Union[str, List[UpdateDatapointContentDatasets2TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


UpdateDatapointMessagesDatasetsRequestRequestBodyContent = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestRequestBodyContent",
    Union[str, List[UpdateDatapointContentDatasets2]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


UpdateDatapointMessagesDatasetsRequestRequestBodyRole = Literal["assistant",]
r"""The role of the messages author, in this case `assistant`."""


class UpdateDatapointMessagesAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class UpdateDatapointMessagesAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


UpdateDatapointMessagesType = Literal["function",]
r"""The type of the tool. Currently, only `function` is supported."""


class UpdateDatapointMessagesFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class UpdateDatapointMessagesFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: UpdateDatapointMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: UpdateDatapointMessagesFunctionTypedDict
    thought_signature: NotRequired[str]
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""


class UpdateDatapointMessagesToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: UpdateDatapointMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: UpdateDatapointMessagesFunction

    thought_signature: Optional[str] = None
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["thought_signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesAssistantMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsRequestRequestBodyRole
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[UpdateDatapointMessagesDatasetsRequestRequestBodyContentTypedDict]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[UpdateDatapointMessagesAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[UpdateDatapointMessagesToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""


class UpdateDatapointMessagesAssistantMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsRequestRequestBodyRole
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[
        UpdateDatapointMessagesDatasetsRequestRequestBodyContent
    ] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[UpdateDatapointMessagesAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[UpdateDatapointMessagesToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["content", "refusal", "name", "audio", "tool_calls"])
        nullable_fields = set(["content", "refusal", "audio"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsRequestRole = Literal["user",]
r"""The role of the messages author, in this case `user`."""


UpdateDatapoint2Type = Literal["file",]
r"""The type of the content part. Always `file`."""


UpdateDatapoint2DatasetsType = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


UpdateDatapoint2TTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class UpdateDatapoint2CacheControlTypedDict(TypedDict):
    type: UpdateDatapoint2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[UpdateDatapoint2TTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class UpdateDatapoint2CacheControl(BaseModel):
    type: UpdateDatapoint2DatasetsType
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[UpdateDatapoint2TTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapoint24TypedDict(TypedDict):
    type: UpdateDatapoint2Type
    r"""The type of the content part. Always `file`."""
    file: FileContentPartSchemaTypedDict
    r"""File data for the content part. Must contain either file_data or uri, but not both."""
    cache_control: NotRequired[UpdateDatapoint2CacheControlTypedDict]


class UpdateDatapoint24(BaseModel):
    type: UpdateDatapoint2Type
    r"""The type of the content part. Always `file`."""

    file: FileContentPartSchema
    r"""File data for the content part. Must contain either file_data or uri, but not both."""

    cache_control: Optional[UpdateDatapoint2CacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointContent2TypedDict = TypeAliasType(
    "UpdateDatapointContent2TypedDict",
    Union[
        AudioContentPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ImageContentPartSchemaTypedDict,
        UpdateDatapoint24TypedDict,
    ],
)


UpdateDatapointContent2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[ImageContentPartSchema, Tag("image_url")],
        Annotated[AudioContentPartSchema, Tag("input_audio")],
        Annotated[UpdateDatapoint24, Tag("file")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


UpdateDatapointMessagesDatasetsRequestContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestContentTypedDict",
    Union[str, List[UpdateDatapointContent2TypedDict]],
)
r"""The contents of the user message."""


UpdateDatapointMessagesDatasetsRequestContent = TypeAliasType(
    "UpdateDatapointMessagesDatasetsRequestContent",
    Union[str, List[UpdateDatapointContent2]],
)
r"""The contents of the user message."""


class UpdateDatapointMessagesUserMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsRequestRole
    r"""The role of the messages author, in this case `user`."""
    content: UpdateDatapointMessagesDatasetsRequestContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesUserMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsRequestRole
    r"""The role of the messages author, in this case `user`."""

    content: UpdateDatapointMessagesDatasetsRequestContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsRole = Literal["developer",]
r"""The role of the messages author, in this case  `developer`."""


UpdateDatapointMessagesDatasetsContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the developer message."""


UpdateDatapointMessagesDatasetsContent = TypeAliasType(
    "UpdateDatapointMessagesDatasetsContent", Union[str, List[TextContentPartSchema]]
)
r"""The contents of the developer message."""


class UpdateDatapointMessagesDeveloperMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""
    content: UpdateDatapointMessagesDatasetsContentTypedDict
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesDeveloperMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsRole
    r"""The role of the messages author, in this case  `developer`."""

    content: UpdateDatapointMessagesDatasetsContent
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesRole = Literal["system",]
r"""The role of the messages author, in this case `system`."""


UpdateDatapointMessagesContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the system message."""


UpdateDatapointMessagesContent = TypeAliasType(
    "UpdateDatapointMessagesContent", Union[str, List[TextContentPartSchema]]
)
r"""The contents of the system message."""


class UpdateDatapointMessagesSystemMessageTypedDict(TypedDict):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: UpdateDatapointMessagesRole
    r"""The role of the messages author, in this case `system`."""
    content: UpdateDatapointMessagesContentTypedDict
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesSystemMessage(BaseModel):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: UpdateDatapointMessagesRole
    r"""The role of the messages author, in this case `system`."""

    content: UpdateDatapointMessagesContent
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesTypedDict = TypeAliasType(
    "UpdateDatapointMessagesTypedDict",
    Union[
        UpdateDatapointMessagesSystemMessageTypedDict,
        UpdateDatapointMessagesDeveloperMessageTypedDict,
        UpdateDatapointMessagesUserMessageTypedDict,
        UpdateDatapointMessagesToolMessageTypedDict,
        UpdateDatapointMessagesAssistantMessageTypedDict,
    ],
)


UpdateDatapointMessages = Annotated[
    Union[
        Annotated[UpdateDatapointMessagesSystemMessage, Tag("system")],
        Annotated[UpdateDatapointMessagesDeveloperMessage, Tag("developer")],
        Annotated[UpdateDatapointMessagesUserMessage, Tag("user")],
        Annotated[UpdateDatapointMessagesAssistantMessage, Tag("assistant")],
        Annotated[UpdateDatapointMessagesToolMessage, Tag("tool")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


class UpdateDatapointRequestBodyTypedDict(TypedDict):
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[UpdateDatapointMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]


class UpdateDatapointRequestBody(BaseModel):
    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[UpdateDatapointMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["inputs", "messages", "expected_output"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointRequestTypedDict(TypedDict):
    dataset_id: str
    r"""The unique identifier of the dataset"""
    datapoint_id: str
    r"""The unique identifier of the datapoint"""
    request_body: NotRequired[UpdateDatapointRequestBodyTypedDict]


class UpdateDatapointRequest(BaseModel):
    dataset_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the dataset"""

    datapoint_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier of the datapoint"""

    request_body: Annotated[
        Optional[UpdateDatapointRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["RequestBody"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Role = Literal[
    "tool",
]
r"""The role of the messages author, in this case tool."""


UpdateDatapointContentDatasetsResponse200ApplicationJSON2TypedDict = (
    TextContentPartSchemaTypedDict
)


UpdateDatapointContentDatasetsResponse200ApplicationJSON2 = TextContentPartSchema


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict",
    Union[
        str, List[UpdateDatapointContentDatasetsResponse200ApplicationJSON2TypedDict]
    ],
)
r"""The contents of the tool message."""


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Content = (
    TypeAliasType(
        "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Content",
        Union[str, List[UpdateDatapointContentDatasetsResponse200ApplicationJSON2]],
    )
)
r"""The contents of the tool message."""


UpdateDatapointMessagesDatasetsResponse200Type = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


UpdateDatapointMessagesDatasetsTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class UpdateDatapointMessagesDatasetsCacheControlTypedDict(TypedDict):
    type: UpdateDatapointMessagesDatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[UpdateDatapointMessagesDatasetsTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class UpdateDatapointMessagesDatasetsCacheControl(BaseModel):
    type: UpdateDatapointMessagesDatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[UpdateDatapointMessagesDatasetsTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesDatasetsToolMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Role
    r"""The role of the messages author, in this case tool."""
    content: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5ContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""
    cache_control: NotRequired[UpdateDatapointMessagesDatasetsCacheControlTypedDict]


class UpdateDatapointMessagesDatasetsToolMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Role
    r"""The role of the messages author, in this case tool."""

    content: (
        UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBody5Content
    )
    r"""The contents of the tool message."""

    tool_call_id: Nullable[str]
    r"""Tool call that this message is responding to."""

    cache_control: Optional[UpdateDatapointMessagesDatasetsCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        nullable_fields = set(["tool_call_id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdateDatapointContentDatasetsResponse2002TypedDict = TypeAliasType(
    "UpdateDatapointContentDatasetsResponse2002TypedDict",
    Union[
        RefusalPartSchemaTypedDict,
        RedactedReasoningPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ReasoningPartSchemaTypedDict,
    ],
)


UpdateDatapointContentDatasetsResponse2002 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[RefusalPartSchema, Tag("refusal")],
        Annotated[ReasoningPartSchema, Tag("reasoning")],
        Annotated[RedactedReasoningPartSchema, Tag("redacted_reasoning")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict",
    Union[str, List[UpdateDatapointContentDatasetsResponse2002TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContent = (
    TypeAliasType(
        "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContent",
        Union[str, List[UpdateDatapointContentDatasetsResponse2002]],
    )
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyRole = Literal[
    "assistant",
]
r"""The role of the messages author, in this case `assistant`."""


class UpdateDatapointMessagesDatasetsAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class UpdateDatapointMessagesDatasetsAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


UpdateDatapointMessagesDatasetsResponseType = Literal["function",]
r"""The type of the tool. Currently, only `function` is supported."""


class UpdateDatapointMessagesDatasetsFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class UpdateDatapointMessagesDatasetsFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesDatasetsToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: UpdateDatapointMessagesDatasetsResponseType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: UpdateDatapointMessagesDatasetsFunctionTypedDict
    thought_signature: NotRequired[str]
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""


class UpdateDatapointMessagesDatasetsToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: UpdateDatapointMessagesDatasetsResponseType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: UpdateDatapointMessagesDatasetsFunction

    thought_signature: Optional[str] = None
    r"""Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["thought_signature"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapointMessagesDatasetsAssistantMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyRole
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[
            UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContentTypedDict
        ]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[UpdateDatapointMessagesDatasetsAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[UpdateDatapointMessagesDatasetsToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""


class UpdateDatapointMessagesDatasetsAssistantMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyRole
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[
        UpdateDatapointMessagesDatasetsResponse200ApplicationJSONResponseBodyContent
    ] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[UpdateDatapointMessagesDatasetsAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[UpdateDatapointMessagesDatasetsToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["content", "refusal", "name", "audio", "tool_calls"])
        nullable_fields = set(["content", "refusal", "audio"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONRole = Literal["user",]
r"""The role of the messages author, in this case `user`."""


UpdateDatapoint2DatasetsResponseType = Literal["file",]
r"""The type of the content part. Always `file`."""


UpdateDatapoint2DatasetsResponse200Type = Literal["ephemeral",]
r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""


UpdateDatapoint2DatasetsTTL = Literal[
    "5m",
    "1h",
]
r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

- `5m`: 5 minutes
- `1h`: 1 hour

Defaults to `5m`. Only supported by `Anthropic` Claude models.
"""


class UpdateDatapoint2DatasetsCacheControlTypedDict(TypedDict):
    type: UpdateDatapoint2DatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""
    ttl: NotRequired[UpdateDatapoint2DatasetsTTL]
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """


class UpdateDatapoint2DatasetsCacheControl(BaseModel):
    type: UpdateDatapoint2DatasetsResponse200Type
    r"""Create a cache control breakpoint at this content block. Accepts only the value \"ephemeral\"."""

    ttl: Optional[UpdateDatapoint2DatasetsTTL] = "5m"
    r"""The time-to-live for the cache control breakpoint. This may be one of the following values:

    - `5m`: 5 minutes
    - `1h`: 1 hour

    Defaults to `5m`. Only supported by `Anthropic` Claude models.
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["ttl"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class UpdateDatapoint2Datasets4TypedDict(TypedDict):
    type: UpdateDatapoint2DatasetsResponseType
    r"""The type of the content part. Always `file`."""
    file: FileContentPartSchemaTypedDict
    r"""File data for the content part. Must contain either file_data or uri, but not both."""
    cache_control: NotRequired[UpdateDatapoint2DatasetsCacheControlTypedDict]


class UpdateDatapoint2Datasets4(BaseModel):
    type: UpdateDatapoint2DatasetsResponseType
    r"""The type of the content part. Always `file`."""

    file: FileContentPartSchema
    r"""File data for the content part. Must contain either file_data or uri, but not both."""

    cache_control: Optional[UpdateDatapoint2DatasetsCacheControl] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["cache_control"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointContentDatasetsResponse2TypedDict = TypeAliasType(
    "UpdateDatapointContentDatasetsResponse2TypedDict",
    Union[
        AudioContentPartSchemaTypedDict,
        TextContentPartSchemaTypedDict,
        ImageContentPartSchemaTypedDict,
        UpdateDatapoint2Datasets4TypedDict,
    ],
)


UpdateDatapointContentDatasetsResponse2 = Annotated[
    Union[
        Annotated[TextContentPartSchema, Tag("text")],
        Annotated[ImageContentPartSchema, Tag("image_url")],
        Annotated[AudioContentPartSchema, Tag("input_audio")],
        Annotated[UpdateDatapoint2Datasets4, Tag("file")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContentTypedDict = (
    TypeAliasType(
        "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContentTypedDict",
        Union[str, List[UpdateDatapointContentDatasetsResponse2TypedDict]],
    )
)
r"""The contents of the user message."""


UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContent = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContent",
    Union[str, List[UpdateDatapointContentDatasetsResponse2]],
)
r"""The contents of the user message."""


class UpdateDatapointMessagesDatasetsUserMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case `user`."""
    content: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesDatasetsUserMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case `user`."""

    content: UpdateDatapointMessagesDatasetsResponse200ApplicationJSONContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsResponse200Role = Literal["developer",]
r"""The role of the messages author, in this case  `developer`."""


UpdateDatapointMessagesDatasetsResponse200ContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponse200ContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the developer message."""


UpdateDatapointMessagesDatasetsResponse200Content = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponse200Content",
    Union[str, List[TextContentPartSchema]],
)
r"""The contents of the developer message."""


class UpdateDatapointMessagesDatasetsDeveloperMessageTypedDict(TypedDict):
    role: UpdateDatapointMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case  `developer`."""
    content: UpdateDatapointMessagesDatasetsResponse200ContentTypedDict
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesDatasetsDeveloperMessage(BaseModel):
    role: UpdateDatapointMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case  `developer`."""

    content: UpdateDatapointMessagesDatasetsResponse200Content
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointMessagesDatasetsResponseRole = Literal["system",]
r"""The role of the messages author, in this case `system`."""


UpdateDatapointMessagesDatasetsResponseContentTypedDict = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponseContentTypedDict",
    Union[str, List[TextContentPartSchemaTypedDict]],
)
r"""The contents of the system message."""


UpdateDatapointMessagesDatasetsResponseContent = TypeAliasType(
    "UpdateDatapointMessagesDatasetsResponseContent",
    Union[str, List[TextContentPartSchema]],
)
r"""The contents of the system message."""


class UpdateDatapointMessagesDatasetsSystemMessageTypedDict(TypedDict):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: UpdateDatapointMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `system`."""
    content: UpdateDatapointMessagesDatasetsResponseContentTypedDict
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class UpdateDatapointMessagesDatasetsSystemMessage(BaseModel):
    r"""Developer-provided instructions that the model should follow, regardless of messages sent by the user."""

    role: UpdateDatapointMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `system`."""

    content: UpdateDatapointMessagesDatasetsResponseContent
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointDatasetsMessagesTypedDict = TypeAliasType(
    "UpdateDatapointDatasetsMessagesTypedDict",
    Union[
        UpdateDatapointMessagesDatasetsSystemMessageTypedDict,
        UpdateDatapointMessagesDatasetsDeveloperMessageTypedDict,
        UpdateDatapointMessagesDatasetsUserMessageTypedDict,
        UpdateDatapointMessagesDatasetsToolMessageTypedDict,
        UpdateDatapointMessagesDatasetsAssistantMessageTypedDict,
    ],
)


UpdateDatapointDatasetsMessages = Annotated[
    Union[
        Annotated[UpdateDatapointMessagesDatasetsSystemMessage, Tag("system")],
        Annotated[UpdateDatapointMessagesDatasetsDeveloperMessage, Tag("developer")],
        Annotated[UpdateDatapointMessagesDatasetsUserMessage, Tag("user")],
        Annotated[UpdateDatapointMessagesDatasetsAssistantMessage, Tag("assistant")],
        Annotated[UpdateDatapointMessagesDatasetsToolMessage, Tag("tool")],
    ],
    Discriminator(lambda m: get_discriminator(m, "role", "role")),
]


UpdateDatapointEvaluationsDatasetsResponseEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


UpdateDatapointEvaluationsDatasetsResponseSource = Literal[
    "orq",
    "external",
]


UpdateDatapointEvaluationsDatasetsResponseType = Literal["string_array",]


class UpdateDatapointEvaluations3TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: UpdateDatapointEvaluationsDatasetsResponseEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: UpdateDatapointEvaluationsDatasetsResponseType
    values: List[str]
    source: NotRequired[UpdateDatapointEvaluationsDatasetsResponseSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class UpdateDatapointEvaluations3(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: UpdateDatapointEvaluationsDatasetsResponseEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: UpdateDatapointEvaluationsDatasetsResponseType

    values: List[str]

    source: Optional[UpdateDatapointEvaluationsDatasetsResponseSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-20T18:42:57.256Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointEvaluationsDatasetsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


UpdateDatapointEvaluationsDatasetsSource = Literal[
    "orq",
    "external",
]


UpdateDatapointEvaluationsDatasetsType = Literal["number",]


class UpdateDatapointEvaluations2TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: UpdateDatapointEvaluationsDatasetsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: UpdateDatapointEvaluationsDatasetsType
    value: float
    source: NotRequired[UpdateDatapointEvaluationsDatasetsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class UpdateDatapointEvaluations2(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: UpdateDatapointEvaluationsDatasetsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: UpdateDatapointEvaluationsDatasetsType

    value: float

    source: Optional[UpdateDatapointEvaluationsDatasetsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-20T18:42:57.255Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointEvaluationsEvaluationType = Literal["human_review",]
r"""The type of evaluation"""


UpdateDatapointEvaluationsSource = Literal[
    "orq",
    "external",
]


UpdateDatapointEvaluationsType = Literal["string",]


class UpdateDatapointEvaluations1TypedDict(TypedDict):
    id: str
    r"""The unique identifier of the human evaluation"""
    evaluation_type: UpdateDatapointEvaluationsEvaluationType
    r"""The type of evaluation"""
    human_review_id: str
    r"""The unique identifier of the human review"""
    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""
    type: UpdateDatapointEvaluationsType
    value: str
    source: NotRequired[UpdateDatapointEvaluationsSource]
    reviewed_at: NotRequired[datetime]
    r"""The date and time the item was reviewed"""


class UpdateDatapointEvaluations1(BaseModel):
    id: str
    r"""The unique identifier of the human evaluation"""

    evaluation_type: UpdateDatapointEvaluationsEvaluationType
    r"""The type of evaluation"""

    human_review_id: str
    r"""The unique identifier of the human review"""

    reviewed_by_id: str
    r"""The unique identifier of the user who reviewed the item"""

    type: UpdateDatapointEvaluationsType

    value: str

    source: Optional[UpdateDatapointEvaluationsSource] = "orq"

    reviewed_at: Optional[datetime] = parse_datetime("2026-02-20T18:42:57.255Z")
    r"""The date and time the item was reviewed"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["source", "reviewed_at"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


UpdateDatapointEvaluationsTypedDict = TypeAliasType(
    "UpdateDatapointEvaluationsTypedDict",
    Union[
        UpdateDatapointEvaluations1TypedDict,
        UpdateDatapointEvaluations2TypedDict,
        UpdateDatapointEvaluations3TypedDict,
    ],
)


UpdateDatapointEvaluations = Annotated[
    Union[
        Annotated[UpdateDatapointEvaluations1, Tag("string")],
        Annotated[UpdateDatapointEvaluations2, Tag("number")],
        Annotated[UpdateDatapointEvaluations3, Tag("string_array")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class UpdateDatapointResponseBodyTypedDict(TypedDict):
    r"""Dataset item updated."""

    id: str
    r"""The unique identifier of the dataset item"""
    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""
    dataset_id: str
    r"""The unique identifier of the dataset"""
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[UpdateDatapointDatasetsMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]
    evaluations: NotRequired[List[UpdateDatapointEvaluationsTypedDict]]
    r"""Evaluations associated with the datapoint"""
    snapshot_version: NotRequired[str]
    r"""The version of the dataset snapshot"""
    created_by_id: NotRequired[str]
    r"""The unique identifier of the user who created the dataset"""
    updated_by_id: NotRequired[str]
    r"""The unique identifier of the user who last updated the dataset"""
    created: NotRequired[datetime]
    r"""The date and time the resource was created"""
    updated: NotRequired[datetime]
    r"""The date and time the resource was last updated"""


class UpdateDatapointResponseBody(BaseModel):
    r"""Dataset item updated."""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the dataset item"""

    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""

    dataset_id: str
    r"""The unique identifier of the dataset"""

    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[UpdateDatapointDatasetsMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    evaluations: Optional[List[UpdateDatapointEvaluations]] = None
    r"""Evaluations associated with the datapoint"""

    snapshot_version: Optional[str] = None
    r"""The version of the dataset snapshot"""

    created_by_id: Optional[str] = None
    r"""The unique identifier of the user who created the dataset"""

    updated_by_id: Optional[str] = None
    r"""The unique identifier of the user who last updated the dataset"""

    created: Optional[datetime] = None
    r"""The date and time the resource was created"""

    updated: Optional[datetime] = parse_datetime("2026-02-20T18:42:43.251Z")
    r"""The date and time the resource was last updated"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "inputs",
                "messages",
                "expected_output",
                "evaluations",
                "snapshot_version",
                "created_by_id",
                "updated_by_id",
                "created",
                "updated",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    UpdateDatapointResponseBody.model_rebuild()
except NameError:
    pass
