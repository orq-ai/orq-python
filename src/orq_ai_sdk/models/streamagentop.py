"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .actionreviewedstreamingevent import (
    ActionReviewedStreamingEvent,
    ActionReviewedStreamingEventTypedDict,
)
from .actionreviewrequestedstreamingevent import (
    ActionReviewRequestedStreamingEvent,
    ActionReviewRequestedStreamingEventTypedDict,
)
from .agenterroredstreamingevent import (
    AgentErroredStreamingEvent,
    AgentErroredStreamingEventTypedDict,
)
from .agentexecutionstartedstreamingevent import (
    AgentExecutionStartedStreamingEvent,
    AgentExecutionStartedStreamingEventTypedDict,
)
from .agenthandedoffstreamingevent import (
    AgentHandedOffStreamingEvent,
    AgentHandedOffStreamingEventTypedDict,
)
from .agentinactivestreamingevent import (
    AgentInactiveStreamingEvent,
    AgentInactiveStreamingEventTypedDict,
)
from .agentmessagecreatedstreamingevent import (
    AgentMessageCreatedStreamingEvent,
    AgentMessageCreatedStreamingEventTypedDict,
)
from .agentstartedstreamingevent import (
    AgentStartedStreamingEvent,
    AgentStartedStreamingEventTypedDict,
)
from .agentthoughtstreamingevent import (
    AgentThoughtStreamingEvent,
    AgentThoughtStreamingEventTypedDict,
)
from .errorstreamingevent import ErrorStreamingEvent, ErrorStreamingEventTypedDict
from .executionnamedstreamingevent import (
    ExecutionNamedStreamingEvent,
    ExecutionNamedStreamingEventTypedDict,
)
from .executionreviewedstreamingevent import (
    ExecutionReviewedStreamingEvent,
    ExecutionReviewedStreamingEventTypedDict,
)
from .executionreviewrequiredstreamingevent import (
    ExecutionReviewRequiredStreamingEvent,
    ExecutionReviewRequiredStreamingEventTypedDict,
)
from .filepart import FilePart, FilePartTypedDict
from .textpart import TextPart, TextPartTypedDict
from .timeoutstreamingevent import TimeoutStreamingEvent, TimeoutStreamingEventTypedDict
from .toolexecutionfailedstreamingevent import (
    ToolExecutionFailedStreamingEvent,
    ToolExecutionFailedStreamingEventTypedDict,
)
from .toolexecutionfinishedstreamingevent import (
    ToolExecutionFinishedStreamingEvent,
    ToolExecutionFinishedStreamingEventTypedDict,
)
from .toolexecutionstartedstreamingevent import (
    ToolExecutionStartedStreamingEvent,
    ToolExecutionStartedStreamingEventTypedDict,
)
from .toolresultpart import ToolResultPart, ToolResultPartTypedDict
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel, UNSET_SENTINEL
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


StreamAgentRoleToolMessage = Literal["tool",]
r"""Message containing tool execution results"""


StreamAgentRoleUserMessage = Literal["user",]
r"""Message from the end user"""


StreamAgentRoleTypedDict = TypeAliasType(
    "StreamAgentRoleTypedDict",
    Union[StreamAgentRoleUserMessage, StreamAgentRoleToolMessage],
)
r"""Message role (user or tool for continuing executions)"""


StreamAgentRole = TypeAliasType(
    "StreamAgentRole", Union[StreamAgentRoleUserMessage, StreamAgentRoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


StreamAgentPublicMessagePartTypedDict = TypeAliasType(
    "StreamAgentPublicMessagePartTypedDict",
    Union[TextPartTypedDict, FilePartTypedDict, ToolResultPartTypedDict],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


StreamAgentPublicMessagePart = Annotated[
    Union[
        Annotated[TextPart, Tag("text")],
        Annotated[FilePart, Tag("file")],
        Annotated[ToolResultPart, Tag("tool_result")],
    ],
    Discriminator(lambda m: get_discriminator(m, "kind", "kind")),
]
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class StreamAgentA2AMessageTypedDict(TypedDict):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: StreamAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[StreamAgentPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class StreamAgentA2AMessage(BaseModel):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: StreamAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[StreamAgentPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["messageId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class StreamAgentContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class StreamAgentContact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["display_name", "email", "metadata", "logo_url", "tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class StreamAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class StreamAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["tags"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class StreamAgentMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class StreamAgentMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class StreamAgentRequestBodyTypedDict(TypedDict):
    message: StreamAgentA2AMessageTypedDict
    r"""The A2A message to send to the agent (user input or tool results)"""
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[StreamAgentContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[StreamAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[StreamAgentMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""
    stream_timeout_seconds: NotRequired[float]
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""


class StreamAgentRequestBody(BaseModel):
    message: StreamAgentA2AMessage
    r"""The A2A message to send to the agent (user input or tool results)"""

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[StreamAgentContact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[StreamAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[StreamAgentMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""

    stream_timeout_seconds: Optional[float] = None
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "task_id",
                "variables",
                "contact",
                "thread",
                "memory",
                "metadata",
                "stream_timeout_seconds",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class StreamAgentRequestTypedDict(TypedDict):
    key: str
    r"""The key or ID of the agent to invoke"""
    request_body: StreamAgentRequestBodyTypedDict


class StreamAgentRequest(BaseModel):
    key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The key or ID of the agent to invoke"""

    request_body: Annotated[
        StreamAgentRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


class StreamAgentAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class StreamAgentAgentsResponseBody(OrqError):
    r"""Agent not found"""

    data: StreamAgentAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: StreamAgentAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


StreamAgentDataTypedDict = TypeAliasType(
    "StreamAgentDataTypedDict",
    Union[
        AgentExecutionStartedStreamingEventTypedDict,
        AgentStartedStreamingEventTypedDict,
        AgentThoughtStreamingEventTypedDict,
        AgentInactiveStreamingEventTypedDict,
        AgentErroredStreamingEventTypedDict,
        ActionReviewRequestedStreamingEventTypedDict,
        ActionReviewedStreamingEventTypedDict,
        ExecutionReviewRequiredStreamingEventTypedDict,
        ExecutionReviewedStreamingEventTypedDict,
        ExecutionNamedStreamingEventTypedDict,
        AgentHandedOffStreamingEventTypedDict,
        AgentMessageCreatedStreamingEventTypedDict,
        ToolExecutionStartedStreamingEventTypedDict,
        ToolExecutionFinishedStreamingEventTypedDict,
        ToolExecutionFailedStreamingEventTypedDict,
        TimeoutStreamingEventTypedDict,
        ErrorStreamingEventTypedDict,
    ],
)


StreamAgentData = Annotated[
    Union[
        Annotated[AgentExecutionStartedStreamingEvent, Tag("agents.execution_started")],
        Annotated[AgentStartedStreamingEvent, Tag("event.agents.started")],
        Annotated[AgentThoughtStreamingEvent, Tag("event.agents.thought")],
        Annotated[AgentInactiveStreamingEvent, Tag("event.agents.inactive")],
        Annotated[AgentErroredStreamingEvent, Tag("event.agents.errored")],
        Annotated[
            ActionReviewRequestedStreamingEvent,
            Tag("event.agents.action_review_requested"),
        ],
        Annotated[ActionReviewedStreamingEvent, Tag("event.agents.action_reviewed")],
        Annotated[
            ExecutionReviewRequiredStreamingEvent,
            Tag("event.agents.execution_review_required"),
        ],
        Annotated[
            ExecutionReviewedStreamingEvent, Tag("event.agents.execution_reviewed")
        ],
        Annotated[ExecutionNamedStreamingEvent, Tag("event.agents.execution_named")],
        Annotated[AgentHandedOffStreamingEvent, Tag("event.agents.handed_off")],
        Annotated[
            AgentMessageCreatedStreamingEvent, Tag("event.agents.message-created")
        ],
        Annotated[
            ToolExecutionStartedStreamingEvent,
            Tag("event.workflow_events.tool_execution_started"),
        ],
        Annotated[
            ToolExecutionFinishedStreamingEvent,
            Tag("event.workflow_events.tool_execution_finished"),
        ],
        Annotated[
            ToolExecutionFailedStreamingEvent,
            Tag("event.workflow_events.tool_execution_failed"),
        ],
        Annotated[TimeoutStreamingEvent, Tag("agents.timeout")],
        Annotated[ErrorStreamingEvent, Tag("agents.error")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class StreamAgentResponseBodyTypedDict(TypedDict):
    r"""Server-Sent Event stream successfully established. Returns real-time events including agent messages, tool calls, status updates, and completion signals. The stream ends with a [DONE] sentinel value."""

    data: StreamAgentDataTypedDict


class StreamAgentResponseBody(BaseModel):
    r"""Server-Sent Event stream successfully established. Returns real-time events including agent messages, tool calls, status updates, and completion signals. The stream ends with a [DONE] sentinel value."""

    data: StreamAgentData
