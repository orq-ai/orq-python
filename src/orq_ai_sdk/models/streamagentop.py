"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


StreamAgentRoleToolMessage = Literal["tool",]
r"""Tool message"""


StreamAgentRoleUserMessage = Literal["user",]
r"""User message"""


StreamAgentRoleTypedDict = TypeAliasType(
    "StreamAgentRoleTypedDict",
    Union[StreamAgentRoleUserMessage, StreamAgentRoleToolMessage],
)
r"""Message role (user or tool for continuing executions)"""


StreamAgentRole = TypeAliasType(
    "StreamAgentRole", Union[StreamAgentRoleUserMessage, StreamAgentRoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


StreamAgentPublicMessagePartAgentsRequestKind = Literal["tool_result",]


class StreamAgentPublicMessagePartToolResultPartTypedDict(TypedDict):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: StreamAgentPublicMessagePartAgentsRequestKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class StreamAgentPublicMessagePartToolResultPart(BaseModel):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: StreamAgentPublicMessagePartAgentsRequestKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


StreamAgentPublicMessagePartAgentsKind = Literal["file",]


class StreamAgentFileFileInURIFormatTypedDict(TypedDict):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class StreamAgentFileFileInURIFormat(BaseModel):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class StreamAgentFileBinaryFormatTypedDict(TypedDict):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class StreamAgentFileBinaryFormat(BaseModel):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


StreamAgentPublicMessagePartFileTypedDict = TypeAliasType(
    "StreamAgentPublicMessagePartFileTypedDict",
    Union[
        StreamAgentFileBinaryFormatTypedDict, StreamAgentFileFileInURIFormatTypedDict
    ],
)


StreamAgentPublicMessagePartFile = TypeAliasType(
    "StreamAgentPublicMessagePartFile",
    Union[StreamAgentFileBinaryFormat, StreamAgentFileFileInURIFormat],
)


class StreamAgentPublicMessagePartFilePartTypedDict(TypedDict):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: StreamAgentPublicMessagePartAgentsKind
    file: StreamAgentPublicMessagePartFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class StreamAgentPublicMessagePartFilePart(BaseModel):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: StreamAgentPublicMessagePartAgentsKind

    file: StreamAgentPublicMessagePartFile

    metadata: Optional[Dict[str, Any]] = None


StreamAgentPublicMessagePartKind = Literal["text",]


class StreamAgentPublicMessagePartTextPartTypedDict(TypedDict):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: StreamAgentPublicMessagePartKind
    text: str


class StreamAgentPublicMessagePartTextPart(BaseModel):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: StreamAgentPublicMessagePartKind

    text: str


StreamAgentPublicMessagePartTypedDict = TypeAliasType(
    "StreamAgentPublicMessagePartTypedDict",
    Union[
        StreamAgentPublicMessagePartTextPartTypedDict,
        StreamAgentPublicMessagePartFilePartTypedDict,
        StreamAgentPublicMessagePartToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


StreamAgentPublicMessagePart = TypeAliasType(
    "StreamAgentPublicMessagePart",
    Union[
        StreamAgentPublicMessagePartTextPart,
        StreamAgentPublicMessagePartFilePart,
        StreamAgentPublicMessagePartToolResultPart,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class StreamAgentMessageTypedDict(TypedDict):
    role: StreamAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[StreamAgentPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class StreamAgentMessage(BaseModel):
    role: StreamAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[StreamAgentPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""


class StreamAgentContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class StreamAgentContact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class StreamAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class StreamAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class StreamAgentMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class StreamAgentMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class StreamAgentRequestBodyTypedDict(TypedDict):
    message: StreamAgentMessageTypedDict
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[StreamAgentContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[StreamAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[StreamAgentMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""
    stream_timeout_seconds: NotRequired[float]
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""


class StreamAgentRequestBody(BaseModel):
    message: StreamAgentMessage

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[StreamAgentContact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[StreamAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[StreamAgentMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""

    stream_timeout_seconds: Optional[float] = None
    r"""Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)"""


class StreamAgentRequestTypedDict(TypedDict):
    key: str
    r"""The key or ID of the agent to invoke"""
    request_body: NotRequired[StreamAgentRequestBodyTypedDict]


class StreamAgentRequest(BaseModel):
    key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The key or ID of the agent to invoke"""

    request_body: Annotated[
        Optional[StreamAgentRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None


class StreamAgentAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class StreamAgentAgentsResponseBody(OrqError):
    r"""Agent not found"""

    data: StreamAgentAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: StreamAgentAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class StreamAgentResponseBodyTypedDict(TypedDict):
    r"""SSE stream of agent events"""

    data: str
    r"""JSON-encoded event data"""


class StreamAgentResponseBody(BaseModel):
    r"""SSE stream of agent events"""

    data: str
    r"""JSON-encoded event data"""
