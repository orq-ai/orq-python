"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


Status = Literal[
    "inactive",
    "approval_required",
    "in_progress",
    "errored",
]
r"""Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored"""


class ListAgentTasksRequestTypedDict(TypedDict):
    agent_key: str
    r"""The unique key of the agent"""
    limit: NotRequired[float]
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""
    starting_after: NotRequired[str]
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""
    ending_before: NotRequired[str]
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""
    status: NotRequired[Status]
    r"""Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored"""


class ListAgentTasksRequest(BaseModel):
    agent_key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique key of the agent"""

    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""

    starting_after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""

    ending_before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""

    status: Annotated[
        Optional[Status],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored"""


class ListAgentTasksAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class ListAgentTasksAgentsResponseBody(OrqError):
    r"""No agent tasks found"""

    data: ListAgentTasksAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: ListAgentTasksAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class ListAgentTasksModelTypedDict(TypedDict):
    id: str
    r"""The database ID of the primary model"""
    integration_id: NotRequired[Nullable[str]]
    r"""Optional integration ID for custom model configurations"""
    fallback_models: NotRequired[Nullable[List[str]]]
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""
    max_tokens: NotRequired[int]
    r"""Maximum number of tokens for model responses"""
    temperature: NotRequired[float]
    r"""Temperature setting for model responses"""


class ListAgentTasksModel(BaseModel):
    id: str
    r"""The database ID of the primary model"""

    integration_id: OptionalNullable[str] = UNSET
    r"""Optional integration ID for custom model configurations"""

    fallback_models: OptionalNullable[List[str]] = UNSET
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""

    max_tokens: Optional[int] = None
    r"""Maximum number of tokens for model responses"""

    temperature: Optional[float] = None
    r"""Temperature setting for model responses"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "integration_id",
            "fallback_models",
            "max_tokens",
            "temperature",
        ]
        nullable_fields = ["integration_id", "fallback_models"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListAgentTasksToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class ListAgentTasksConditionsTypedDict(TypedDict):
    condition: str
    r"""The argument of the tool call to evaluate"""
    operator: str
    r"""The operator to use"""
    value: str
    r"""The value to compare against"""


class ListAgentTasksConditions(BaseModel):
    condition: str
    r"""The argument of the tool call to evaluate"""

    operator: str
    r"""The operator to use"""

    value: str
    r"""The value to compare against"""


class ListAgentTasksToolsTypedDict(TypedDict):
    id: str
    r"""The id of the resource"""
    action_type: str
    key: NotRequired[str]
    r"""Optional tool key for custom tools"""
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]
    conditions: NotRequired[List[ListAgentTasksConditionsTypedDict]]
    mcp_server: NotRequired[str]
    r"""The id of the resource"""
    timeout: NotRequired[float]
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class ListAgentTasksTools(BaseModel):
    id: str
    r"""The id of the resource"""

    action_type: str

    key: Optional[str] = None
    r"""Optional tool key for custom tools"""

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False

    conditions: Optional[List[ListAgentTasksConditions]] = None

    mcp_server: Annotated[Optional[str], pydantic.Field(alias="mcpServer")] = None
    r"""The id of the resource"""

    timeout: Optional[float] = 120
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class ListAgentTasksSettingsTypedDict(TypedDict):
    tools: List[ListAgentTasksToolsTypedDict]
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""
    tool_approval_required: NotRequired[ListAgentTasksToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class ListAgentTasksSettings(BaseModel):
    tools: List[ListAgentTasksTools]

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""

    tool_approval_required: Optional[ListAgentTasksToolApprovalRequired] = (
        "respect_tool"
    )
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class AgentManifestSnapshotTypedDict(TypedDict):
    id: str
    key: str
    role: str
    description: str
    instructions: str
    model: ListAgentTasksModelTypedDict
    system_prompt: NotRequired[str]
    settings: NotRequired[ListAgentTasksSettingsTypedDict]
    project_id: NotRequired[str]


class AgentManifestSnapshot(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    key: str

    role: str

    description: str

    instructions: str

    model: ListAgentTasksModel

    system_prompt: Optional[str] = None

    settings: Optional[ListAgentTasksSettings] = None

    project_id: Optional[str] = None


class ListAgentTasksMemoryTypedDict(TypedDict):
    r"""Memory configuration for this execution"""

    entity_id: str
    r"""Entity identifier used for memory store isolation (user/session/conversation)"""


class ListAgentTasksMemory(BaseModel):
    r"""Memory configuration for this execution"""

    entity_id: str
    r"""Entity identifier used for memory store isolation (user/session/conversation)"""


class ListAgentTasksStateTypedDict(TypedDict):
    waiting_for_approval: NotRequired[bool]
    inactive: NotRequired[bool]
    error: NotRequired[str]
    iteration: NotRequired[int]
    accumulated_execution_time: NotRequired[float]


class ListAgentTasksState(BaseModel):
    waiting_for_approval: Optional[bool] = False

    inactive: Optional[bool] = True

    error: Optional[str] = None

    iteration: Optional[int] = 1

    accumulated_execution_time: Optional[float] = 0


class ListAgentTasksMetricsTypedDict(TypedDict):
    input_cost: NotRequired[float]
    output_cost: NotRequired[float]
    total_cost: NotRequired[float]
    prompt_tokens: NotRequired[int]
    completion_tokens: NotRequired[int]
    total_tokens: NotRequired[int]


class ListAgentTasksMetrics(BaseModel):
    input_cost: Optional[float] = 0

    output_cost: Optional[float] = 0

    total_cost: Optional[float] = 0

    prompt_tokens: Optional[int] = 0

    completion_tokens: Optional[int] = 0

    total_tokens: Optional[int] = 0


class TasksTypedDict(TypedDict):
    id: str
    agent_manifest_snapshot: AgentManifestSnapshotTypedDict
    workspace_id: str
    state: ListAgentTasksStateTypedDict
    metrics: ListAgentTasksMetricsTypedDict
    created_by_id: NotRequired[str]
    updated_by_id: NotRequired[str]
    created: NotRequired[str]
    updated: NotRequired[str]
    name: NotRequired[str]
    memory: NotRequired[ListAgentTasksMemoryTypedDict]
    r"""Memory configuration for this execution"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Execution-level metadata as key-value pairs"""


class Tasks(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]

    agent_manifest_snapshot: AgentManifestSnapshot

    workspace_id: str

    state: ListAgentTasksState

    metrics: ListAgentTasksMetrics

    created_by_id: Optional[str] = None

    updated_by_id: Optional[str] = None

    created: Optional[str] = None

    updated: Optional[str] = None

    name: Optional[str] = None

    memory: Optional[ListAgentTasksMemory] = None
    r"""Memory configuration for this execution"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Execution-level metadata as key-value pairs"""


class ListAgentTasksResponseBodyTypedDict(TypedDict):
    r"""Agent tasks retrieved"""

    tasks: List[TasksTypedDict]
    overall_total: float


class ListAgentTasksResponseBody(BaseModel):
    r"""Agent tasks retrieved"""

    tasks: List[Tasks]

    overall_total: float
