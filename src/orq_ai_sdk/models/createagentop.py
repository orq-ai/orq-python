"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from orq_ai_sdk.models import OrqError
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


ToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type = Literal[
    "function",
]
r"""Function tool type"""


class FunctionToolTypedDict(TypedDict):
    r"""Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    r"""Function tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created function tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created function tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class FunctionTool(BaseModel):
    r"""Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    r"""Function tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created function tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created function tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type = Literal[
    "code",
]
r"""Code execution tool type"""


class CodeExecutionToolTypedDict(TypedDict):
    r"""Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    r"""Code execution tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created code tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created code tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class CodeExecutionTool(BaseModel):
    r"""Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    r"""Code execution tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created code tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created code tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type = Literal[
    "http",
]
r"""HTTP tool type"""


class HTTPToolTypedDict(TypedDict):
    r"""Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    r"""HTTP tool type"""
    key: NotRequired[str]
    r"""The key of the pre-created HTTP tool"""
    id: NotRequired[str]
    r"""The ID of the pre-created HTTP tool"""
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class HTTPTool(BaseModel):
    r"""Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id."""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    r"""HTTP tool type"""

    key: Optional[str] = None
    r"""The key of the pre-created HTTP tool"""

    id: Optional[str] = None
    r"""The ID of the pre-created HTTP tool"""

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type = Literal[
    "current_date",
]


class CurrentDateToolTypedDict(TypedDict):
    r"""Returns the current date and time"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class CurrentDateTool(BaseModel):
    r"""Returns the current date and time"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type = Literal[
    "query_knowledge_base",
]


class QueryKnowledgeBaseToolTypedDict(TypedDict):
    r"""Queries knowledge bases for information"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class QueryKnowledgeBaseTool(BaseModel):
    r"""Queries knowledge bases for information"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type = Literal[
    "retrieve_knowledge_bases",
]


class RetrieveKnowledgeBasesToolTypedDict(TypedDict):
    r"""Lists available knowledge bases"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class RetrieveKnowledgeBasesTool(BaseModel):
    r"""Lists available knowledge bases"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type = Literal[
    "delete_memory_document",
]


class DeleteMemoryDocumentToolTypedDict(TypedDict):
    r"""Deletes documents from memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class DeleteMemoryDocumentTool(BaseModel):
    r"""Deletes documents from memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType = Literal[
    "retrieve_memory_stores",
]


class RetrieveMemoryStoresToolTypedDict(TypedDict):
    r"""Lists available memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class RetrieveMemoryStoresTool(BaseModel):
    r"""Lists available memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType = Literal[
    "write_memory_store",
]


class WriteMemoryStoreToolTypedDict(TypedDict):
    r"""Writes information to agent memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class WriteMemoryStoreTool(BaseModel):
    r"""Writes information to agent memory stores"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType = Literal[
    "query_memory_store",
]


class QueryMemoryStoreToolTypedDict(TypedDict):
    r"""Queries agent memory stores for context"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class QueryMemoryStoreTool(BaseModel):
    r"""Queries agent memory stores for context"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsRequestType = Literal["retrieve_agents",]


class RetrieveAgentsToolTypedDict(TypedDict):
    r"""Retrieves available agents in the system"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class RetrieveAgentsTool(BaseModel):
    r"""Retrieves available agents in the system"""

    type: CreateAgentAgentToolInputCRUDAgentsRequestType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDAgentsType = Literal["call_sub_agent",]


class CallSubAgentToolTypedDict(TypedDict):
    r"""Delegates tasks to specialized sub-agents"""

    type: CreateAgentAgentToolInputCRUDAgentsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class CallSubAgentTool(BaseModel):
    r"""Delegates tasks to specialized sub-agents"""

    type: CreateAgentAgentToolInputCRUDAgentsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


CreateAgentAgentToolInputCRUDType = Literal["web_scraper",]


class WebScraperToolTypedDict(TypedDict):
    r"""Scrapes and extracts content from web pages"""

    type: CreateAgentAgentToolInputCRUDType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class WebScraperTool(BaseModel):
    r"""Scrapes and extracts content from web pages"""

    type: CreateAgentAgentToolInputCRUDType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


AgentToolInputCRUDType = Literal["google_search",]


class GoogleSearchToolTypedDict(TypedDict):
    r"""Performs Google searches to retrieve web content"""

    type: AgentToolInputCRUDType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class GoogleSearchTool(BaseModel):
    r"""Performs Google searches to retrieve web content"""

    type: AgentToolInputCRUDType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


AgentToolInputCRUDTypedDict = TypeAliasType(
    "AgentToolInputCRUDTypedDict",
    Union[
        GoogleSearchToolTypedDict,
        WebScraperToolTypedDict,
        CallSubAgentToolTypedDict,
        RetrieveAgentsToolTypedDict,
        QueryMemoryStoreToolTypedDict,
        WriteMemoryStoreToolTypedDict,
        RetrieveMemoryStoresToolTypedDict,
        DeleteMemoryDocumentToolTypedDict,
        RetrieveKnowledgeBasesToolTypedDict,
        QueryKnowledgeBaseToolTypedDict,
        CurrentDateToolTypedDict,
        HTTPToolTypedDict,
        CodeExecutionToolTypedDict,
        FunctionToolTypedDict,
    ],
)
r"""Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools must reference pre-created tools by key or id."""


AgentToolInputCRUD = TypeAliasType(
    "AgentToolInputCRUD",
    Union[
        GoogleSearchTool,
        WebScraperTool,
        CallSubAgentTool,
        RetrieveAgentsTool,
        QueryMemoryStoreTool,
        WriteMemoryStoreTool,
        RetrieveMemoryStoresTool,
        DeleteMemoryDocumentTool,
        RetrieveKnowledgeBasesTool,
        QueryKnowledgeBaseTool,
        CurrentDateTool,
        HTTPTool,
        CodeExecutionTool,
        FunctionTool,
    ],
)
r"""Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools must reference pre-created tools by key or id."""


class SettingsTypedDict(TypedDict):
    r"""Configuration settings for the agent's behavior"""

    tools: List[AgentToolInputCRUDTypedDict]
    r"""Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id."""
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""
    tool_approval_required: NotRequired[ToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class Settings(BaseModel):
    r"""Configuration settings for the agent's behavior"""

    tools: List[AgentToolInputCRUD]
    r"""Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id."""

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""

    tool_approval_required: Optional[ToolApprovalRequired] = "respect_tool"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class KnowledgeBasesTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class KnowledgeBases(BaseModel):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class TeamOfAgentsTypedDict(TypedDict):
    key: str
    r"""The unique key of the agent within the workspace"""
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class TeamOfAgents(BaseModel):
    key: str
    r"""The unique key of the agent within the workspace"""

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class CreateAgentRequestBodyTypedDict(TypedDict):
    path: str
    r"""The path where the agent will be stored in the project structure"""
    key: str
    r"""Unique identifier for the agent within the workspace"""
    role: str
    r"""The role or function of the agent"""
    description: str
    r"""A brief description of what the agent does"""
    instructions: str
    r"""Detailed instructions that guide the agent's behavior"""
    model: str
    r"""The primary language model that powers the agent (e.g., \"anthropic/claude-3-sonnet-20240229\")"""
    settings: SettingsTypedDict
    r"""Configuration settings for the agent's behavior"""
    system_prompt: NotRequired[str]
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""
    memory_stores: NotRequired[List[str]]
    r"""Optional array of memory store keys for the agent to access"""
    knowledge_bases: NotRequired[List[KnowledgeBasesTypedDict]]
    r"""Optional array of knowledge base configurations for the agent to access"""
    team_of_agents: NotRequired[List[TeamOfAgentsTypedDict]]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""


class CreateAgentRequestBody(BaseModel):
    path: str
    r"""The path where the agent will be stored in the project structure"""

    key: str
    r"""Unique identifier for the agent within the workspace"""

    role: str
    r"""The role or function of the agent"""

    description: str
    r"""A brief description of what the agent does"""

    instructions: str
    r"""Detailed instructions that guide the agent's behavior"""

    model: str
    r"""The primary language model that powers the agent (e.g., \"anthropic/claude-3-sonnet-20240229\")"""

    settings: Settings
    r"""Configuration settings for the agent's behavior"""

    system_prompt: Optional[str] = None
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""

    memory_stores: Optional[List[str]] = None
    r"""Optional array of memory store keys for the agent to access"""

    knowledge_bases: Optional[List[KnowledgeBases]] = None
    r"""Optional array of knowledge base configurations for the agent to access"""

    team_of_agents: Optional[List[TeamOfAgents]] = None
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""


class CreateAgentAgentsResponseBodyData(BaseModel):
    message: str


@dataclass(unsafe_hash=True)
class CreateAgentAgentsResponseBody(OrqError):
    r"""Agent with this key already exists in the workspace"""

    data: CreateAgentAgentsResponseBodyData = field(hash=False)

    def __init__(
        self,
        data: CreateAgentAgentsResponseBodyData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


CreateAgentStatus = Literal[
    "live",
    "draft",
    "pending",
    "published",
]
r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""


CreateAgentToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class ConditionsTypedDict(TypedDict):
    condition: str
    r"""The argument of the tool call to evaluate"""
    operator: str
    r"""The operator to use"""
    value: str
    r"""The value to compare against"""


class Conditions(BaseModel):
    condition: str
    r"""The argument of the tool call to evaluate"""

    operator: str
    r"""The operator to use"""

    value: str
    r"""The value to compare against"""


class CreateAgentToolsTypedDict(TypedDict):
    id: str
    r"""The id of the resource"""
    action_type: str
    key: NotRequired[str]
    r"""Optional tool key for custom tools"""
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]
    conditions: NotRequired[List[ConditionsTypedDict]]
    mcp_server: NotRequired[str]
    r"""The id of the resource"""
    timeout: NotRequired[float]
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class CreateAgentTools(BaseModel):
    id: str
    r"""The id of the resource"""

    action_type: str

    key: Optional[str] = None
    r"""Optional tool key for custom tools"""

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False

    conditions: Optional[List[Conditions]] = None

    mcp_server: Annotated[Optional[str], pydantic.Field(alias="mcpServer")] = None
    r"""The id of the resource"""

    timeout: Optional[float] = 120
    r"""Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)"""


class CreateAgentSettingsTypedDict(TypedDict):
    tools: List[CreateAgentToolsTypedDict]
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""
    tool_approval_required: NotRequired[CreateAgentToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class CreateAgentSettings(BaseModel):
    tools: List[CreateAgentTools]

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""

    tool_approval_required: Optional[CreateAgentToolApprovalRequired] = "respect_tool"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class CreateAgentModelTypedDict(TypedDict):
    id: str
    r"""The database ID of the primary model"""
    integration_id: NotRequired[Nullable[str]]
    r"""Optional integration ID for custom model configurations"""
    fallback_models: NotRequired[Nullable[List[str]]]
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""
    max_tokens: NotRequired[int]
    r"""Maximum number of tokens for model responses"""
    temperature: NotRequired[float]
    r"""Temperature setting for model responses"""


class CreateAgentModel(BaseModel):
    id: str
    r"""The database ID of the primary model"""

    integration_id: OptionalNullable[str] = UNSET
    r"""Optional integration ID for custom model configurations"""

    fallback_models: OptionalNullable[List[str]] = UNSET
    r"""Optional array of fallback model IDs that will be used automatically in order if the primary model fails"""

    max_tokens: Optional[int] = None
    r"""Maximum number of tokens for model responses"""

    temperature: Optional[float] = None
    r"""Temperature setting for model responses"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "integration_id",
            "fallback_models",
            "max_tokens",
            "temperature",
        ]
        nullable_fields = ["integration_id", "fallback_models"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateAgentTeamOfAgentsTypedDict(TypedDict):
    key: str
    r"""The unique key of the agent within the workspace"""
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class CreateAgentTeamOfAgents(BaseModel):
    key: str
    r"""The unique key of the agent within the workspace"""

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class CreateAgentMetricsTypedDict(TypedDict):
    total_cost: NotRequired[float]


class CreateAgentMetrics(BaseModel):
    total_cost: Optional[float] = 0


class CreateAgentKnowledgeBasesTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class CreateAgentKnowledgeBases(BaseModel):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


HiddenPanels = Literal[
    "model",
    "tools",
    "knowledge_bases",
    "variables",
    "runtime_constraints",
]


class CreateAgentResponseBodyTypedDict(TypedDict):
    r"""Agent created successfully"""

    id: str
    key: str
    workspace_id: str
    project_id: str
    role: str
    description: str
    instructions: str
    status: CreateAgentStatus
    r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""
    model: CreateAgentModelTypedDict
    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    memory_stores: List[str]
    team_of_agents: List[CreateAgentTeamOfAgentsTypedDict]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""
    created_by_id: NotRequired[Nullable[str]]
    updated_by_id: NotRequired[Nullable[str]]
    created: NotRequired[str]
    updated: NotRequired[str]
    system_prompt: NotRequired[str]
    settings: NotRequired[CreateAgentSettingsTypedDict]
    version_hash: NotRequired[str]
    metrics: NotRequired[CreateAgentMetricsTypedDict]
    variables: NotRequired[Dict[str, Any]]
    r"""Extracted variables from agent instructions"""
    knowledge_bases: NotRequired[List[CreateAgentKnowledgeBasesTypedDict]]
    r"""Agent knowledge bases reference"""
    hidden_panels: NotRequired[List[HiddenPanels]]
    r"""List of hidden collapsed panels in configuration. Duplicates are not allowed."""


class CreateAgentResponseBody(BaseModel):
    r"""Agent created successfully"""

    id: Annotated[str, pydantic.Field(alias="_id")]

    key: str

    workspace_id: str

    project_id: str

    role: str

    description: str

    instructions: str

    status: CreateAgentStatus
    r"""The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version."""

    model: CreateAgentModel

    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    memory_stores: List[str]

    team_of_agents: List[CreateAgentTeamOfAgents]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""

    created_by_id: OptionalNullable[str] = UNSET

    updated_by_id: OptionalNullable[str] = UNSET

    created: Optional[str] = None

    updated: Optional[str] = None

    system_prompt: Optional[str] = None

    settings: Optional[CreateAgentSettings] = None

    version_hash: Optional[str] = None

    metrics: Optional[CreateAgentMetrics] = None

    variables: Optional[Dict[str, Any]] = None
    r"""Extracted variables from agent instructions"""

    knowledge_bases: Optional[List[CreateAgentKnowledgeBases]] = None
    r"""Agent knowledge bases reference"""

    hidden_panels: Optional[List[HiddenPanels]] = None
    r"""List of hidden collapsed panels in configuration. Duplicates are not allowed."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "created_by_id",
            "updated_by_id",
            "created",
            "updated",
            "system_prompt",
            "settings",
            "version_hash",
            "metrics",
            "variables",
            "knowledge_bases",
            "hidden_panels",
        ]
        nullable_fields = ["created_by_id", "updated_by_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
