"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
import pydantic
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


RunAgentRoleToolMessage = Literal["tool",]
r"""Tool message"""


RunAgentRoleUserMessage = Literal["user",]
r"""User message"""


RunAgentRoleTypedDict = TypeAliasType(
    "RunAgentRoleTypedDict", Union[RunAgentRoleUserMessage, RunAgentRoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


RunAgentRole = TypeAliasType(
    "RunAgentRole", Union[RunAgentRoleUserMessage, RunAgentRoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


RunAgentPublicMessagePartAgentsRequestKind = Literal["tool_result",]


class PublicMessagePartToolResultPartTypedDict(TypedDict):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: RunAgentPublicMessagePartAgentsRequestKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartToolResultPart(BaseModel):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: RunAgentPublicMessagePartAgentsRequestKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


RunAgentPublicMessagePartAgentsKind = Literal["file",]


class FileFileInURIFormatTypedDict(TypedDict):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class FileFileInURIFormat(BaseModel):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class FileBinaryFormatTypedDict(TypedDict):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class FileBinaryFormat(BaseModel):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


RunAgentPublicMessagePartFileTypedDict = TypeAliasType(
    "RunAgentPublicMessagePartFileTypedDict",
    Union[FileBinaryFormatTypedDict, FileFileInURIFormatTypedDict],
)


RunAgentPublicMessagePartFile = TypeAliasType(
    "RunAgentPublicMessagePartFile", Union[FileBinaryFormat, FileFileInURIFormat]
)


class PublicMessagePartFilePartTypedDict(TypedDict):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: RunAgentPublicMessagePartAgentsKind
    file: RunAgentPublicMessagePartFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartFilePart(BaseModel):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: RunAgentPublicMessagePartAgentsKind

    file: RunAgentPublicMessagePartFile

    metadata: Optional[Dict[str, Any]] = None


RunAgentPublicMessagePartKind = Literal["text",]


class PublicMessagePartTextPartTypedDict(TypedDict):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: RunAgentPublicMessagePartKind
    text: str


class PublicMessagePartTextPart(BaseModel):
    r"""Text content part. Use this to send text messages to the agent."""

    kind: RunAgentPublicMessagePartKind

    text: str


RunAgentPublicMessagePartTypedDict = TypeAliasType(
    "RunAgentPublicMessagePartTypedDict",
    Union[
        PublicMessagePartTextPartTypedDict,
        PublicMessagePartFilePartTypedDict,
        PublicMessagePartToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


RunAgentPublicMessagePart = TypeAliasType(
    "RunAgentPublicMessagePart",
    Union[
        PublicMessagePartTextPart,
        PublicMessagePartFilePart,
        PublicMessagePartToolResultPart,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class RunAgentMessageTypedDict(TypedDict):
    r"""The A2A format message containing the task for the agent to perform."""

    role: RunAgentRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[RunAgentPublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class RunAgentMessage(BaseModel):
    r"""The A2A format message containing the task for the agent to perform."""

    role: RunAgentRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[RunAgentPublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""


class RunAgentContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class RunAgentContact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class RunAgentThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class RunAgentThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class RunAgentMemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class RunAgentMemory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class RunAgentKnowledgeBasesTypedDict(TypedDict):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class RunAgentKnowledgeBases(BaseModel):
    knowledge_id: str
    r"""Unique identifier of the knowledge base to search"""


class RunAgentTeamOfAgentsTypedDict(TypedDict):
    key: str
    r"""The unique key of the agent within the workspace"""
    role: NotRequired[str]
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


class RunAgentTeamOfAgents(BaseModel):
    key: str
    r"""The unique key of the agent within the workspace"""

    role: Optional[str] = None
    r"""The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to."""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type = Literal[
    "function",
]


class AgentToolInputRunFunctionTypedDict(TypedDict):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""
    description: NotRequired[str]
    r"""A description of what the function does, used by the model to choose when and how to call the function."""
    strict: NotRequired[bool]
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""
    parameters: NotRequired[Dict[str, Any]]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class AgentToolInputRunFunction(BaseModel):
    name: str
    r"""The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."""

    description: Optional[str] = None
    r"""A description of what the function does, used by the model to choose when and how to call the function."""

    strict: Optional[bool] = None
    r"""Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models."""

    parameters: Optional[Dict[str, Any]] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class FunctionToolRunTypedDict(TypedDict):
    r"""Function tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    function: AgentToolInputRunFunctionTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    description: NotRequired[str]
    requires_approval: NotRequired[bool]


class FunctionToolRun(BaseModel):
    r"""Function tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    function: AgentToolInputRunFunction

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    display_name: Optional[str] = None

    description: Optional[str] = None

    requires_approval: Optional[bool] = False


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type = Literal["code",]


Language = Literal["python",]


class CodeToolTypedDict(TypedDict):
    language: Language
    code: str
    r"""The code to execute."""
    parameters: NotRequired[Dict[str, Any]]
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class CodeTool(BaseModel):
    language: Language

    code: str
    r"""The code to execute."""

    parameters: Optional[Dict[str, Any]] = None
    r"""The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format."""


class CodeToolRunTypedDict(TypedDict):
    r"""Code execution tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    code_tool: CodeToolTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]


class CodeToolRun(BaseModel):
    r"""Code execution tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    code_tool: CodeTool

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type = Literal["http",]


Method = Literal[
    "GET",
    "POST",
    "PUT",
    "DELETE",
]
r"""The HTTP method to use."""


class BlueprintTypedDict(TypedDict):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""
    method: Method
    r"""The HTTP method to use."""
    headers: NotRequired[Dict[str, str]]
    r"""The headers to send with the request."""
    body: NotRequired[Dict[str, Any]]
    r"""The body to send with the request."""


class Blueprint(BaseModel):
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    url: str
    r"""The URL to send the request to."""

    method: Method
    r"""The HTTP method to use."""

    headers: Optional[Dict[str, str]] = None
    r"""The headers to send with the request."""

    body: Optional[Dict[str, Any]] = None
    r"""The body to send with the request."""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HTTPType = Literal[
    "string",
    "number",
    "boolean",
]
r"""The type of the argument."""


DefaultValueTypedDict = TypeAliasType("DefaultValueTypedDict", Union[str, float, bool])
r"""The default value of the argument."""


DefaultValue = TypeAliasType("DefaultValue", Union[str, float, bool])
r"""The default value of the argument."""


class ArgumentsTypedDict(TypedDict):
    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HTTPType
    r"""The type of the argument."""
    description: str
    r"""A description of the argument."""
    send_to_model: NotRequired[bool]
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""
    default_value: NotRequired[DefaultValueTypedDict]
    r"""The default value of the argument."""


class Arguments(BaseModel):
    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HTTPType
    r"""The type of the argument."""

    description: str
    r"""A description of the argument."""

    send_to_model: Optional[bool] = True
    r"""Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank."""

    default_value: Optional[DefaultValue] = None
    r"""The default value of the argument."""


class HTTPTypedDict(TypedDict):
    blueprint: BlueprintTypedDict
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""
    arguments: NotRequired[Dict[str, ArgumentsTypedDict]]
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class HTTP(BaseModel):
    blueprint: Blueprint
    r"""The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields."""

    arguments: Optional[Dict[str, Arguments]] = None
    r"""The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field."""


class HTTPToolRunTypedDict(TypedDict):
    r"""HTTP tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""
    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""
    http: HTTPTypedDict
    id: NotRequired[str]
    display_name: NotRequired[str]
    requires_approval: NotRequired[bool]


class HTTPToolRun(BaseModel):
    r"""HTTP tool with inline definition for on-the-fly creation in run endpoint"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type

    key: str
    r"""Unique key of the tool as it will be displayed in the UI"""

    description: str
    r"""A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision."""

    http: HTTP

    id: Annotated[Optional[str], pydantic.Field(alias="_id")] = None

    display_name: Optional[str] = None

    requires_approval: Optional[bool] = False


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type = Literal[
    "current_date",
]


class AgentToolInputRunCurrentDateToolTypedDict(TypedDict):
    r"""Returns the current date and time"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunCurrentDateTool(BaseModel):
    r"""Returns the current date and time"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type = Literal[
    "query_knowledge_base",
]


class AgentToolInputRunQueryKnowledgeBaseToolTypedDict(TypedDict):
    r"""Queries knowledge bases for information"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunQueryKnowledgeBaseTool(BaseModel):
    r"""Queries knowledge bases for information"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type = Literal[
    "retrieve_knowledge_bases",
]


class AgentToolInputRunRetrieveKnowledgeBasesToolTypedDict(TypedDict):
    r"""Lists available knowledge bases"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunRetrieveKnowledgeBasesTool(BaseModel):
    r"""Lists available knowledge bases"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type = Literal[
    "delete_memory_document",
]


class AgentToolInputRunDeleteMemoryDocumentToolTypedDict(TypedDict):
    r"""Deletes documents from memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunDeleteMemoryDocumentTool(BaseModel):
    r"""Deletes documents from memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType = Literal[
    "retrieve_memory_stores",
]


class AgentToolInputRunRetrieveMemoryStoresToolTypedDict(TypedDict):
    r"""Lists available memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunRetrieveMemoryStoresTool(BaseModel):
    r"""Lists available memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType = Literal[
    "write_memory_store",
]


class AgentToolInputRunWriteMemoryStoreToolTypedDict(TypedDict):
    r"""Writes information to agent memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunWriteMemoryStoreTool(BaseModel):
    r"""Writes information to agent memory stores"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestRequestBodyType = Literal["query_memory_store",]


class AgentToolInputRunQueryMemoryStoreToolTypedDict(TypedDict):
    r"""Queries agent memory stores for context"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodyType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunQueryMemoryStoreTool(BaseModel):
    r"""Queries agent memory stores for context"""

    type: RunAgentAgentToolInputRunAgentsRequestRequestBodyType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsRequestType = Literal["retrieve_agents",]


class AgentToolInputRunRetrieveAgentsToolTypedDict(TypedDict):
    r"""Retrieves available agents in the system"""

    type: RunAgentAgentToolInputRunAgentsRequestType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunRetrieveAgentsTool(BaseModel):
    r"""Retrieves available agents in the system"""

    type: RunAgentAgentToolInputRunAgentsRequestType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunAgentsType = Literal["call_sub_agent",]


class AgentToolInputRunCallSubAgentToolTypedDict(TypedDict):
    r"""Delegates tasks to specialized sub-agents"""

    type: RunAgentAgentToolInputRunAgentsType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunCallSubAgentTool(BaseModel):
    r"""Delegates tasks to specialized sub-agents"""

    type: RunAgentAgentToolInputRunAgentsType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


RunAgentAgentToolInputRunType = Literal["web_scraper",]


class AgentToolInputRunWebScraperToolTypedDict(TypedDict):
    r"""Scrapes and extracts content from web pages"""

    type: RunAgentAgentToolInputRunType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunWebScraperTool(BaseModel):
    r"""Scrapes and extracts content from web pages"""

    type: RunAgentAgentToolInputRunType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


AgentToolInputRunType = Literal["google_search",]


class AgentToolInputRunGoogleSearchToolTypedDict(TypedDict):
    r"""Performs Google searches to retrieve web content"""

    type: AgentToolInputRunType
    requires_approval: NotRequired[bool]
    r"""Whether this tool requires approval before execution"""


class AgentToolInputRunGoogleSearchTool(BaseModel):
    r"""Performs Google searches to retrieve web content"""

    type: AgentToolInputRunType

    requires_approval: Optional[bool] = False
    r"""Whether this tool requires approval before execution"""


AgentToolInputRunTypedDict = TypeAliasType(
    "AgentToolInputRunTypedDict",
    Union[
        AgentToolInputRunGoogleSearchToolTypedDict,
        AgentToolInputRunWebScraperToolTypedDict,
        AgentToolInputRunCallSubAgentToolTypedDict,
        AgentToolInputRunRetrieveAgentsToolTypedDict,
        AgentToolInputRunQueryMemoryStoreToolTypedDict,
        AgentToolInputRunWriteMemoryStoreToolTypedDict,
        AgentToolInputRunRetrieveMemoryStoresToolTypedDict,
        AgentToolInputRunDeleteMemoryDocumentToolTypedDict,
        AgentToolInputRunRetrieveKnowledgeBasesToolTypedDict,
        AgentToolInputRunQueryKnowledgeBaseToolTypedDict,
        AgentToolInputRunCurrentDateToolTypedDict,
        HTTPToolRunTypedDict,
        CodeToolRunTypedDict,
        FunctionToolRunTypedDict,
    ],
)
r"""Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (http, code, function) support full inline definitions for on-the-fly creation."""


AgentToolInputRun = TypeAliasType(
    "AgentToolInputRun",
    Union[
        AgentToolInputRunGoogleSearchTool,
        AgentToolInputRunWebScraperTool,
        AgentToolInputRunCallSubAgentTool,
        AgentToolInputRunRetrieveAgentsTool,
        AgentToolInputRunQueryMemoryStoreTool,
        AgentToolInputRunWriteMemoryStoreTool,
        AgentToolInputRunRetrieveMemoryStoresTool,
        AgentToolInputRunDeleteMemoryDocumentTool,
        AgentToolInputRunRetrieveKnowledgeBasesTool,
        AgentToolInputRunQueryKnowledgeBaseTool,
        AgentToolInputRunCurrentDateTool,
        HTTPToolRun,
        CodeToolRun,
        FunctionToolRun,
    ],
)
r"""Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (http, code, function) support full inline definitions for on-the-fly creation."""


RunAgentToolApprovalRequired = Literal[
    "all",
    "respect_tool",
    "none",
]
r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""


class RunAgentSettingsTypedDict(TypedDict):
    tools: List[AgentToolInputRunTypedDict]
    r"""Tools available to the agent"""
    tool_approval_required: NotRequired[RunAgentToolApprovalRequired]
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""
    max_iterations: NotRequired[int]
    r"""Maximum iterations(llm calls) before the agent will stop executing."""
    max_execution_time: NotRequired[int]
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""


class RunAgentSettings(BaseModel):
    tools: List[AgentToolInputRun]
    r"""Tools available to the agent"""

    tool_approval_required: Optional[RunAgentToolApprovalRequired] = "none"
    r"""If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools."""

    max_iterations: Optional[int] = 15
    r"""Maximum iterations(llm calls) before the agent will stop executing."""

    max_execution_time: Optional[int] = 300
    r"""Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned."""


class RunAgentRequestBodyTypedDict(TypedDict):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""
    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""
    role: str
    r"""Specifies the agent's function and area of expertise."""
    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""
    message: RunAgentMessageTypedDict
    r"""The A2A format message containing the task for the agent to perform."""
    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""
    settings: RunAgentSettingsTypedDict
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    fallback_models: NotRequired[List[str]]
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[RunAgentContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[RunAgentThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[RunAgentMemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    description: NotRequired[str]
    r"""A brief summary of the agent's purpose."""
    system_prompt: NotRequired[str]
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""
    memory_stores: NotRequired[List[str]]
    r"""The list of keys of the memory stores that are accessible to the agent."""
    knowledge_bases: NotRequired[List[RunAgentKnowledgeBasesTypedDict]]
    r"""Knowledge base configurations for the agent to access"""
    team_of_agents: NotRequired[List[RunAgentTeamOfAgentsTypedDict]]
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""


class RunAgentRequestBody(BaseModel):
    key: str
    r"""A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed."""

    model: str
    r"""The language model that powers the agent. The model must support tool calling capabilities."""

    role: str
    r"""Specifies the agent's function and area of expertise."""

    instructions: str
    r"""Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions."""

    message: RunAgentMessage
    r"""The A2A format message containing the task for the agent to perform."""

    path: str
    r"""The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists."""

    settings: RunAgentSettings

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    fallback_models: Optional[List[str]] = None
    r"""Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[RunAgentContact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[RunAgentThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[RunAgentMemory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    description: Optional[str] = None
    r"""A brief summary of the agent's purpose."""

    system_prompt: Optional[str] = None
    r"""A custom system prompt template for the agent. If omitted, the default template is used."""

    memory_stores: Optional[List[str]] = None
    r"""The list of keys of the memory stores that are accessible to the agent."""

    knowledge_bases: Optional[List[RunAgentKnowledgeBases]] = None
    r"""Knowledge base configurations for the agent to access"""

    team_of_agents: Optional[List[RunAgentTeamOfAgents]] = None
    r"""The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent run as key-value pairs that will be included in traces"""


RunAgentKind = Literal["task",]
r"""A2A entity type"""


RunAgentState = Literal[
    "submitted",
    "working",
    "input-required",
    "completed",
    "failed",
    "canceled",
    "rejected",
    "auth-required",
    "unknown",
]
r"""Current task state"""


RunAgentAgentsKind = Literal["message",]


RunAgentAgentsRole = Literal[
    "user",
    "agent",
    "tool",
    "system",
]
r"""Extended A2A message role"""


class RunAgentAgentsMessageTypedDict(TypedDict):
    r"""Optional status message"""

    kind: RunAgentAgentsKind
    message_id: str
    role: RunAgentAgentsRole
    r"""Extended A2A message role"""
    parts: List[Any]


class RunAgentAgentsMessage(BaseModel):
    r"""Optional status message"""

    kind: RunAgentAgentsKind

    message_id: Annotated[str, pydantic.Field(alias="messageId")]

    role: RunAgentAgentsRole
    r"""Extended A2A message role"""

    parts: List[Any]


class RunAgentStatusTypedDict(TypedDict):
    r"""Task status information"""

    state: RunAgentState
    r"""Current task state"""
    timestamp: NotRequired[str]
    r"""ISO timestamp of status update"""
    message: NotRequired[RunAgentAgentsMessageTypedDict]
    r"""Optional status message"""


class RunAgentStatus(BaseModel):
    r"""Task status information"""

    state: RunAgentState
    r"""Current task state"""

    timestamp: Optional[str] = None
    r"""ISO timestamp of status update"""

    message: Optional[RunAgentAgentsMessage] = None
    r"""Optional status message"""


class RunAgentResponseBodyTypedDict(TypedDict):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""
    context_id: str
    r"""The correlation ID for this execution"""
    kind: RunAgentKind
    r"""A2A entity type"""
    status: RunAgentStatusTypedDict
    r"""Task status information"""
    metadata: NotRequired[Dict[str, Any]]
    r"""Task metadata containing workspace_id and trace_id for feedback"""


class RunAgentResponseBody(BaseModel):
    r"""A2A Task response format"""

    id: str
    r"""The ID of the created agent execution task"""

    context_id: Annotated[str, pydantic.Field(alias="contextId")]
    r"""The correlation ID for this execution"""

    kind: RunAgentKind
    r"""A2A entity type"""

    status: RunAgentStatus
    r"""Task status information"""

    metadata: Optional[Dict[str, Any]] = None
    r"""Task metadata containing workspace_id and trace_id for feedback"""
