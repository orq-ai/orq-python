"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import BaseModel
from orq_ai_sdk.utils import FieldMetadata, PathParamMetadata, RequestMetadata
import pydantic
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SearchKnowledgeOrExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledgeOrExists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledgeOrKnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeNin = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNin", Union[str, float, bool]
)


class SearchKnowledgeOrNinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledgeOrKnowledgeNinTypedDict]


class SearchKnowledgeOrNin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledgeOrKnowledgeNin]


SearchKnowledgeOrKnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeIn = TypeAliasType(
    "SearchKnowledgeOrKnowledgeIn", Union[str, float, bool]
)


class SearchKnowledgeOrInTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledgeOrKnowledgeInTypedDict]


class SearchKnowledgeOrIn(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledgeOrKnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledgeOrLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeOrLte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeOrLtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledgeOrLt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledgeOrGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeOrGte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeOr3TypedDict(TypedDict):
    gt: float


class SearchKnowledgeOr3(BaseModel):
    gt: float


SearchKnowledgeOrKnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeNe = TypeAliasType(
    "SearchKnowledgeOrKnowledgeNe", Union[str, float, bool]
)


class SearchKnowledgeOrNeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledgeOrKnowledgeNeTypedDict


class SearchKnowledgeOrNe(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledgeOrKnowledgeNe


SearchKnowledgeOrKnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledgeOrKnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeOrKnowledgeEq = TypeAliasType(
    "SearchKnowledgeOrKnowledgeEq", Union[str, float, bool]
)


class SearchKnowledgeOrEqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledgeOrKnowledgeEqTypedDict


class SearchKnowledgeOrEq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledgeOrKnowledgeEq


SearchKnowledgeFilterByOrTypedDict = TypeAliasType(
    "SearchKnowledgeFilterByOrTypedDict",
    Union[
        SearchKnowledgeOrEqTypedDict,
        SearchKnowledgeOrNeTypedDict,
        SearchKnowledgeOr3TypedDict,
        SearchKnowledgeOrGteTypedDict,
        SearchKnowledgeOrLtTypedDict,
        SearchKnowledgeOrLteTypedDict,
        SearchKnowledgeOrInTypedDict,
        SearchKnowledgeOrNinTypedDict,
        SearchKnowledgeOrExistsTypedDict,
    ],
)


SearchKnowledgeFilterByOr = TypeAliasType(
    "SearchKnowledgeFilterByOr",
    Union[
        SearchKnowledgeOrEq,
        SearchKnowledgeOrNe,
        SearchKnowledgeOr3,
        SearchKnowledgeOrGte,
        SearchKnowledgeOrLt,
        SearchKnowledgeOrLte,
        SearchKnowledgeOrIn,
        SearchKnowledgeOrNin,
        SearchKnowledgeOrExists,
    ],
)


class FilterByOrTypedDict(TypedDict):
    r"""Or"""

    or_: List[Dict[str, SearchKnowledgeFilterByOrTypedDict]]


class FilterByOr(BaseModel):
    r"""Or"""

    or_: Annotated[
        List[Dict[str, SearchKnowledgeFilterByOr]], pydantic.Field(alias="or")
    ]


class SearchKnowledgeAndExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledgeAndExists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledgeAndKnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeNin = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNin", Union[str, float, bool]
)


class SearchKnowledgeAndNinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledgeAndKnowledgeNinTypedDict]


class SearchKnowledgeAndNin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledgeAndKnowledgeNin]


SearchKnowledgeAndKnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeIn = TypeAliasType(
    "SearchKnowledgeAndKnowledgeIn", Union[str, float, bool]
)


class SearchKnowledgeAndInTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledgeAndKnowledgeInTypedDict]


class SearchKnowledgeAndIn(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledgeAndKnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledgeAndLteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeAndLte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledgeAndLtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledgeAndLt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledgeAndGteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeAndGte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledgeAnd3TypedDict(TypedDict):
    gt: float


class SearchKnowledgeAnd3(BaseModel):
    gt: float


SearchKnowledgeAndKnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeNe = TypeAliasType(
    "SearchKnowledgeAndKnowledgeNe", Union[str, float, bool]
)


class SearchKnowledgeAndNeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledgeAndKnowledgeNeTypedDict


class SearchKnowledgeAndNe(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledgeAndKnowledgeNe


SearchKnowledgeAndKnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledgeAndKnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledgeAndKnowledgeEq = TypeAliasType(
    "SearchKnowledgeAndKnowledgeEq", Union[str, float, bool]
)


class SearchKnowledgeAndEqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledgeAndKnowledgeEqTypedDict


class SearchKnowledgeAndEq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledgeAndKnowledgeEq


SearchKnowledgeFilterByAndTypedDict = TypeAliasType(
    "SearchKnowledgeFilterByAndTypedDict",
    Union[
        SearchKnowledgeAndEqTypedDict,
        SearchKnowledgeAndNeTypedDict,
        SearchKnowledgeAnd3TypedDict,
        SearchKnowledgeAndGteTypedDict,
        SearchKnowledgeAndLtTypedDict,
        SearchKnowledgeAndLteTypedDict,
        SearchKnowledgeAndInTypedDict,
        SearchKnowledgeAndNinTypedDict,
        SearchKnowledgeAndExistsTypedDict,
    ],
)


SearchKnowledgeFilterByAnd = TypeAliasType(
    "SearchKnowledgeFilterByAnd",
    Union[
        SearchKnowledgeAndEq,
        SearchKnowledgeAndNe,
        SearchKnowledgeAnd3,
        SearchKnowledgeAndGte,
        SearchKnowledgeAndLt,
        SearchKnowledgeAndLte,
        SearchKnowledgeAndIn,
        SearchKnowledgeAndNin,
        SearchKnowledgeAndExists,
    ],
)


class FilterByAndTypedDict(TypedDict):
    r"""And"""

    and_: List[Dict[str, SearchKnowledgeFilterByAndTypedDict]]


class FilterByAnd(BaseModel):
    r"""And"""

    and_: Annotated[
        List[Dict[str, SearchKnowledgeFilterByAnd]], pydantic.Field(alias="and")
    ]


class SearchKnowledge1ExistsTypedDict(TypedDict):
    r"""Exists"""

    exists: bool


class SearchKnowledge1Exists(BaseModel):
    r"""Exists"""

    exists: bool


SearchKnowledge1KnowledgeNinTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeNinTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeNin = TypeAliasType(
    "SearchKnowledge1KnowledgeNin", Union[str, float, bool]
)


class SearchKnowledge1NinTypedDict(TypedDict):
    r"""Not in"""

    nin: List[SearchKnowledge1KnowledgeNinTypedDict]


class SearchKnowledge1Nin(BaseModel):
    r"""Not in"""

    nin: List[SearchKnowledge1KnowledgeNin]


SearchKnowledge1KnowledgeInTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeInTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeIn = TypeAliasType(
    "SearchKnowledge1KnowledgeIn", Union[str, float, bool]
)


class SearchKnowledge1InTypedDict(TypedDict):
    r"""In"""

    in_: List[SearchKnowledge1KnowledgeInTypedDict]


class SearchKnowledge1In(BaseModel):
    r"""In"""

    in_: Annotated[List[SearchKnowledge1KnowledgeIn], pydantic.Field(alias="in")]


class SearchKnowledge1LteTypedDict(TypedDict):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledge1Lte(BaseModel):
    r"""Less than or equal to"""

    lte: float


class SearchKnowledge1LtTypedDict(TypedDict):
    r"""Less than"""

    lt: float


class SearchKnowledge1Lt(BaseModel):
    r"""Less than"""

    lt: float


class SearchKnowledge1GteTypedDict(TypedDict):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledge1Gte(BaseModel):
    r"""Greater than or equal to"""

    gte: float


class SearchKnowledge13TypedDict(TypedDict):
    gt: float


class SearchKnowledge13(BaseModel):
    gt: float


SearchKnowledge1KnowledgeNeTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeNeTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeNe = TypeAliasType(
    "SearchKnowledge1KnowledgeNe", Union[str, float, bool]
)


class SearchKnowledge1NeTypedDict(TypedDict):
    r"""Not equal to"""

    ne: SearchKnowledge1KnowledgeNeTypedDict


class SearchKnowledge1Ne(BaseModel):
    r"""Not equal to"""

    ne: SearchKnowledge1KnowledgeNe


SearchKnowledge1KnowledgeEqTypedDict = TypeAliasType(
    "SearchKnowledge1KnowledgeEqTypedDict", Union[str, float, bool]
)


SearchKnowledge1KnowledgeEq = TypeAliasType(
    "SearchKnowledge1KnowledgeEq", Union[str, float, bool]
)


class SearchKnowledge1EqTypedDict(TypedDict):
    r"""Equal to"""

    eq: SearchKnowledge1KnowledgeEqTypedDict


class SearchKnowledge1Eq(BaseModel):
    r"""Equal to"""

    eq: SearchKnowledge1KnowledgeEq


FilterBy1TypedDict = TypeAliasType(
    "FilterBy1TypedDict",
    Union[
        SearchKnowledge1EqTypedDict,
        SearchKnowledge1NeTypedDict,
        SearchKnowledge13TypedDict,
        SearchKnowledge1GteTypedDict,
        SearchKnowledge1LtTypedDict,
        SearchKnowledge1LteTypedDict,
        SearchKnowledge1InTypedDict,
        SearchKnowledge1NinTypedDict,
        SearchKnowledge1ExistsTypedDict,
    ],
)


FilterBy1 = TypeAliasType(
    "FilterBy1",
    Union[
        SearchKnowledge1Eq,
        SearchKnowledge1Ne,
        SearchKnowledge13,
        SearchKnowledge1Gte,
        SearchKnowledge1Lt,
        SearchKnowledge1Lte,
        SearchKnowledge1In,
        SearchKnowledge1Nin,
        SearchKnowledge1Exists,
    ],
)


FilterByTypedDict = TypeAliasType(
    "FilterByTypedDict",
    Union[FilterByAndTypedDict, FilterByOrTypedDict, Dict[str, FilterBy1TypedDict]],
)
r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""


FilterBy = TypeAliasType(
    "FilterBy", Union[FilterByAnd, FilterByOr, Dict[str, FilterBy1]]
)
r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""


class SearchOptionsTypedDict(TypedDict):
    r"""Additional search options"""

    include_vectors: NotRequired[bool]
    r"""Whether to include the vector in the chunk"""
    include_metadata: NotRequired[bool]
    r"""Whether to include the metadata in the chunk"""
    include_scores: NotRequired[bool]
    r"""Whether to include the scores in the chunk"""


class SearchOptions(BaseModel):
    r"""Additional search options"""

    include_vectors: Optional[bool] = None
    r"""Whether to include the vector in the chunk"""

    include_metadata: Optional[bool] = None
    r"""Whether to include the metadata in the chunk"""

    include_scores: Optional[bool] = None
    r"""Whether to include the scores in the chunk"""


class SearchKnowledgeRequestBodyTypedDict(TypedDict):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""
    top_k: NotRequired[int]
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`"""
    threshold: NotRequired[float]
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""
    filter_by: NotRequired[FilterByTypedDict]
    r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""
    search_options: NotRequired[SearchOptionsTypedDict]
    r"""Additional search options"""


class SearchKnowledgeRequestBody(BaseModel):
    r"""A search request for chunks in a knowledge base"""

    query: str
    r"""The query to use to search the knowledge base"""

    top_k: Optional[int] = None
    r"""The number of results to return. If not provided, will default to the knowledge base configured `top_k`"""

    threshold: Optional[float] = None
    r"""The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`"""

    filter_by: Optional[FilterBy] = None
    r"""The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information."""

    search_options: Optional[SearchOptions] = None
    r"""Additional search options"""


class SearchKnowledgeRequestTypedDict(TypedDict):
    knowledge_id: str
    r"""The unique identifier or key of the knowledge base"""
    request_body: NotRequired[SearchKnowledgeRequestBodyTypedDict]
    r"""A search request for chunks in a knowledge base"""


class SearchKnowledgeRequest(BaseModel):
    knowledge_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique identifier or key of the knowledge base"""

    request_body: Annotated[
        Optional[SearchKnowledgeRequestBody],
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ] = None
    r"""A search request for chunks in a knowledge base"""


class ScoresTypedDict(TypedDict):
    rerank_score: NotRequired[float]
    search_score: NotRequired[float]


class Scores(BaseModel):
    rerank_score: Optional[float] = None

    search_score: Optional[float] = None


class MatchesTypedDict(TypedDict):
    id: str
    text: str
    vector: NotRequired[List[float]]
    metadata: NotRequired[Dict[str, Any]]
    scores: NotRequired[ScoresTypedDict]


class Matches(BaseModel):
    id: str

    text: str

    vector: Optional[List[float]] = None

    metadata: Optional[Dict[str, Any]] = None

    scores: Optional[Scores] = None


class SearchKnowledgeResponseBodyTypedDict(TypedDict):
    r"""Search knowledge base"""

    matches: List[MatchesTypedDict]


class SearchKnowledgeResponseBody(BaseModel):
    r"""Search knowledge base"""

    matches: List[Matches]
