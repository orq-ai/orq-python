"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


ResponseDoneEventType = Literal["response.done",]


ResponseDoneEventFinishReason = Literal[
    "stop",
    "length",
    "tool_calls",
    "content_filter",
    "function_call",
    "max_iterations",
    "max_time",
]
r"""The reason why the agent stopped generating"""


class ResponseDoneEventPromptTokensDetailsTypedDict(TypedDict):
    cached_tokens: NotRequired[Nullable[int]]
    cache_creation_tokens: NotRequired[Nullable[int]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio input tokens consumed by the request."""


class ResponseDoneEventPromptTokensDetails(BaseModel):
    cached_tokens: OptionalNullable[int] = UNSET

    cache_creation_tokens: OptionalNullable[int] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio input tokens consumed by the request."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["cached_tokens", "cache_creation_tokens", "audio_tokens"]
        )
        nullable_fields = set(
            ["cached_tokens", "cache_creation_tokens", "audio_tokens"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ResponseDoneEventCompletionTokensDetailsTypedDict(TypedDict):
    reasoning_tokens: NotRequired[Nullable[float]]
    accepted_prediction_tokens: NotRequired[Nullable[float]]
    rejected_prediction_tokens: NotRequired[Nullable[float]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio output tokens produced by the response."""


class ResponseDoneEventCompletionTokensDetails(BaseModel):
    reasoning_tokens: OptionalNullable[float] = UNSET

    accepted_prediction_tokens: OptionalNullable[float] = UNSET

    rejected_prediction_tokens: OptionalNullable[float] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio output tokens produced by the response."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "reasoning_tokens",
                "accepted_prediction_tokens",
                "rejected_prediction_tokens",
                "audio_tokens",
            ]
        )
        nullable_fields = set(
            [
                "reasoning_tokens",
                "accepted_prediction_tokens",
                "rejected_prediction_tokens",
                "audio_tokens",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ResponseDoneEventUsageTypedDict(TypedDict):
    r"""Token usage statistics for the complete response"""

    completion_tokens: NotRequired[float]
    r"""Number of tokens in the generated completion."""
    prompt_tokens: NotRequired[float]
    r"""Number of tokens in the prompt."""
    total_tokens: NotRequired[float]
    r"""Total number of tokens used in the request (prompt + completion)."""
    prompt_tokens_details: NotRequired[
        Nullable[ResponseDoneEventPromptTokensDetailsTypedDict]
    ]
    completion_tokens_details: NotRequired[
        Nullable[ResponseDoneEventCompletionTokensDetailsTypedDict]
    ]


class ResponseDoneEventUsage(BaseModel):
    r"""Token usage statistics for the complete response"""

    completion_tokens: Optional[float] = None
    r"""Number of tokens in the generated completion."""

    prompt_tokens: Optional[float] = None
    r"""Number of tokens in the prompt."""

    total_tokens: Optional[float] = None
    r"""Total number of tokens used in the request (prompt + completion)."""

    prompt_tokens_details: OptionalNullable[ResponseDoneEventPromptTokensDetails] = (
        UNSET
    )

    completion_tokens_details: OptionalNullable[
        ResponseDoneEventCompletionTokensDetails
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "completion_tokens",
                "prompt_tokens",
                "total_tokens",
                "prompt_tokens_details",
                "completion_tokens_details",
            ]
        )
        nullable_fields = set(["prompt_tokens_details", "completion_tokens_details"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


ResponseDoneEventDataType = Literal["function",]


class ResponseDoneEventFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call"""
    arguments: NotRequired[str]
    r"""The arguments to pass to the function as JSON string"""


class ResponseDoneEventFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call"""

    arguments: Optional[str] = None
    r"""The arguments to pass to the function as JSON string"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseDoneEventPendingToolCallsTypedDict(TypedDict):
    id: str
    r"""Unique identifier for the tool call"""
    type: ResponseDoneEventDataType
    function: ResponseDoneEventFunctionTypedDict


class ResponseDoneEventPendingToolCalls(BaseModel):
    id: str
    r"""Unique identifier for the tool call"""

    type: ResponseDoneEventDataType

    function: ResponseDoneEventFunction


class ResponseDoneEventDataTypedDict(TypedDict):
    finish_reason: ResponseDoneEventFinishReason
    r"""The reason why the agent stopped generating"""
    usage: NotRequired[ResponseDoneEventUsageTypedDict]
    r"""Token usage statistics for the complete response"""
    pending_tool_calls: NotRequired[List[ResponseDoneEventPendingToolCallsTypedDict]]
    r"""Tool calls awaiting user response (when finishReason is function_call)"""


class ResponseDoneEventData(BaseModel):
    finish_reason: Annotated[
        ResponseDoneEventFinishReason, pydantic.Field(alias="finishReason")
    ]
    r"""The reason why the agent stopped generating"""

    usage: Optional[ResponseDoneEventUsage] = None
    r"""Token usage statistics for the complete response"""

    pending_tool_calls: Annotated[
        Optional[List[ResponseDoneEventPendingToolCalls]],
        pydantic.Field(alias="pendingToolCalls"),
    ] = None
    r"""Tool calls awaiting user response (when finishReason is function_call)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["usage", "pendingToolCalls"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ResponseDoneEventTypedDict(TypedDict):
    r"""Emitted when the agent completes processing. Contains the finish reason and usage statistics."""

    type: ResponseDoneEventType
    timestamp: str
    r"""ISO timestamp of when the event occurred"""
    data: ResponseDoneEventDataTypedDict


class ResponseDoneEvent(BaseModel):
    r"""Emitted when the agent completes processing. Contains the finish reason and usage statistics."""

    type: ResponseDoneEventType

    timestamp: str
    r"""ISO timestamp of when the event occurred"""

    data: ResponseDoneEventData
