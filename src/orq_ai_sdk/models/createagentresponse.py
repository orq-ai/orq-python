"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .agentresponsemessage import AgentResponseMessage, AgentResponseMessageTypedDict
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import model_serializer
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PromptTokensDetailsTypedDict(TypedDict):
    cached_tokens: NotRequired[Nullable[int]]
    cache_creation_tokens: NotRequired[Nullable[int]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio input tokens consumed by the request."""


class PromptTokensDetails(BaseModel):
    cached_tokens: OptionalNullable[int] = UNSET

    cache_creation_tokens: OptionalNullable[int] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio input tokens consumed by the request."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["cached_tokens", "cache_creation_tokens", "audio_tokens"]
        )
        nullable_fields = set(
            ["cached_tokens", "cache_creation_tokens", "audio_tokens"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CompletionTokensDetailsTypedDict(TypedDict):
    reasoning_tokens: NotRequired[Nullable[float]]
    accepted_prediction_tokens: NotRequired[Nullable[float]]
    rejected_prediction_tokens: NotRequired[Nullable[float]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio output tokens produced by the response."""


class CompletionTokensDetails(BaseModel):
    reasoning_tokens: OptionalNullable[float] = UNSET

    accepted_prediction_tokens: OptionalNullable[float] = UNSET

    rejected_prediction_tokens: OptionalNullable[float] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio output tokens produced by the response."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "reasoning_tokens",
                "accepted_prediction_tokens",
                "rejected_prediction_tokens",
                "audio_tokens",
            ]
        )
        nullable_fields = set(
            [
                "reasoning_tokens",
                "accepted_prediction_tokens",
                "rejected_prediction_tokens",
                "audio_tokens",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class UsageTypedDict(TypedDict):
    r"""Token usage from the agent execution"""

    completion_tokens: NotRequired[float]
    r"""Number of tokens in the generated completion."""
    prompt_tokens: NotRequired[float]
    r"""Number of tokens in the prompt."""
    total_tokens: NotRequired[float]
    r"""Total number of tokens used in the request (prompt + completion)."""
    prompt_tokens_details: NotRequired[Nullable[PromptTokensDetailsTypedDict]]
    completion_tokens_details: NotRequired[Nullable[CompletionTokensDetailsTypedDict]]


class Usage(BaseModel):
    r"""Token usage from the agent execution"""

    completion_tokens: Optional[float] = None
    r"""Number of tokens in the generated completion."""

    prompt_tokens: Optional[float] = None
    r"""Number of tokens in the prompt."""

    total_tokens: Optional[float] = None
    r"""Total number of tokens used in the request (prompt + completion)."""

    prompt_tokens_details: OptionalNullable[PromptTokensDetails] = UNSET

    completion_tokens_details: OptionalNullable[CompletionTokensDetails] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "completion_tokens",
                "prompt_tokens",
                "total_tokens",
                "prompt_tokens_details",
                "completion_tokens_details",
            ]
        )
        nullable_fields = set(["prompt_tokens_details", "completion_tokens_details"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


FinishReason = Literal[
    "stop",
    "length",
    "tool_calls",
    "content_filter",
    "function_call",
    "max_iterations",
    "max_time",
]
r"""The reason why the agent stopped generating"""


CreateAgentResponseType = Literal["function",]


class FunctionTypedDict(TypedDict):
    name: NotRequired[str]
    arguments: NotRequired[str]


class Function(BaseModel):
    name: Optional[str] = None

    arguments: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["name", "arguments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PendingToolCallsTypedDict(TypedDict):
    id: str
    type: CreateAgentResponseType
    function: FunctionTypedDict


class PendingToolCalls(BaseModel):
    id: str

    type: CreateAgentResponseType

    function: Function


class CreateAgentResponseTypedDict(TypedDict):
    r"""Response type from the create-response endpoint."""

    id: str
    r"""The unique response ID"""
    task_id: str
    r"""The agent execution task ID"""
    output: List[AgentResponseMessageTypedDict]
    r"""Array of messages from the agent execution"""
    created_at: str
    r"""ISO timestamp of response creation"""
    model: str
    r"""Model used in provider/model format"""
    usage: NotRequired[Nullable[UsageTypedDict]]
    r"""Token usage from the agent execution"""
    finish_reason: NotRequired[FinishReason]
    r"""The reason why the agent stopped generating"""
    pending_tool_calls: NotRequired[List[PendingToolCallsTypedDict]]
    r"""Tool calls awaiting user response (when finish_reason is function_call)"""


class CreateAgentResponse(BaseModel):
    r"""Response type from the create-response endpoint."""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique response ID"""

    task_id: str
    r"""The agent execution task ID"""

    output: List[AgentResponseMessage]
    r"""Array of messages from the agent execution"""

    created_at: str
    r"""ISO timestamp of response creation"""

    model: str
    r"""Model used in provider/model format"""

    usage: OptionalNullable[Usage] = UNSET
    r"""Token usage from the agent execution"""

    finish_reason: Optional[FinishReason] = None
    r"""The reason why the agent stopped generating"""

    pending_tool_calls: Optional[List[PendingToolCalls]] = None
    r"""Tool calls awaiting user response (when finish_reason is function_call)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["usage", "finish_reason", "pending_tool_calls"])
        nullable_fields = set(["usage"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
