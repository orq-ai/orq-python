"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .datapart import DataPart, DataPartTypedDict
from .filepart import FilePart, FilePartTypedDict
from .textpart import TextPart, TextPartTypedDict
from .toolcallpart import ToolCallPart, ToolCallPartTypedDict
from .toolresultpart import ToolResultPart, ToolResultPartTypedDict
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    RequestMetadata,
    get_discriminator,
)
import pydantic
from pydantic import Discriminator, Tag, model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


RoleToolMessage = Literal["tool",]
r"""Message containing tool execution results"""


RoleUserMessage = Literal["user",]
r"""Message from the end user"""


CreateAgentResponseRequestRoleTypedDict = TypeAliasType(
    "CreateAgentResponseRequestRoleTypedDict", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


CreateAgentResponseRequestRole = TypeAliasType(
    "CreateAgentResponseRequestRole", Union[RoleUserMessage, RoleToolMessage]
)
r"""Message role (user or tool for continuing executions)"""


CreateAgentResponseRequestPublicMessagePartKind = Literal["tool_result",]


class PublicMessagePartToolResultPartTypedDict(TypedDict):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: CreateAgentResponseRequestPublicMessagePartKind
    tool_call_id: str
    result: NotRequired[Any]
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartToolResultPart(BaseModel):
    r"""Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request."""

    kind: CreateAgentResponseRequestPublicMessagePartKind

    tool_call_id: str

    result: Optional[Any] = None

    metadata: Optional[Dict[str, Any]] = None


PublicMessagePartKind = Literal["file",]


class FileFileInURIFormatTypedDict(TypedDict):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class FileFileInURIFormat(BaseModel):
    r"""File in URI format. Check in the model's documentation for the supported mime types for the URI format"""

    uri: str
    r"""URL for the File content"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


class FileBinaryFormatTypedDict(TypedDict):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: str
    r"""base64 encoded content of the file"""
    mime_type: NotRequired[str]
    r"""Optional mimeType for the file"""
    name: NotRequired[str]
    r"""Optional name for the file"""


class FileBinaryFormat(BaseModel):
    r"""Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format."""

    bytes_: Annotated[str, pydantic.Field(alias="bytes")]
    r"""base64 encoded content of the file"""

    mime_type: Annotated[Optional[str], pydantic.Field(alias="mimeType")] = None
    r"""Optional mimeType for the file"""

    name: Optional[str] = None
    r"""Optional name for the file"""


PublicMessagePartFileTypedDict = TypeAliasType(
    "PublicMessagePartFileTypedDict",
    Union[FileBinaryFormatTypedDict, FileFileInURIFormatTypedDict],
)


PublicMessagePartFile = TypeAliasType(
    "PublicMessagePartFile", Union[FileBinaryFormat, FileFileInURIFormat]
)


class PublicMessagePartFilePartTypedDict(TypedDict):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: PublicMessagePartKind
    file: PublicMessagePartFileTypedDict
    metadata: NotRequired[Dict[str, Any]]


class PublicMessagePartFilePart(BaseModel):
    r"""File attachment part. Use this to send files (images, documents, etc.) to the agent for processing."""

    kind: PublicMessagePartKind

    file: PublicMessagePartFile

    metadata: Optional[Dict[str, Any]] = None


PublicMessagePartTypedDict = TypeAliasType(
    "PublicMessagePartTypedDict",
    Union[
        TextPartTypedDict,
        PublicMessagePartFilePartTypedDict,
        PublicMessagePartToolResultPartTypedDict,
    ],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


PublicMessagePart = TypeAliasType(
    "PublicMessagePart",
    Union[TextPart, PublicMessagePartFilePart, PublicMessagePartToolResultPart],
)
r"""Message part that can be provided by users. Use \"text\" for regular messages, \"file\" for attachments, or \"tool_result\" when responding to tool call requests."""


class A2AMessageTypedDict(TypedDict):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: CreateAgentResponseRequestRoleTypedDict
    r"""Message role (user or tool for continuing executions)"""
    parts: List[PublicMessagePartTypedDict]
    r"""A2A message parts (text, file, or tool_result only)"""
    message_id: NotRequired[str]
    r"""Optional A2A message ID in ULID format"""


class A2AMessage(BaseModel):
    r"""The A2A message to send to the agent (user input or tool results)"""

    role: CreateAgentResponseRequestRole
    r"""Message role (user or tool for continuing executions)"""

    parts: List[PublicMessagePart]
    r"""A2A message parts (text, file, or tool_result only)"""

    message_id: Annotated[Optional[str], pydantic.Field(alias="messageId")] = None
    r"""Optional A2A message ID in ULID format"""


class ContactTypedDict(TypedDict):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""
    display_name: NotRequired[str]
    r"""Display name of the contact"""
    email: NotRequired[str]
    r"""Email address of the contact"""
    metadata: NotRequired[List[Dict[str, Any]]]
    r"""A hash of key/value pairs containing any other data about the contact"""
    logo_url: NotRequired[str]
    r"""URL to the contact's avatar or logo"""
    tags: NotRequired[List[str]]
    r"""A list of tags associated with the contact"""


class Contact(BaseModel):
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    id: str
    r"""Unique identifier for the contact"""

    display_name: Optional[str] = None
    r"""Display name of the contact"""

    email: Optional[str] = None
    r"""Email address of the contact"""

    metadata: Optional[List[Dict[str, Any]]] = None
    r"""A hash of key/value pairs containing any other data about the contact"""

    logo_url: Optional[str] = None
    r"""URL to the contact's avatar or logo"""

    tags: Optional[List[str]] = None
    r"""A list of tags associated with the contact"""


class CreateAgentResponseRequestThreadTypedDict(TypedDict):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""
    tags: NotRequired[List[str]]
    r"""Optional tags to differentiate or categorize threads"""


class CreateAgentResponseRequestThread(BaseModel):
    r"""Thread information to group related requests"""

    id: str
    r"""Unique thread identifier to group related invocations."""

    tags: Optional[List[str]] = None
    r"""Optional tags to differentiate or categorize threads"""


class MemoryTypedDict(TypedDict):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class Memory(BaseModel):
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    entity_id: str
    r"""An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions."""


class CreateAgentResponseRequestRequestBodyTypedDict(TypedDict):
    message: A2AMessageTypedDict
    r"""The A2A message to send to the agent (user input or tool results)"""
    task_id: NotRequired[str]
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""
    variables: NotRequired[Dict[str, Any]]
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""
    contact: NotRequired[ContactTypedDict]
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""
    thread: NotRequired[CreateAgentResponseRequestThreadTypedDict]
    r"""Thread information to group related requests"""
    memory: NotRequired[MemoryTypedDict]
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""
    metadata: NotRequired[Dict[str, Any]]
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""
    background: NotRequired[bool]
    r"""If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors."""


class CreateAgentResponseRequestRequestBody(BaseModel):
    message: A2AMessage
    r"""The A2A message to send to the agent (user input or tool results)"""

    task_id: Optional[str] = None
    r"""Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue."""

    variables: Optional[Dict[str, Any]] = None
    r"""Optional variables for template replacement in system prompt, instructions, and messages"""

    contact: Optional[Contact] = None
    r"""Information about the contact making the request. If the contact does not exist, it will be created automatically."""

    thread: Optional[CreateAgentResponseRequestThread] = None
    r"""Thread information to group related requests"""

    memory: Optional[Memory] = None
    r"""Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions."""

    metadata: Optional[Dict[str, Any]] = None
    r"""Optional metadata for the agent invocation as key-value pairs that will be included in traces"""

    background: Optional[bool] = False
    r"""If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors."""


class CreateAgentResponseRequestRequestTypedDict(TypedDict):
    agent_key: str
    r"""The unique key of identifier of the agent to invoke"""
    request_body: CreateAgentResponseRequestRequestBodyTypedDict


class CreateAgentResponseRequestRequest(BaseModel):
    agent_key: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The unique key of identifier of the agent to invoke"""

    request_body: Annotated[
        CreateAgentResponseRequestRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="application/json")),
    ]


CreateAgentResponseRequestAgentsResponsesRole = Literal[
    "user",
    "agent",
    "tool",
    "system",
]


PartsTypedDict = TypeAliasType(
    "PartsTypedDict",
    Union[
        TextPartTypedDict,
        DataPartTypedDict,
        FilePartTypedDict,
        ToolResultPartTypedDict,
        ToolCallPartTypedDict,
    ],
)


Parts = Annotated[
    Union[
        Annotated[TextPart, Tag("text")],
        Annotated[DataPart, Tag("data")],
        Annotated[FilePart, Tag("file")],
        Annotated[ToolCallPart, Tag("tool_call")],
        Annotated[ToolResultPart, Tag("tool_result")],
    ],
    Discriminator(lambda m: get_discriminator(m, "kind", "kind")),
]


class OutputTypedDict(TypedDict):
    message_id: str
    role: CreateAgentResponseRequestAgentsResponsesRole
    parts: List[PartsTypedDict]
    metadata: NotRequired[Dict[str, Any]]


class Output(BaseModel):
    message_id: Annotated[str, pydantic.Field(alias="messageId")]

    role: CreateAgentResponseRequestAgentsResponsesRole

    parts: List[Parts]

    metadata: Optional[Dict[str, Any]] = None


class PromptTokensDetailsTypedDict(TypedDict):
    cached_tokens: NotRequired[Nullable[int]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio input tokens consumed by the request."""


class PromptTokensDetails(BaseModel):
    cached_tokens: OptionalNullable[int] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio input tokens consumed by the request."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["cached_tokens", "audio_tokens"]
        nullable_fields = ["cached_tokens", "audio_tokens"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CompletionTokensDetailsTypedDict(TypedDict):
    reasoning_tokens: NotRequired[Nullable[float]]
    accepted_prediction_tokens: NotRequired[Nullable[float]]
    rejected_prediction_tokens: NotRequired[Nullable[float]]
    audio_tokens: NotRequired[Nullable[int]]
    r"""The number of audio output tokens produced by the response."""


class CompletionTokensDetails(BaseModel):
    reasoning_tokens: OptionalNullable[float] = UNSET

    accepted_prediction_tokens: OptionalNullable[float] = UNSET

    rejected_prediction_tokens: OptionalNullable[float] = UNSET

    audio_tokens: OptionalNullable[int] = UNSET
    r"""The number of audio output tokens produced by the response."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "reasoning_tokens",
            "accepted_prediction_tokens",
            "rejected_prediction_tokens",
            "audio_tokens",
        ]
        nullable_fields = [
            "reasoning_tokens",
            "accepted_prediction_tokens",
            "rejected_prediction_tokens",
            "audio_tokens",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateAgentResponseRequestUsageTypedDict(TypedDict):
    r"""Token usage from the agent execution"""

    completion_tokens: NotRequired[float]
    r"""Number of tokens in the generated completion."""
    prompt_tokens: NotRequired[float]
    r"""Number of tokens in the prompt."""
    total_tokens: NotRequired[float]
    r"""Total number of tokens used in the request (prompt + completion)."""
    prompt_tokens_details: NotRequired[Nullable[PromptTokensDetailsTypedDict]]
    completion_tokens_details: NotRequired[Nullable[CompletionTokensDetailsTypedDict]]


class CreateAgentResponseRequestUsage(BaseModel):
    r"""Token usage from the agent execution"""

    completion_tokens: Optional[float] = None
    r"""Number of tokens in the generated completion."""

    prompt_tokens: Optional[float] = None
    r"""Number of tokens in the prompt."""

    total_tokens: Optional[float] = None
    r"""Total number of tokens used in the request (prompt + completion)."""

    prompt_tokens_details: OptionalNullable[PromptTokensDetails] = UNSET

    completion_tokens_details: OptionalNullable[CompletionTokensDetails] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "completion_tokens",
            "prompt_tokens",
            "total_tokens",
            "prompt_tokens_details",
            "completion_tokens_details",
        ]
        nullable_fields = ["prompt_tokens_details", "completion_tokens_details"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateAgentResponseRequestResponseBodyTypedDict(TypedDict):
    r"""Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details."""

    id: str
    r"""The unique response ID"""
    task_id: str
    r"""The agent execution task ID"""
    output: List[OutputTypedDict]
    r"""Array of messages from the agent execution"""
    created_at: str
    r"""ISO timestamp of response creation"""
    model: str
    r"""Model used in provider/model format"""
    usage: NotRequired[Nullable[CreateAgentResponseRequestUsageTypedDict]]
    r"""Token usage from the agent execution"""


class CreateAgentResponseRequestResponseBody(BaseModel):
    r"""Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details."""

    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique response ID"""

    task_id: str
    r"""The agent execution task ID"""

    output: List[Output]
    r"""Array of messages from the agent execution"""

    created_at: str
    r"""ISO timestamp of response creation"""

    model: str
    r"""Model used in provider/model format"""

    usage: OptionalNullable[CreateAgentResponseRequestUsage] = UNSET
    r"""Token usage from the agent execution"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["usage"]
        nullable_fields = ["usage"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
