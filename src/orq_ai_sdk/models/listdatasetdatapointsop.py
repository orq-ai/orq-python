"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from orq_ai_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from orq_ai_sdk.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    parse_datetime,
)
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class ListDatasetDatapointsRequestTypedDict(TypedDict):
    dataset_id: str
    limit: NotRequired[float]
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""
    starting_after: NotRequired[str]
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""
    ending_before: NotRequired[str]
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""


class ListDatasetDatapointsRequest(BaseModel):
    dataset_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]

    limit: Annotated[
        Optional[float],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 10
    r"""A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10"""

    starting_after: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list."""

    ending_before: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list."""


ListDatasetDatapointsObject = Literal["list"]

ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole = Literal["tool"]
r"""The role of the messages author, in this case tool."""

ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict",
    Union[str, List[str]],
)
r"""The contents of the tool message."""


ListDatasetDatapointsMessagesDatasetsResponseContent = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsResponseContent", Union[str, List[str]]
)
r"""The contents of the tool message."""


class ListDatasetDatapointsMessagesToolMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case tool."""
    content: ListDatasetDatapointsMessagesDatasetsResponseContentTypedDict
    r"""The contents of the tool message."""
    tool_call_id: str
    r"""Tool call that this message is responding to."""


class ListDatasetDatapointsMessagesToolMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponse200ApplicationJSONRole
    r"""The role of the messages author, in this case tool."""

    content: ListDatasetDatapointsMessagesDatasetsResponseContent
    r"""The contents of the tool message."""

    tool_call_id: str
    r"""Tool call that this message is responding to."""


ListDatasetDatapoints2DatasetsResponse200ApplicationJSONResponseBodyType = Literal[
    "refusal"
]
r"""The type of the content part."""


class ListDatasetDatapoints2RefusalContentPartTypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsResponse200ApplicationJSONResponseBodyType
    r"""The type of the content part."""
    refusal: str
    r"""The refusal message generated by the model."""


class ListDatasetDatapoints2RefusalContentPart(BaseModel):
    type: ListDatasetDatapoints2DatasetsResponse200ApplicationJSONResponseBodyType
    r"""The type of the content part."""

    refusal: str
    r"""The refusal message generated by the model."""


ListDatasetDatapoints2DatasetsResponse200ApplicationJSONType = Literal["text"]
r"""The type of the content part."""


class ListDatasetDatapoints2TextContentPartTypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsResponse200ApplicationJSONType
    r"""The type of the content part."""
    text: str
    r"""The text content."""


class ListDatasetDatapoints2TextContentPart(BaseModel):
    type: ListDatasetDatapoints2DatasetsResponse200ApplicationJSONType
    r"""The type of the content part."""

    text: str
    r"""The text content."""


ListDatasetDatapointsContentDatasets2TypedDict = TypeAliasType(
    "ListDatasetDatapointsContentDatasets2TypedDict",
    Union[
        ListDatasetDatapoints2TextContentPartTypedDict,
        ListDatasetDatapoints2RefusalContentPartTypedDict,
    ],
)


ListDatasetDatapointsContentDatasets2 = TypeAliasType(
    "ListDatasetDatapointsContentDatasets2",
    Union[
        ListDatasetDatapoints2TextContentPart, ListDatasetDatapoints2RefusalContentPart
    ],
)


ListDatasetDatapointsMessagesDatasetsContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsContentTypedDict",
    Union[str, List[ListDatasetDatapointsContentDatasets2TypedDict]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


ListDatasetDatapointsMessagesDatasetsContent = TypeAliasType(
    "ListDatasetDatapointsMessagesDatasetsContent",
    Union[str, List[ListDatasetDatapointsContentDatasets2]],
)
r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""


ListDatasetDatapointsMessagesDatasetsResponse200Role = Literal["assistant"]
r"""The role of the messages author, in this case `assistant`."""


class ListDatasetDatapointsMessagesAudioTypedDict(TypedDict):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


class ListDatasetDatapointsMessagesAudio(BaseModel):
    r"""Data about a previous audio response from the model."""

    id: str
    r"""Unique identifier for a previous audio response from the model."""


ListDatasetDatapointsMessagesType = Literal["function"]
r"""The type of the tool. Currently, only `function` is supported."""


class ListDatasetDatapointsMessagesFunctionTypedDict(TypedDict):
    name: NotRequired[str]
    r"""The name of the function to call."""
    arguments: NotRequired[str]
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class ListDatasetDatapointsMessagesFunction(BaseModel):
    name: Optional[str] = None
    r"""The name of the function to call."""

    arguments: Optional[str] = None
    r"""The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."""


class ListDatasetDatapointsMessagesToolCallsTypedDict(TypedDict):
    id: str
    r"""The ID of the tool call."""
    type: ListDatasetDatapointsMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""
    function: ListDatasetDatapointsMessagesFunctionTypedDict


class ListDatasetDatapointsMessagesToolCalls(BaseModel):
    id: str
    r"""The ID of the tool call."""

    type: ListDatasetDatapointsMessagesType
    r"""The type of the tool. Currently, only `function` is supported."""

    function: ListDatasetDatapointsMessagesFunction


class ListDatasetDatapointsMessagesAssistantMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case `assistant`."""
    content: NotRequired[
        Nullable[ListDatasetDatapointsMessagesDatasetsContentTypedDict]
    ]
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""
    refusal: NotRequired[Nullable[str]]
    r"""The refusal message by the assistant."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""
    audio: NotRequired[Nullable[ListDatasetDatapointsMessagesAudioTypedDict]]
    r"""Data about a previous audio response from the model."""
    tool_calls: NotRequired[List[ListDatasetDatapointsMessagesToolCallsTypedDict]]
    r"""The tool calls generated by the model, such as function calls."""
    reasoning: NotRequired[str]
    r"""Internal thought process of the model"""
    reasoning_signature: NotRequired[str]
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""
    redacted_reasoning: NotRequired[str]
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""


class ListDatasetDatapointsMessagesAssistantMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponse200Role
    r"""The role of the messages author, in this case `assistant`."""

    content: OptionalNullable[ListDatasetDatapointsMessagesDatasetsContent] = UNSET
    r"""The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified."""

    refusal: OptionalNullable[str] = UNSET
    r"""The refusal message by the assistant."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""

    audio: OptionalNullable[ListDatasetDatapointsMessagesAudio] = UNSET
    r"""Data about a previous audio response from the model."""

    tool_calls: Optional[List[ListDatasetDatapointsMessagesToolCalls]] = None
    r"""The tool calls generated by the model, such as function calls."""

    reasoning: Optional[str] = None
    r"""Internal thought process of the model"""

    reasoning_signature: Optional[str] = None
    r"""The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`."""

    redacted_reasoning: Optional[str] = None
    r"""Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "content",
            "refusal",
            "name",
            "audio",
            "tool_calls",
            "reasoning",
            "reasoning_signature",
            "redacted_reasoning",
        ]
        nullable_fields = ["content", "refusal", "audio"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


ListDatasetDatapointsMessagesDatasetsResponseRole = Literal["user"]
r"""The role of the messages author, in this case `user`."""

ListDatasetDatapoints2DatasetsResponse200Type = Literal["file"]
r"""The type of the content part. Always `file`."""


class ListDatasetDatapoints2FileTypedDict(TypedDict):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""
    filename: str
    r"""The name of the file, used when passing the file to the model as a string."""


class ListDatasetDatapoints2File(BaseModel):
    file_data: str
    r"""The base64 encoded file data, used when passing the file to the model as a string."""

    filename: str
    r"""The name of the file, used when passing the file to the model as a string."""


class ListDatasetDatapoints24TypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsResponse200Type
    r"""The type of the content part. Always `file`."""
    file: ListDatasetDatapoints2FileTypedDict


class ListDatasetDatapoints24(BaseModel):
    type: ListDatasetDatapoints2DatasetsResponse200Type
    r"""The type of the content part. Always `file`."""

    file: ListDatasetDatapoints2File


ListDatasetDatapoints2DatasetsResponseType = Literal["input_audio"]

ListDatasetDatapoints2Format = Literal["mp3", "wav"]
r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class ListDatasetDatapoints2InputAudioTypedDict(TypedDict):
    data: str
    r"""Base64 encoded audio data."""
    format_: ListDatasetDatapoints2Format
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class ListDatasetDatapoints2InputAudio(BaseModel):
    data: str
    r"""Base64 encoded audio data."""

    format_: Annotated[ListDatasetDatapoints2Format, pydantic.Field(alias="format")]
    r"""The format of the encoded audio data. Currently supports `wav` and `mp3`."""


class ListDatasetDatapoints23TypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsResponseType
    input_audio: ListDatasetDatapoints2InputAudioTypedDict


class ListDatasetDatapoints23(BaseModel):
    type: ListDatasetDatapoints2DatasetsResponseType

    input_audio: ListDatasetDatapoints2InputAudio


ListDatasetDatapoints2DatasetsType = Literal["image_url"]

ListDatasetDatapoints2Detail = Literal["low", "high", "auto"]
r"""Specifies the detail level of the image."""


class ListDatasetDatapoints2ImageURLTypedDict(TypedDict):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""
    detail: NotRequired[ListDatasetDatapoints2Detail]
    r"""Specifies the detail level of the image."""


class ListDatasetDatapoints2ImageURL(BaseModel):
    url: str
    r"""Either a URL of the image or the base64 encoded image data."""

    detail: Optional[ListDatasetDatapoints2Detail] = None
    r"""Specifies the detail level of the image."""


class ListDatasetDatapoints22TypedDict(TypedDict):
    type: ListDatasetDatapoints2DatasetsType
    image_url: ListDatasetDatapoints2ImageURLTypedDict


class ListDatasetDatapoints22(BaseModel):
    type: ListDatasetDatapoints2DatasetsType

    image_url: ListDatasetDatapoints2ImageURL


ListDatasetDatapoints2Type = Literal["text"]


class ListDatasetDatapoints21TypedDict(TypedDict):
    type: ListDatasetDatapoints2Type
    text: str


class ListDatasetDatapoints21(BaseModel):
    type: ListDatasetDatapoints2Type

    text: str


ListDatasetDatapointsContent2TypedDict = TypeAliasType(
    "ListDatasetDatapointsContent2TypedDict",
    Union[
        ListDatasetDatapoints21TypedDict,
        ListDatasetDatapoints22TypedDict,
        ListDatasetDatapoints23TypedDict,
        ListDatasetDatapoints24TypedDict,
    ],
)


ListDatasetDatapointsContent2 = TypeAliasType(
    "ListDatasetDatapointsContent2",
    Union[
        ListDatasetDatapoints21,
        ListDatasetDatapoints22,
        ListDatasetDatapoints23,
        ListDatasetDatapoints24,
    ],
)


ListDatasetDatapointsMessagesContentTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesContentTypedDict",
    Union[str, List[ListDatasetDatapointsContent2TypedDict]],
)
r"""The contents of the user message."""


ListDatasetDatapointsMessagesContent = TypeAliasType(
    "ListDatasetDatapointsMessagesContent",
    Union[str, List[ListDatasetDatapointsContent2]],
)
r"""The contents of the user message."""


class ListDatasetDatapointsMessagesUserMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `user`."""
    content: ListDatasetDatapointsMessagesContentTypedDict
    r"""The contents of the user message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesUserMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsResponseRole
    r"""The role of the messages author, in this case `user`."""

    content: ListDatasetDatapointsMessagesContent
    r"""The contents of the user message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


ListDatasetDatapointsMessagesDatasetsRole = Literal["system"]
r"""The role of the messages author, in this case `system`."""


class ListDatasetDatapointsMessagesSystemMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesDatasetsRole
    r"""The role of the messages author, in this case `system`."""
    content: str
    r"""The contents of the system message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesSystemMessage(BaseModel):
    role: ListDatasetDatapointsMessagesDatasetsRole
    r"""The role of the messages author, in this case `system`."""

    content: str
    r"""The contents of the system message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


ListDatasetDatapointsMessagesRole = Literal["developer"]
r"""The role of the messages author, in this case  `developer`."""


class ListDatasetDatapointsMessagesDeveloperMessageTypedDict(TypedDict):
    role: ListDatasetDatapointsMessagesRole
    r"""The role of the messages author, in this case  `developer`."""
    content: str
    r"""The contents of the developer message."""
    name: NotRequired[str]
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


class ListDatasetDatapointsMessagesDeveloperMessage(BaseModel):
    role: ListDatasetDatapointsMessagesRole
    r"""The role of the messages author, in this case  `developer`."""

    content: str
    r"""The contents of the developer message."""

    name: Optional[str] = None
    r"""An optional name for the participant. Provides the model information to differentiate between participants of the same role."""


ListDatasetDatapointsMessagesTypedDict = TypeAliasType(
    "ListDatasetDatapointsMessagesTypedDict",
    Union[
        ListDatasetDatapointsMessagesDeveloperMessageTypedDict,
        ListDatasetDatapointsMessagesSystemMessageTypedDict,
        ListDatasetDatapointsMessagesUserMessageTypedDict,
        ListDatasetDatapointsMessagesToolMessageTypedDict,
        ListDatasetDatapointsMessagesAssistantMessageTypedDict,
    ],
)


ListDatasetDatapointsMessages = TypeAliasType(
    "ListDatasetDatapointsMessages",
    Union[
        ListDatasetDatapointsMessagesDeveloperMessage,
        ListDatasetDatapointsMessagesSystemMessage,
        ListDatasetDatapointsMessagesUserMessage,
        ListDatasetDatapointsMessagesToolMessage,
        ListDatasetDatapointsMessagesAssistantMessage,
    ],
)


class ListDatasetDatapointsDataTypedDict(TypedDict):
    id: str
    r"""The unique identifier of the dataset item"""
    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""
    dataset_id: str
    r"""The unique identifier of the dataset"""
    inputs: NotRequired[Dict[str, Any]]
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""
    messages: NotRequired[List[ListDatasetDatapointsMessagesTypedDict]]
    r"""A list of messages comprising the conversation so far"""
    expected_output: NotRequired[str]
    created_by_id: NotRequired[str]
    r"""The unique identifier of the user who created the dataset"""
    updated_by_id: NotRequired[str]
    r"""The unique identifier of the user who last updated the dataset"""
    created: NotRequired[datetime]
    r"""The date and time the resource was created"""
    updated: NotRequired[datetime]
    r"""The date and time the resource was last updated"""


class ListDatasetDatapointsData(BaseModel):
    id: Annotated[str, pydantic.Field(alias="_id")]
    r"""The unique identifier of the dataset item"""

    workspace_id: str
    r"""The unique identifier of the workspace it belongs to"""

    dataset_id: str
    r"""The unique identifier of the dataset"""

    inputs: Optional[Dict[str, Any]] = None
    r"""The inputs of the dataset. Key value pairs where the key is the input name and the value is the input value. Nested objects are not supported."""

    messages: Optional[List[ListDatasetDatapointsMessages]] = None
    r"""A list of messages comprising the conversation so far"""

    expected_output: Optional[str] = None

    created_by_id: Optional[str] = None
    r"""The unique identifier of the user who created the dataset"""

    updated_by_id: Optional[str] = None
    r"""The unique identifier of the user who last updated the dataset"""

    created: Optional[datetime] = None
    r"""The date and time the resource was created"""

    updated: Optional[datetime] = parse_datetime("2025-07-27T19:30:10.854Z")
    r"""The date and time the resource was last updated"""


class ListDatasetDatapointsResponseBodyTypedDict(TypedDict):
    r"""Datapoints retrieved successfully. Returns a paginated list of datapoints."""

    object: ListDatasetDatapointsObject
    data: List[ListDatasetDatapointsDataTypedDict]
    has_more: bool


class ListDatasetDatapointsResponseBody(BaseModel):
    r"""Datapoints retrieved successfully. Returns a paginated list of datapoints."""

    object: ListDatasetDatapointsObject

    data: List[ListDatasetDatapointsData]

    has_more: bool
