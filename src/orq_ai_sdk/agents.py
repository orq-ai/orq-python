"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .sdkconfiguration import SDKConfiguration
from orq_ai_sdk import models, utils
from orq_ai_sdk._hooks import HookContext
from orq_ai_sdk.models import (
    createagentrequestop as models_createagentrequestop,
    invokeagentop as models_invokeagentop,
    runagentop as models_runagentop,
    streamagentop as models_streamagentop,
    streamrunagentop as models_streamrunagentop,
    updateagentop as models_updateagentop,
)
from orq_ai_sdk.responses import Responses
from orq_ai_sdk.types import OptionalNullable, UNSET
from orq_ai_sdk.utils import eventstreaming, get_security_from_env
from orq_ai_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union
from typing_extensions import deprecated


class Agents(BaseSDK):
    responses: Responses

    def __init__(
        self, sdk_config: SDKConfiguration, parent_ref: Optional[object] = None
    ) -> None:
        BaseSDK.__init__(self, sdk_config, parent_ref=parent_ref)
        self.sdk_configuration = sdk_config
        self._init_sdks()

    def _init_sdks(self):
        self.responses = Responses(self.sdk_configuration, parent_ref=self.parent_ref)

    def create(
        self,
        *,
        key: str,
        role: str,
        description: str,
        instructions: str,
        path: str,
        model: Union[
            models_createagentrequestop.ModelConfiguration,
            models_createagentrequestop.ModelConfigurationTypedDict,
        ],
        settings: Union[
            models_createagentrequestop.Settings,
            models_createagentrequestop.SettingsTypedDict,
        ],
        display_name: Optional[str] = None,
        system_prompt: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_createagentrequestop.FallbackModelConfiguration],
                List[models_createagentrequestop.FallbackModelConfigurationTypedDict],
            ]
        ] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_createagentrequestop.KnowledgeBases],
                List[models_createagentrequestop.KnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_createagentrequestop.TeamOfAgents],
                List[models_createagentrequestop.TeamOfAgentsTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.CreateAgentRequestResponseBody]:
        r"""Create agent

        Creates a new agent with the specified configuration, including model selection, instructions, tools, and knowledge bases. Agents are intelligent assistants that can execute tasks, interact with tools, and maintain context through memory stores. The agent can be configured with a primary model and optional fallback models for automatic failover, custom instructions for behavior control, and various settings to control execution limits and tool usage.

        :param key: Unique identifier for the agent within the workspace
        :param role: The role or function of the agent
        :param description: A brief description of what the agent does
        :param instructions: Detailed instructions that guide the agent's behavior
        :param path: The path where the agent will be stored in the project structure. The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param model: Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
        :param settings: Configuration settings for the agent's behavior
        :param display_name: agent display name within the workspace
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param memory_stores: Optional array of memory store identifiers for the agent to access. Accepts both memory store IDs and keys.
        :param knowledge_bases: Optional array of knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param variables:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAgentRequestRequestBody(
            key=key,
            display_name=display_name,
            role=role,
            description=description,
            instructions=instructions,
            system_prompt=system_prompt,
            path=path,
            model=utils.get_pydantic_model(model, models.ModelConfiguration),
            fallback_models=utils.get_pydantic_model(
                fallback_models, Optional[List[models.FallbackModelConfiguration]]
            ),
            settings=utils.get_pydantic_model(settings, models.Settings),
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.KnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.TeamOfAgents]]
            ),
            variables=variables,
        )

        req = self._build_request(
            method="POST",
            path="/v2/agents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAgentRequestRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateAgentRequest",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                Optional[models.CreateAgentRequestResponseBody], http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            response_data = unmarshal_json_response(
                models.CreateAgentRequestAgentsResponseBodyData, http_res
            )
            raise models.CreateAgentRequestAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        key: str,
        role: str,
        description: str,
        instructions: str,
        path: str,
        model: Union[
            models_createagentrequestop.ModelConfiguration,
            models_createagentrequestop.ModelConfigurationTypedDict,
        ],
        settings: Union[
            models_createagentrequestop.Settings,
            models_createagentrequestop.SettingsTypedDict,
        ],
        display_name: Optional[str] = None,
        system_prompt: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_createagentrequestop.FallbackModelConfiguration],
                List[models_createagentrequestop.FallbackModelConfigurationTypedDict],
            ]
        ] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_createagentrequestop.KnowledgeBases],
                List[models_createagentrequestop.KnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_createagentrequestop.TeamOfAgents],
                List[models_createagentrequestop.TeamOfAgentsTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.CreateAgentRequestResponseBody]:
        r"""Create agent

        Creates a new agent with the specified configuration, including model selection, instructions, tools, and knowledge bases. Agents are intelligent assistants that can execute tasks, interact with tools, and maintain context through memory stores. The agent can be configured with a primary model and optional fallback models for automatic failover, custom instructions for behavior control, and various settings to control execution limits and tool usage.

        :param key: Unique identifier for the agent within the workspace
        :param role: The role or function of the agent
        :param description: A brief description of what the agent does
        :param instructions: Detailed instructions that guide the agent's behavior
        :param path: The path where the agent will be stored in the project structure. The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param model: Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
        :param settings: Configuration settings for the agent's behavior
        :param display_name: agent display name within the workspace
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param memory_stores: Optional array of memory store identifiers for the agent to access. Accepts both memory store IDs and keys.
        :param knowledge_bases: Optional array of knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param variables:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateAgentRequestRequestBody(
            key=key,
            display_name=display_name,
            role=role,
            description=description,
            instructions=instructions,
            system_prompt=system_prompt,
            path=path,
            model=utils.get_pydantic_model(model, models.ModelConfiguration),
            fallback_models=utils.get_pydantic_model(
                fallback_models, Optional[List[models.FallbackModelConfiguration]]
            ),
            settings=utils.get_pydantic_model(settings, models.Settings),
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.KnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.TeamOfAgents]]
            ),
            variables=variables,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/agents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.CreateAgentRequestRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="CreateAgentRequest",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["409", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                Optional[models.CreateAgentRequestResponseBody], http_res
            )
        if utils.match_response(http_res, "409", "application/json"):
            response_data = unmarshal_json_response(
                models.CreateAgentRequestAgentsResponseBodyData, http_res
            )
            raise models.CreateAgentRequestAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        agent_key: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete agent

        Permanently removes an agent from the workspace. This operation is irreversible and will delete all associated configuration including model assignments, tools, knowledge bases, memory stores, and cached data. Active agent sessions will be terminated, and the agent key will become available for reuse.

        :param agent_key: The unique key of the agent to delete
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAgentRequest(
            agent_key=agent_key,
        )

        req = self._build_request(
            method="DELETE",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.DeleteAgentResponseBodyData, http_res
            )
            raise models.DeleteAgentResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        agent_key: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete agent

        Permanently removes an agent from the workspace. This operation is irreversible and will delete all associated configuration including model assignments, tools, knowledge bases, memory stores, and cached data. Active agent sessions will be terminated, and the agent key will become available for reuse.

        :param agent_key: The unique key of the agent to delete
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteAgentRequest(
            agent_key=agent_key,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="DeleteAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.DeleteAgentResponseBodyData, http_res
            )
            raise models.DeleteAgentResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def retrieve(
        self,
        *,
        agent_key: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.RetrieveAgentRequestResponseBody]:
        r"""Retrieve agent

        Retrieves detailed information about a specific agent identified by its unique key or identifier. Returns the complete agent manifest including configuration settings, model assignments (primary and fallback), tools, knowledge bases, memory stores, instructions, and execution parameters. Use this endpoint to fetch the current state and configuration of an individual agent.

        :param agent_key: The unique key of the agent to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetrieveAgentRequestRequest(
            agent_key=agent_key,
        )

        req = self._build_request(
            method="GET",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetrieveAgentRequest",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.RetrieveAgentRequestResponseBody], http_res
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.RetrieveAgentRequestAgentsResponseBodyData, http_res
            )
            raise models.RetrieveAgentRequestAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def retrieve_async(
        self,
        *,
        agent_key: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.RetrieveAgentRequestResponseBody]:
        r"""Retrieve agent

        Retrieves detailed information about a specific agent identified by its unique key or identifier. Returns the complete agent manifest including configuration settings, model assignments (primary and fallback), tools, knowledge bases, memory stores, instructions, and execution parameters. Use this endpoint to fetch the current state and configuration of an individual agent.

        :param agent_key: The unique key of the agent to retrieve
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RetrieveAgentRequestRequest(
            agent_key=agent_key,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RetrieveAgentRequest",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.RetrieveAgentRequestResponseBody], http_res
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.RetrieveAgentRequestAgentsResponseBodyData, http_res
            )
            raise models.RetrieveAgentRequestAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def update(
        self,
        *,
        agent_key: str,
        key: Optional[str] = None,
        display_name: Optional[str] = None,
        project_id: Optional[str] = None,
        role: Optional[str] = None,
        description: Optional[str] = None,
        instructions: Optional[str] = None,
        system_prompt: Optional[str] = None,
        model: Optional[
            Union[
                models_updateagentop.UpdateAgentModelConfiguration,
                models_updateagentop.UpdateAgentModelConfigurationTypedDict,
            ]
        ] = None,
        fallback_models: Optional[
            Union[
                List[models_updateagentop.UpdateAgentFallbackModelConfiguration],
                List[
                    models_updateagentop.UpdateAgentFallbackModelConfigurationTypedDict
                ],
            ]
        ] = None,
        settings: Optional[
            Union[
                models_updateagentop.UpdateAgentSettings,
                models_updateagentop.UpdateAgentSettingsTypedDict,
            ]
        ] = None,
        path: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_updateagentop.UpdateAgentKnowledgeBases],
                List[models_updateagentop.UpdateAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_updateagentop.UpdateAgentTeamOfAgents],
                List[models_updateagentop.UpdateAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.UpdateAgentResponseBody]:
        r"""Update agent

        Modifies an existing agent's configuration with partial updates. Supports updating any aspect of the agent including model assignments (primary and fallback), instructions, tools, knowledge bases, memory stores, and execution parameters. Only the fields provided in the request body will be updated; all other fields remain unchanged. Changes take effect immediately for new agent invocations.

        :param agent_key: The unique key of the agent to update
        :param key:
        :param display_name:
        :param project_id:
        :param role:
        :param description:
        :param instructions:
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param model: Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param settings:
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param memory_stores: Array of memory store identifiers. Accepts both memory store IDs and keys.
        :param knowledge_bases:
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param variables: Extracted variables from agent instructions
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAgentRequest(
            agent_key=agent_key,
            request_body=models.UpdateAgentUpdateAgentRequest(
                key=key,
                display_name=display_name,
                project_id=project_id,
                role=role,
                description=description,
                instructions=instructions,
                system_prompt=system_prompt,
                model=utils.get_pydantic_model(
                    model, Optional[models.UpdateAgentModelConfiguration]
                ),
                fallback_models=utils.get_pydantic_model(
                    fallback_models,
                    Optional[List[models.UpdateAgentFallbackModelConfiguration]],
                ),
                settings=utils.get_pydantic_model(
                    settings, Optional[models.UpdateAgentSettings]
                ),
                path=path,
                memory_stores=memory_stores,
                knowledge_bases=utils.get_pydantic_model(
                    knowledge_bases, Optional[List[models.UpdateAgentKnowledgeBases]]
                ),
                team_of_agents=utils.get_pydantic_model(
                    team_of_agents, Optional[List[models.UpdateAgentTeamOfAgents]]
                ),
                variables=variables,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.UpdateAgentUpdateAgentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.UpdateAgentResponseBody], http_res
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.UpdateAgentAgentsResponseBodyData, http_res
            )
            raise models.UpdateAgentAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        agent_key: str,
        key: Optional[str] = None,
        display_name: Optional[str] = None,
        project_id: Optional[str] = None,
        role: Optional[str] = None,
        description: Optional[str] = None,
        instructions: Optional[str] = None,
        system_prompt: Optional[str] = None,
        model: Optional[
            Union[
                models_updateagentop.UpdateAgentModelConfiguration,
                models_updateagentop.UpdateAgentModelConfigurationTypedDict,
            ]
        ] = None,
        fallback_models: Optional[
            Union[
                List[models_updateagentop.UpdateAgentFallbackModelConfiguration],
                List[
                    models_updateagentop.UpdateAgentFallbackModelConfigurationTypedDict
                ],
            ]
        ] = None,
        settings: Optional[
            Union[
                models_updateagentop.UpdateAgentSettings,
                models_updateagentop.UpdateAgentSettingsTypedDict,
            ]
        ] = None,
        path: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_updateagentop.UpdateAgentKnowledgeBases],
                List[models_updateagentop.UpdateAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_updateagentop.UpdateAgentTeamOfAgents],
                List[models_updateagentop.UpdateAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.UpdateAgentResponseBody]:
        r"""Update agent

        Modifies an existing agent's configuration with partial updates. Supports updating any aspect of the agent including model assignments (primary and fallback), instructions, tools, knowledge bases, memory stores, and execution parameters. Only the fields provided in the request body will be updated; all other fields remain unchanged. Changes take effect immediately for new agent invocations.

        :param agent_key: The unique key of the agent to update
        :param key:
        :param display_name:
        :param project_id:
        :param role:
        :param description:
        :param instructions:
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param model: Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param settings:
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param memory_stores: Array of memory store identifiers. Accepts both memory store IDs and keys.
        :param knowledge_bases:
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param variables: Extracted variables from agent instructions
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateAgentRequest(
            agent_key=agent_key,
            request_body=models.UpdateAgentUpdateAgentRequest(
                key=key,
                display_name=display_name,
                project_id=project_id,
                role=role,
                description=description,
                instructions=instructions,
                system_prompt=system_prompt,
                model=utils.get_pydantic_model(
                    model, Optional[models.UpdateAgentModelConfiguration]
                ),
                fallback_models=utils.get_pydantic_model(
                    fallback_models,
                    Optional[List[models.UpdateAgentFallbackModelConfiguration]],
                ),
                settings=utils.get_pydantic_model(
                    settings, Optional[models.UpdateAgentSettings]
                ),
                path=path,
                memory_stores=memory_stores,
                knowledge_bases=utils.get_pydantic_model(
                    knowledge_bases, Optional[List[models.UpdateAgentKnowledgeBases]]
                ),
                team_of_agents=utils.get_pydantic_model(
                    team_of_agents, Optional[List[models.UpdateAgentTeamOfAgents]]
                ),
                variables=variables,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/v2/agents/{agent_key}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.UpdateAgentUpdateAgentRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="UpdateAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.UpdateAgentResponseBody], http_res
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.UpdateAgentAgentsResponseBodyData, http_res
            )
            raise models.UpdateAgentAgentsResponseBody(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    def invoke(
        self,
        *,
        key: str,
        message: Union[
            models_invokeagentop.InvokeAgentA2AMessage,
            models_invokeagentop.InvokeAgentA2AMessageTypedDict,
        ],
        task_id: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_invokeagentop.InvokeAgentContact,
                models_invokeagentop.InvokeAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_invokeagentop.InvokeAgentThread,
                models_invokeagentop.InvokeAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_invokeagentop.InvokeAgentMemory,
                models_invokeagentop.InvokeAgentMemoryTypedDict,
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.InvokeAgentA2ATaskResponse]:
        r"""Execute an agent task

        Invokes an agent to perform a task with the provided input message. The agent will process the request using its configured model and tools, maintaining context through memory stores if configured. Supports automatic model fallback on primary model failure, tool execution, knowledge base retrieval, and continuation of previous conversations. Returns a task response that can be used to track execution status and retrieve results.

        :param key: The key or ID of the agent to invoke
        :param message: The A2A message to send to the agent (user input or tool results)
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param metadata: Optional metadata for the agent invocation as key-value pairs that will be included in traces
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.InvokeAgentRequest(
            key=key,
            request_body=models.InvokeAgentRequestBody(
                task_id=task_id,
                message=utils.get_pydantic_model(message, models.InvokeAgentA2AMessage),
                variables=variables,
                contact=utils.get_pydantic_model(
                    contact, Optional[models.InvokeAgentContact]
                ),
                thread=utils.get_pydantic_model(
                    thread, Optional[models.InvokeAgentThread]
                ),
                memory=utils.get_pydantic_model(
                    memory, Optional[models.InvokeAgentMemory]
                ),
                metadata=metadata,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/agents/{key}/task",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.InvokeAgentRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="InvokeAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.InvokeAgentA2ATaskResponse], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    async def invoke_async(
        self,
        *,
        key: str,
        message: Union[
            models_invokeagentop.InvokeAgentA2AMessage,
            models_invokeagentop.InvokeAgentA2AMessageTypedDict,
        ],
        task_id: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_invokeagentop.InvokeAgentContact,
                models_invokeagentop.InvokeAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_invokeagentop.InvokeAgentThread,
                models_invokeagentop.InvokeAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_invokeagentop.InvokeAgentMemory,
                models_invokeagentop.InvokeAgentMemoryTypedDict,
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.InvokeAgentA2ATaskResponse]:
        r"""Execute an agent task

        Invokes an agent to perform a task with the provided input message. The agent will process the request using its configured model and tools, maintaining context through memory stores if configured. Supports automatic model fallback on primary model failure, tool execution, knowledge base retrieval, and continuation of previous conversations. Returns a task response that can be used to track execution status and retrieve results.

        :param key: The key or ID of the agent to invoke
        :param message: The A2A message to send to the agent (user input or tool results)
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param metadata: Optional metadata for the agent invocation as key-value pairs that will be included in traces
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.InvokeAgentRequest(
            key=key,
            request_body=models.InvokeAgentRequestBody(
                task_id=task_id,
                message=utils.get_pydantic_model(message, models.InvokeAgentA2AMessage),
                variables=variables,
                contact=utils.get_pydantic_model(
                    contact, Optional[models.InvokeAgentContact]
                ),
                thread=utils.get_pydantic_model(
                    thread, Optional[models.InvokeAgentThread]
                ),
                memory=utils.get_pydantic_model(
                    memory, Optional[models.InvokeAgentMemory]
                ),
                metadata=metadata,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/agents/{key}/task",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "json",
                Optional[models.InvokeAgentRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="InvokeAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.InvokeAgentA2ATaskResponse], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def list(
        self,
        *,
        limit: Optional[float] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ListAgentsResponseBody]:
        r"""List agents

        Retrieves a comprehensive list of agents configured in your workspace. Supports pagination for large datasets and returns agents sorted by creation date (newest first). Each agent in the response includes its complete configuration: model settings with fallback options, instructions, tools, knowledge bases, memory stores, and execution parameters. Use pagination parameters to efficiently navigate through large collections of agents.

        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 200. When not provided, returns all agents without pagination.
        :param starting_after: A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
        :param ending_before: A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListAgentsRequest(
            limit=limit,
            starting_after=starting_after,
            ending_before=ending_before,
        )

        req = self._build_request(
            method="GET",
            path="/v2/agents/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ListAgents",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.ListAgentsResponseBody], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def list_async(
        self,
        *,
        limit: Optional[float] = None,
        starting_after: Optional[str] = None,
        ending_before: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ListAgentsResponseBody]:
        r"""List agents

        Retrieves a comprehensive list of agents configured in your workspace. Supports pagination for large datasets and returns agents sorted by creation date (newest first). Each agent in the response includes its complete configuration: model settings with fallback options, instructions, tools, knowledge bases, memory stores, and execution parameters. Use pagination parameters to efficiently navigate through large collections of agents.

        :param limit: A limit on the number of objects to be returned. Limit can range between 1 and 200. When not provided, returns all agents without pagination.
        :param starting_after: A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
        :param ending_before: A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ListAgentsRequest(
            limit=limit,
            starting_after=starting_after,
            ending_before=ending_before,
        )

        req = self._build_request_async(
            method="GET",
            path="/v2/agents/",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="ListAgents",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.ListAgentsResponseBody], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    def run(
        self,
        *,
        key: str,
        model: Union[
            models_runagentop.RunAgentModelConfiguration,
            models_runagentop.RunAgentModelConfigurationTypedDict,
        ],
        role: str,
        instructions: str,
        message: Union[
            models_runagentop.RunAgentA2AMessage,
            models_runagentop.RunAgentA2AMessageTypedDict,
        ],
        path: str,
        settings: Union[
            models_runagentop.RunAgentSettings,
            models_runagentop.RunAgentSettingsTypedDict,
        ],
        task_id: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_runagentop.RunAgentFallbackModelConfiguration],
                List[models_runagentop.RunAgentFallbackModelConfigurationTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_runagentop.RunAgentContact,
                models_runagentop.RunAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_runagentop.RunAgentThread,
                models_runagentop.RunAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_runagentop.RunAgentMemory,
                models_runagentop.RunAgentMemoryTypedDict,
            ]
        ] = None,
        description: Optional[str] = None,
        system_prompt: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_runagentop.RunAgentKnowledgeBases],
                List[models_runagentop.RunAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_runagentop.RunAgentTeamOfAgents],
                List[models_runagentop.RunAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.RunAgentA2ATaskResponse]:
        r"""Run an agent with configuration

        Executes an agent using inline configuration or references an existing agent. Supports dynamic agent creation where the system automatically manages agent versioning - reusing existing agents with matching configurations or creating new versions when configurations differ. Ideal for programmatic agent execution with flexible configuration management. The agent processes messages in A2A format with support for memory context, tool execution, and automatic model fallback on failure.

        :param key: A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
        :param model: Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
        :param role: Specifies the agent's function and area of expertise.
        :param instructions: Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
        :param message: The A2A format message containing the task for the agent to perform.
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param settings:
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param description: A brief summary of the agent's purpose.
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param memory_stores: Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
        :param knowledge_bases: Knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param metadata: Optional metadata for the agent run as key-value pairs that will be included in traces
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RunAgentRequestBody(
            key=key,
            task_id=task_id,
            model=utils.get_pydantic_model(model, models.RunAgentModelConfiguration),
            fallback_models=utils.get_pydantic_model(
                fallback_models,
                Optional[List[models.RunAgentFallbackModelConfiguration]],
            ),
            role=role,
            instructions=instructions,
            message=utils.get_pydantic_model(message, models.RunAgentA2AMessage),
            variables=variables,
            contact=utils.get_pydantic_model(contact, Optional[models.RunAgentContact]),
            thread=utils.get_pydantic_model(thread, Optional[models.RunAgentThread]),
            memory=utils.get_pydantic_model(memory, Optional[models.RunAgentMemory]),
            path=path,
            description=description,
            system_prompt=system_prompt,
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.RunAgentKnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.RunAgentTeamOfAgents]]
            ),
            settings=utils.get_pydantic_model(settings, models.RunAgentSettings),
            metadata=metadata,
        )

        req = self._build_request(
            method="POST",
            path="/v2/agents/run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.RunAgentRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RunAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.RunAgentA2ATaskResponse], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    async def run_async(
        self,
        *,
        key: str,
        model: Union[
            models_runagentop.RunAgentModelConfiguration,
            models_runagentop.RunAgentModelConfigurationTypedDict,
        ],
        role: str,
        instructions: str,
        message: Union[
            models_runagentop.RunAgentA2AMessage,
            models_runagentop.RunAgentA2AMessageTypedDict,
        ],
        path: str,
        settings: Union[
            models_runagentop.RunAgentSettings,
            models_runagentop.RunAgentSettingsTypedDict,
        ],
        task_id: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_runagentop.RunAgentFallbackModelConfiguration],
                List[models_runagentop.RunAgentFallbackModelConfigurationTypedDict],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_runagentop.RunAgentContact,
                models_runagentop.RunAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_runagentop.RunAgentThread,
                models_runagentop.RunAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_runagentop.RunAgentMemory,
                models_runagentop.RunAgentMemoryTypedDict,
            ]
        ] = None,
        description: Optional[str] = None,
        system_prompt: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_runagentop.RunAgentKnowledgeBases],
                List[models_runagentop.RunAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_runagentop.RunAgentTeamOfAgents],
                List[models_runagentop.RunAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.RunAgentA2ATaskResponse]:
        r"""Run an agent with configuration

        Executes an agent using inline configuration or references an existing agent. Supports dynamic agent creation where the system automatically manages agent versioning - reusing existing agents with matching configurations or creating new versions when configurations differ. Ideal for programmatic agent execution with flexible configuration management. The agent processes messages in A2A format with support for memory context, tool execution, and automatic model fallback on failure.

        :param key: A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
        :param model: Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
        :param role: Specifies the agent's function and area of expertise.
        :param instructions: Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
        :param message: The A2A format message containing the task for the agent to perform.
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param settings:
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param description: A brief summary of the agent's purpose.
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param memory_stores: Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
        :param knowledge_bases: Knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param metadata: Optional metadata for the agent run as key-value pairs that will be included in traces
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RunAgentRequestBody(
            key=key,
            task_id=task_id,
            model=utils.get_pydantic_model(model, models.RunAgentModelConfiguration),
            fallback_models=utils.get_pydantic_model(
                fallback_models,
                Optional[List[models.RunAgentFallbackModelConfiguration]],
            ),
            role=role,
            instructions=instructions,
            message=utils.get_pydantic_model(message, models.RunAgentA2AMessage),
            variables=variables,
            contact=utils.get_pydantic_model(contact, Optional[models.RunAgentContact]),
            thread=utils.get_pydantic_model(thread, Optional[models.RunAgentThread]),
            memory=utils.get_pydantic_model(memory, Optional[models.RunAgentMemory]),
            path=path,
            description=description,
            system_prompt=system_prompt,
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.RunAgentKnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.RunAgentTeamOfAgents]]
            ),
            settings=utils.get_pydantic_model(settings, models.RunAgentSettings),
            metadata=metadata,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/agents/run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.RunAgentRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="RunAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                Optional[models.RunAgentA2ATaskResponse], http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    def stream_run(
        self,
        *,
        key: str,
        model: Union[
            models_streamrunagentop.StreamRunAgentModelConfiguration,
            models_streamrunagentop.StreamRunAgentModelConfigurationTypedDict,
        ],
        role: str,
        instructions: str,
        message: Union[
            models_streamrunagentop.StreamRunAgentA2AMessage,
            models_streamrunagentop.StreamRunAgentA2AMessageTypedDict,
        ],
        path: str,
        settings: Union[
            models_streamrunagentop.StreamRunAgentSettings,
            models_streamrunagentop.StreamRunAgentSettingsTypedDict,
        ],
        task_id: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentFallbackModelConfiguration],
                List[
                    models_streamrunagentop.StreamRunAgentFallbackModelConfigurationTypedDict
                ],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentContact,
                models_streamrunagentop.StreamRunAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentThread,
                models_streamrunagentop.StreamRunAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentMemory,
                models_streamrunagentop.StreamRunAgentMemoryTypedDict,
            ]
        ] = None,
        description: Optional[str] = None,
        system_prompt: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentKnowledgeBases],
                List[models_streamrunagentop.StreamRunAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentTeamOfAgents],
                List[models_streamrunagentop.StreamRunAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        stream_timeout_seconds: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStream[models.StreamRunAgentResponseBody]]:
        r"""Run agent with streaming response

        Dynamically configures and executes an agent while streaming the interaction in real-time via Server-Sent Events (SSE). Intelligently manages agent versioning by reusing existing agents with matching configurations or creating new versions when configurations differ. Combines the flexibility of inline configuration with real-time streaming, making it ideal for dynamic agent interactions with live feedback. The stream provides continuous updates including message chunks, tool executions, and status changes until completion or timeout.

        :param key: A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
        :param model: Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
        :param role: Specifies the agent's function and area of expertise.
        :param instructions: Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
        :param message: The A2A format message containing the task for the agent to perform.
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param settings:
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param description: A brief summary of the agent's purpose.
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param memory_stores: Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
        :param knowledge_bases: Knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param metadata: Optional metadata for the agent run as key-value pairs that will be included in traces
        :param stream_timeout_seconds: Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamRunAgentRequestBody(
            key=key,
            task_id=task_id,
            model=utils.get_pydantic_model(
                model, models.StreamRunAgentModelConfiguration
            ),
            fallback_models=utils.get_pydantic_model(
                fallback_models,
                Optional[List[models.StreamRunAgentFallbackModelConfiguration]],
            ),
            role=role,
            instructions=instructions,
            message=utils.get_pydantic_model(message, models.StreamRunAgentA2AMessage),
            variables=variables,
            contact=utils.get_pydantic_model(
                contact, Optional[models.StreamRunAgentContact]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.StreamRunAgentThread]
            ),
            memory=utils.get_pydantic_model(
                memory, Optional[models.StreamRunAgentMemory]
            ),
            path=path,
            description=description,
            system_prompt=system_prompt,
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.StreamRunAgentKnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.StreamRunAgentTeamOfAgents]]
            ),
            settings=utils.get_pydantic_model(settings, models.StreamRunAgentSettings),
            metadata=metadata,
            stream_timeout_seconds=stream_timeout_seconds,
        )

        req = self._build_request(
            method="POST",
            path="/v2/agents/stream-run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.StreamRunAgentRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="StreamRunAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStream(
                http_res,
                lambda raw: utils.unmarshal_json(
                    raw, models.StreamRunAgentResponseBody
                ),
                sentinel="[DONE]",
                client_ref=self,
            )
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = unmarshal_json_response(
                models.StreamRunAgentAgentsResponseBodyData, http_res, http_res_text
            )
            raise models.StreamRunAgentAgentsResponseBody(
                response_data, http_res, http_res_text
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError("Unexpected response received", http_res, http_res_text)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    async def stream_run_async(
        self,
        *,
        key: str,
        model: Union[
            models_streamrunagentop.StreamRunAgentModelConfiguration,
            models_streamrunagentop.StreamRunAgentModelConfigurationTypedDict,
        ],
        role: str,
        instructions: str,
        message: Union[
            models_streamrunagentop.StreamRunAgentA2AMessage,
            models_streamrunagentop.StreamRunAgentA2AMessageTypedDict,
        ],
        path: str,
        settings: Union[
            models_streamrunagentop.StreamRunAgentSettings,
            models_streamrunagentop.StreamRunAgentSettingsTypedDict,
        ],
        task_id: Optional[str] = None,
        fallback_models: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentFallbackModelConfiguration],
                List[
                    models_streamrunagentop.StreamRunAgentFallbackModelConfigurationTypedDict
                ],
            ]
        ] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentContact,
                models_streamrunagentop.StreamRunAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentThread,
                models_streamrunagentop.StreamRunAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_streamrunagentop.StreamRunAgentMemory,
                models_streamrunagentop.StreamRunAgentMemoryTypedDict,
            ]
        ] = None,
        description: Optional[str] = None,
        system_prompt: Optional[str] = None,
        memory_stores: Optional[List[str]] = None,
        knowledge_bases: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentKnowledgeBases],
                List[models_streamrunagentop.StreamRunAgentKnowledgeBasesTypedDict],
            ]
        ] = None,
        team_of_agents: Optional[
            Union[
                List[models_streamrunagentop.StreamRunAgentTeamOfAgents],
                List[models_streamrunagentop.StreamRunAgentTeamOfAgentsTypedDict],
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        stream_timeout_seconds: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStreamAsync[models.StreamRunAgentResponseBody]]:
        r"""Run agent with streaming response

        Dynamically configures and executes an agent while streaming the interaction in real-time via Server-Sent Events (SSE). Intelligently manages agent versioning by reusing existing agents with matching configurations or creating new versions when configurations differ. Combines the flexibility of inline configuration with real-time streaming, making it ideal for dynamic agent interactions with live feedback. The stream provides continuous updates including message chunks, tool executions, and status changes until completion or timeout.

        :param key: A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
        :param model: Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
        :param role: Specifies the agent's function and area of expertise.
        :param instructions: Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
        :param message: The A2A format message containing the task for the agent to perform.
        :param path: Entity storage path in the format: `project/folder/subfolder/...`

            The first element identifies the project, followed by nested folders (auto-created as needed).

            With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
        :param settings:
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param fallback_models: Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param description: A brief summary of the agent's purpose.
        :param system_prompt: A custom system prompt template for the agent. If omitted, the default template is used.
        :param memory_stores: Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
        :param knowledge_bases: Knowledge base configurations for the agent to access
        :param team_of_agents: The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
        :param metadata: Optional metadata for the agent run as key-value pairs that will be included in traces
        :param stream_timeout_seconds: Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamRunAgentRequestBody(
            key=key,
            task_id=task_id,
            model=utils.get_pydantic_model(
                model, models.StreamRunAgentModelConfiguration
            ),
            fallback_models=utils.get_pydantic_model(
                fallback_models,
                Optional[List[models.StreamRunAgentFallbackModelConfiguration]],
            ),
            role=role,
            instructions=instructions,
            message=utils.get_pydantic_model(message, models.StreamRunAgentA2AMessage),
            variables=variables,
            contact=utils.get_pydantic_model(
                contact, Optional[models.StreamRunAgentContact]
            ),
            thread=utils.get_pydantic_model(
                thread, Optional[models.StreamRunAgentThread]
            ),
            memory=utils.get_pydantic_model(
                memory, Optional[models.StreamRunAgentMemory]
            ),
            path=path,
            description=description,
            system_prompt=system_prompt,
            memory_stores=memory_stores,
            knowledge_bases=utils.get_pydantic_model(
                knowledge_bases, Optional[List[models.StreamRunAgentKnowledgeBases]]
            ),
            team_of_agents=utils.get_pydantic_model(
                team_of_agents, Optional[List[models.StreamRunAgentTeamOfAgents]]
            ),
            settings=utils.get_pydantic_model(settings, models.StreamRunAgentSettings),
            metadata=metadata,
            stream_timeout_seconds=stream_timeout_seconds,
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/agents/stream-run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.StreamRunAgentRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="StreamRunAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStreamAsync(
                http_res,
                lambda raw: utils.unmarshal_json(
                    raw, models.StreamRunAgentResponseBody
                ),
                sentinel="[DONE]",
                client_ref=self,
            )
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = unmarshal_json_response(
                models.StreamRunAgentAgentsResponseBodyData, http_res, http_res_text
            )
            raise models.StreamRunAgentAgentsResponseBody(
                response_data, http_res, http_res_text
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError("Unexpected response received", http_res, http_res_text)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    def stream(
        self,
        *,
        key: str,
        message: Union[
            models_streamagentop.StreamAgentA2AMessage,
            models_streamagentop.StreamAgentA2AMessageTypedDict,
        ],
        task_id: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_streamagentop.StreamAgentContact,
                models_streamagentop.StreamAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_streamagentop.StreamAgentThread,
                models_streamagentop.StreamAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_streamagentop.StreamAgentMemory,
                models_streamagentop.StreamAgentMemoryTypedDict,
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        stream_timeout_seconds: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStream[models.StreamAgentResponseBody]]:
        r"""Stream agent execution in real-time

        Executes an agent and streams the interaction in real-time using Server-Sent Events (SSE). Provides live updates as the agent processes the request, including message chunks, tool calls, and execution status. Perfect for building responsive chat interfaces and monitoring agent progress. The stream continues until the agent completes its task, encounters an error, or reaches the configured timeout (default 30 minutes, configurable 1-3600 seconds).

        :param key: The key or ID of the agent to invoke
        :param message: The A2A message to send to the agent (user input or tool results)
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param metadata: Optional metadata for the agent invocation as key-value pairs that will be included in traces
        :param stream_timeout_seconds: Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamAgentRequest(
            key=key,
            request_body=models.StreamAgentRequestBody(
                task_id=task_id,
                message=utils.get_pydantic_model(message, models.StreamAgentA2AMessage),
                variables=variables,
                contact=utils.get_pydantic_model(
                    contact, Optional[models.StreamAgentContact]
                ),
                thread=utils.get_pydantic_model(
                    thread, Optional[models.StreamAgentThread]
                ),
                memory=utils.get_pydantic_model(
                    memory, Optional[models.StreamAgentMemory]
                ),
                metadata=metadata,
                stream_timeout_seconds=stream_timeout_seconds,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v2/agents/{key}/stream-task",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.StreamAgentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="StreamAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStream(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.StreamAgentResponseBody),
                sentinel="[DONE]",
                client_ref=self,
            )
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = utils.stream_to_text(http_res)
            response_data = unmarshal_json_response(
                models.StreamAgentAgentsResponseBodyData, http_res, http_res_text
            )
            raise models.StreamAgentAgentsResponseBody(
                response_data, http_res, http_res_text
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError("Unexpected response received", http_res, http_res_text)

    @deprecated(
        "warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
    )
    async def stream_async(
        self,
        *,
        key: str,
        message: Union[
            models_streamagentop.StreamAgentA2AMessage,
            models_streamagentop.StreamAgentA2AMessageTypedDict,
        ],
        task_id: Optional[str] = None,
        variables: Optional[Dict[str, Any]] = None,
        contact: Optional[
            Union[
                models_streamagentop.StreamAgentContact,
                models_streamagentop.StreamAgentContactTypedDict,
            ]
        ] = None,
        thread: Optional[
            Union[
                models_streamagentop.StreamAgentThread,
                models_streamagentop.StreamAgentThreadTypedDict,
            ]
        ] = None,
        memory: Optional[
            Union[
                models_streamagentop.StreamAgentMemory,
                models_streamagentop.StreamAgentMemoryTypedDict,
            ]
        ] = None,
        metadata: Optional[Dict[str, Any]] = None,
        stream_timeout_seconds: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[eventstreaming.EventStreamAsync[models.StreamAgentResponseBody]]:
        r"""Stream agent execution in real-time

        Executes an agent and streams the interaction in real-time using Server-Sent Events (SSE). Provides live updates as the agent processes the request, including message chunks, tool calls, and execution status. Perfect for building responsive chat interfaces and monitoring agent progress. The stream continues until the agent completes its task, encounters an error, or reaches the configured timeout (default 30 minutes, configurable 1-3600 seconds).

        :param key: The key or ID of the agent to invoke
        :param message: The A2A message to send to the agent (user input or tool results)
        :param task_id: Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
        :param variables: Optional variables for template replacement in system prompt, instructions, and messages
        :param contact: Information about the contact making the request. If the contact does not exist, it will be created automatically.
        :param thread: Thread information to group related requests
        :param memory: Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
        :param metadata: Optional metadata for the agent invocation as key-value pairs that will be included in traces
        :param stream_timeout_seconds: Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if timeout_ms is None:
            timeout_ms = 600000

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StreamAgentRequest(
            key=key,
            request_body=models.StreamAgentRequestBody(
                task_id=task_id,
                message=utils.get_pydantic_model(message, models.StreamAgentA2AMessage),
                variables=variables,
                contact=utils.get_pydantic_model(
                    contact, Optional[models.StreamAgentContact]
                ),
                thread=utils.get_pydantic_model(
                    thread, Optional[models.StreamAgentThread]
                ),
                memory=utils.get_pydantic_model(
                    memory, Optional[models.StreamAgentMemory]
                ),
                metadata=metadata,
                stream_timeout_seconds=stream_timeout_seconds,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v2/agents/{key}/stream-task",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="text/event-stream",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                models.StreamAgentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="StreamAgent",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["404", "4XX", "5XX"],
            stream=True,
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "text/event-stream"):
            return eventstreaming.EventStreamAsync(
                http_res,
                lambda raw: utils.unmarshal_json(raw, models.StreamAgentResponseBody),
                sentinel="[DONE]",
                client_ref=self,
            )
        if utils.match_response(http_res, "404", "application/json"):
            http_res_text = await utils.stream_to_text_async(http_res)
            response_data = unmarshal_json_response(
                models.StreamAgentAgentsResponseBodyData, http_res, http_res_text
            )
            raise models.StreamAgentAgentsResponseBody(
                response_data, http_res, http_res_text
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError("Unexpected response received", http_res, http_res_text)
